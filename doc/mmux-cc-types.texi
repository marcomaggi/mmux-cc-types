\input texinfo.tex
@c %**start of header
@setfilename mmux-cc-types.info
@settitle MMUX CC Types
@c %**end of header

@c @include version.texi
@include mmux-version.texi
@include macros.texi

@c page
@c ------------------------------------------------------------
@c Values.
@c ------------------------------------------------------------

@set TITLE                      MMUX CC Types

@c To be used as @value{PACKAGE} whenever we need to include the full
@c name of this package.
@set PACKAGE                    MMUX CC Types

@c To be used as @value{PACKAGE} whenever we need to include the
@c nickname of the project: the name that is used to compose the
@c distribution tarball or the web address.
@set PACKAGE_NICKNAME           mmux-cc-types

@c To be used as @value{AUTHOR} whenever we need to include the list of
@c authors of this document.
@set AUTHOR                     Marco Maggi

@c To be used as @value{AUTHOR_EMAIL} whenever we need to include the
@c email of the *single* author of this document.
@set AUTHOR_EMAIL               @email{mrc.mgg@@gmail.com}

@c To be used as @value{COPYRIGHT_YEARS} whenever we need to include the
@c list of copyright years.
@set COPYRIGHT_YEARS            2024, 2025

@c ------------------------------------------------------------

@set PackageAutoconfPrefix              MMUX_CC_TYPES
@set PackagePkgconfigModule             mmux-cc-types
@set PackageLibsVar                     @env{MMUX_CC_TYPES_LIBS}
@set PackageCflagsVar                   @env{MMUX_CC_TYPES_CFLAGS}
@c This is the stem of the library in "libmmux-cc-types.so".
@set PackageLibstem                     mmux-cc-types
@set PackageApiPrefixLower              mmux_
@set PackageApiPrefixUpper              MMUX_

@set PackageHeader                      mmux-cc-types.h
@set PackageHeaderFile                  @file{@value{PackageHeader}}

@set GithubUrl                 @url{https://github.com/marcomaggi/@value{PACKAGE_NICKNAME}}
@set DocumentationUrl          @url{https://marcomaggi.github.io/docs/@value{PACKAGE_NICKNAME}.html}

@c page
@c ------------------------------------------------------------
@c Local macros.
@c ------------------------------------------------------------

@ifinfo
@macro mbfl{}
@acronym{MBFL}
@end macro
@end ifinfo
@ifnotinfo
@macro mbfl{}
@acronym{mbfl}
@end macro
@end ifnotinfo

@ifinfo
@macro mmux{}
@acronym{MMUX}
@end macro
@end ifinfo
@ifnotinfo
@macro mmux{}
@acronym{mmux}
@end macro
@end ifnotinfo

@c page
@c ------------------------------------------------------------
@c Copyright notice.
@c ------------------------------------------------------------

@copying
This document describes version @value{MmuxPkgSemanticVersion} of @value{PACKAGE}, a C23 language
library meant to be used in foreign functions interfaces for higher--level languages.

The package targets @posix{} platforms.

This package is distributed under the terms of the @gnu{} General Public License (@gpl{}).

Development of this package takes place at:

@center @value{GithubUrl}

@noindent
Copyright @copyright{} @value{COPYRIGHT_YEARS} by @value{AUTHOR} @value{AUTHOR_EMAIL}

@quotation
Permission is granted to copy, distribute and/or modify this document under the terms of the @gnu{}
Free Documentation License, Version 1.3 or any later version published by the Free Software
Foundation; with Invariant Sections being ``@gnu{} Free Documentation License'' and ``@gnu{} Lesser
General Public License'', no Front--Cover Texts, and no Back--Cover Texts.  A copy of the license is
included in the section entitled ``@gnu{} Free Documentation License''.
@end quotation
@end copying

@c page
@c ------------------------------------------------------------
@c Headers.
@c ------------------------------------------------------------

@titlepage
@title @value{TITLE}
@subtitle Revision @value{MmuxPkgSemanticVersion}
@author @value{AUTHOR} @value{AUTHOR_EMAIL}
@page
@vskip 0pt plus 1filll
@insertcopying
@end titlepage

@c ------------------------------------------------------------

@ifinfo
@dircategory Development
@direntry
* mmux-cc-types: (mmux-cc-types).       C23language library handling core types.
@end direntry
@end ifinfo

@c ------------------------------------------------------------

@ignore
@syncodeindex tp cp
@syncodeindex vr cp
@syncodeindex fn cp
@end ignore

@c page
@ifnottex
@node Top
@top @value{TITLE}

@insertcopying

@menu
* overview::                    Overview of the package.
* version::                     Version functions.
* initialisation::              Library initialisation.
* config::                      How to configure code to link the library.
* typedefs::                    Type definitions.
* literals::                    Generating literal constants.
* makers::                      Making values.
* sizeof::                      Type sizes.
* limits::                      Type maximum and minimum values.
* constants::                   Functions returning constant values.
* stringrep::                   String representations of supported types.
* printing::                    Printing string representations.
* complex::                     Basic complex number operations.
* predicates::                  Type predicates.
* comparison::                  Comparison functions.
* arithmetics::                 Arithmetics operations.
* mathematics::                 Mathematics operations.
* bitwise::                     Bitwise operations.

Appendices

* Package License::             GNU General Public License.
* Documentation License::       GNU Free Documentation License.
* references::                  Bibliography and references.

Indexes

* concept index::               An entry for each concept.
* function index::              An entry for each function.
* variable index::              An entry for each variable.
* type index::                  An entry for each type.
@end menu
@end ifnottex

@c page
@node overview
@chapter Overview of the package


This document describes version @value{MmuxPkgSemanticVersion} of @value{PACKAGE}, a C23 language
library meant to be used in foreign functions interfaces for higher--level languages.

@cindex @value{PackageHeaderFile}, header file
@cindex Header file @value{PackageHeaderFile}
@value{PACKAGE} installs multiple header files, of which @value{PackageHeaderFile} is the main one,
exporting the whole library @api{}.  All the function names in the @api{} are prefixed with
@code{@value{PackageApiPrefixLower}}; all the preprocessor symbol names are prefixed with
@code{@value{PackageApiPrefixUpper}}; all the type names are prefixed with
@code{@value{PackageApiPrefixLower}} and suffixed with @code{_t}.

The library is installed under @code{$libdir}; for example:

@example
/usr/local/lib64/lib@value{PackageLibstem}.so
@end example

@noindent
C language header files are installed under @code{$includedir}, for example:

@example
/usr/local/include/@value{PackageHeaderFile}
@end example

@menu
* overview decimal::            Support for the @objtype{_DecimalN} types.
* overview stems::              Specifying C language types with their stem.
* overview errors::             Error handling.
* overview linking::            Linking code with the shared library.
@end menu

@c page
@node overview decimal
@section Support for the @objtype{_DecimalN} types


Support for the @objtype{_DecimalN} types is enabled if availability of such types is detected at
package--configuration time.  This package relies on the availability of the external package
@code{libdfp}.

@c page
@node overview stems
@section Specifying C language types with their stem


@cindex Type stems
@cindex @code{pointer}, type stem
@cindex @code{pointerc}, type stem
@cindex @code{char}, type stem
@cindex @code{schar}, type stem
@cindex @code{uchar}, type stem
@cindex @code{sshort}, type stem
@cindex @code{ushort}, type stem
@cindex @code{sint}, type stem
@cindex @code{uint}, type stem
@cindex @code{slong}, type stem
@cindex @code{ulong}, type stem
@cindex @code{sllong}, type stem
@cindex @code{ullong}, type stem
@cindex @code{float}, type stem
@cindex @code{double}, type stem
@cindex @code{ldouble}, type stem

@cindex @code{float32}, type stem
@cindex @code{float64}, type stem
@cindex @code{float128}, type stem

@cindex @code{float32x}, type stem
@cindex @code{float64x}, type stem
@cindex @code{float128x}, type stem

@cindex @code{decimal32}, type stem
@cindex @code{decimal64}, type stem
@cindex @code{decimal128}, type stem

@cindex @code{complexf}, type stem
@cindex @code{complexd}, type stem
@cindex @code{complexld}, type stem

@cindex @code{complexf32}, type stem
@cindex @code{complexf64}, type stem
@cindex @code{complexf128}, type stem

@cindex @code{complexf32x}, type stem
@cindex @code{complexf64x}, type stem
@cindex @code{complexf128x}, type stem

@cindex @code{complexd32}, type stem
@cindex @code{complexd64}, type stem
@cindex @code{complexd128}, type stem

@cindex @code{sint8}, type stem
@cindex @code{uint8}, type stem
@cindex @code{sint16}, type stem
@cindex @code{uint16}, type stem
@cindex @code{sint32}, type stem
@cindex @code{uint32}, type stem
@cindex @code{sint64}, type stem
@cindex @code{uint64}, type stem

@cindex @code{ssize}, type stem
@cindex @code{usize}, type stem
@cindex @code{sintmax}, type stem
@cindex @code{uintmax}, type stem
@cindex @code{sintptr}, type stem
@cindex @code{uintptr}, type stem
@cindex @code{ptrdiff}, type stem
@cindex @code{mode}, type stem
@cindex @code{off}, type stem
@cindex @code{pid}, type stem
@cindex @code{uid}, type stem
@cindex @code{gid}, type stem
@cindex @code{wchar}, type stem
@cindex @code{wint}, type stem
@cindex @code{time}, type stem
@cindex @code{socklen}, type stem
@cindex @code{rlim}, type stem


The following word definitions just alias the corresponding C language type; such uniform names are
useful when using preprocessor macros to generate code.

If @value{PACKAGE} supports a type: it blindly implements all the possible operations for it, even
when it looks like an operation does not make much sense.  A type is a type.

@macro MmuxDefineTypeStem{STEM,TYPE}
@deftp {Type Stem} \STEM\
Single--word specification of a C language type supported by this package.  It is an alias for the C
language type @code{\TYPE\}.
@end deftp

@end macro


@MmuxDefineTypeStem{pointer,void *}
@MmuxDefineTypeStem{pointerc,void const *}

@MmuxDefineTypeStem{char,char}
@MmuxDefineTypeStem{schar,signed char}
@MmuxDefineTypeStem{uchar,unsigned char}
@MmuxDefineTypeStem{sshort,signed short int}
@MmuxDefineTypeStem{ushort,unsigned short int}
@MmuxDefineTypeStem{sint,signed int}
@MmuxDefineTypeStem{uint,unsigned int}
@MmuxDefineTypeStem{slong,signed long}
@MmuxDefineTypeStem{ulong,unsigned long}
@MmuxDefineTypeStem{sllong,signed long long}
@MmuxDefineTypeStem{ullong,unsigned long long}
@MmuxDefineTypeStem{float,float}
@MmuxDefineTypeStem{double,double}
@MmuxDefineTypeStem{ldouble,long double}

@MmuxDefineTypeStem{float32, _Float32}
@MmuxDefineTypeStem{float64, _Float64}
@MmuxDefineTypeStem{float128, _Float128}

@MmuxDefineTypeStem{float32x, _Float32x}
@MmuxDefineTypeStem{float64x, _Float64x}
@MmuxDefineTypeStem{float128x, _Float128x}

@MmuxDefineTypeStem{decimal32, _Decimal32}
@MmuxDefineTypeStem{decimal64, _Decimal64}
@MmuxDefineTypeStem{decimal128, _Decimal128}

@MmuxDefineTypeStem{complexf,float complex}
@MmuxDefineTypeStem{complexd,double complex}
@MmuxDefineTypeStem{complexld,long double complex}

@MmuxDefineTypeStem{complexf32, _Float32 complex}
@MmuxDefineTypeStem{complexf64, _Float64 complex}
@MmuxDefineTypeStem{complexf128, _Float128 complex}

@MmuxDefineTypeStem{complexf32x, _Float32 complex}
@MmuxDefineTypeStem{complexf64x, _Float64x complex}
@MmuxDefineTypeStem{complexf128x, _Float128x complex}

@deftp {Type Stem} complexd32
Single--word specification of a C language type supported by this package.  It is an alias for a
non--standard C language type implementing complex floating--point numbers having
@objtype{_Decimal32} values as real and imaginary parts.
@end deftp


@deftp {Type Stem} complexd64
Single--word specification of a C language type supported by this package.  It is an alias for a
non--standard C language type implementing complex floating--point numbers having
@objtype{_Decimal64} values as real and imaginary parts.
@end deftp


@deftp {Type Stem} complexd128
Single--word specification of a C language type supported by this package.  It is an alias for a
non--standard C language type implementing complex floating--point numbers having
@objtype{_Decimal128} values as real and imaginary parts.
@end deftp

@MmuxDefineTypeStem{sint8,int8_t}
@MmuxDefineTypeStem{uint8,uint8_t}
@MmuxDefineTypeStem{sint16,int16_t}
@MmuxDefineTypeStem{uint16,uint16_t}
@MmuxDefineTypeStem{sint32,int32_t}
@MmuxDefineTypeStem{uint32,uint32_t}
@MmuxDefineTypeStem{sint64,int64_t}
@MmuxDefineTypeStem{uint64,uint64_t}

@MmuxDefineTypeStem{ssize,ssize_t}
@MmuxDefineTypeStem{usize,size_t}
@MmuxDefineTypeStem{sintmax, intmax_t}
@MmuxDefineTypeStem{uintmax, uintmax_t}
@MmuxDefineTypeStem{sintptr, intptr_t}
@MmuxDefineTypeStem{uintptr, uintptr_t}
@MmuxDefineTypeStem{ptrdiff, ptrdiff_t}
@MmuxDefineTypeStem{mode, mode_t}
@MmuxDefineTypeStem{off, off_t}
@MmuxDefineTypeStem{pid, pid_t}
@MmuxDefineTypeStem{uid, uid_t}
@MmuxDefineTypeStem{gid, gid_t}
@MmuxDefineTypeStem{wchar, wchar_t}
@MmuxDefineTypeStem{wint, wint_t}
@MmuxDefineTypeStem{time, time_t}
@MmuxDefineTypeStem{socklen, socklen_t}
@MmuxDefineTypeStem{rlim, rlim_t}

@c page
@node overview errors
@section Error handling


Most of the functions that can fail return a @objtype{bool} value: @cfalse{} when successful;
@ctrue{} when an error occurs.

The functions @cfunc{*_sprint_size} return @samp{-1} when an error occurred.

@c page

@include overview-linking.texi

@c page
@node version
@chapter Version functions


The installed libraries follow version numbering as established by the @gnu{} Autotools.  For an
explanation of interface numbers as managed by @gnu{} Libtool @xref{Libtool versioning, interface,
Libtool's versioning system, libtool, Shared library support for @gnu{}}.


@deftypefun {mmux_asciizcp_t} mmux_cc_types_version_string (void)
Return a pointer to a statically allocated @asciiz{} string representing the interface version
number.
@end deftypefun


@deftypefun mmux_sint_t mmux_cc_types_version_interface_current (void)
Return an integer representing the library interface current number.
@end deftypefun


@deftypefun mmux_sint_t mmux_cc_types_version_interface_revision (void)
Return an integer representing the library interface current revision number.
@end deftypefun


@deftypefun mmux_sint_t mmux_cc_types_version_interface_age (void)
Return an integer representing the library interface current age.
@end deftypefun

@c page
@node initialisation
@chapter Library initialisation


@deftypefun bool mmux_cc_types_init (void)
Initialise library's internal state.  When successful return @cfalse{}; otherwise return @ctrue{}.
@end deftypefun

@c page
@node config
@chapter How to configure code to link the library


@cindex Preprocessor constants, supported data types
@cindex Supported data types, preprocessor constants
@cindex Data types, preprocessor constants indicating support enabled


It happens that some rare platform may not implement the C language types @objtype{signed long long
int}, @objtype{unsigned long long int} and @objtype{long double}; more platforms may not implement
the extension types @objtype{_FloatN} and @objtype{_FloatNx}, which usually are:

@example
_Float32
_Float64
_Float128
_Float32x
_Float64x
_Float128x
@end example

@noindent
even more platforms may not implement the extension types @objtype{_DecimalN}, which usually are:

@example
_Decimal32
_Decimal64
_Decimal128
@end example

@noindent
these types are supported by @value{PACKAGE}.

This package assumes that: if the real floating--point types are supported, the corresponding
complex floating--point types are also supported; so the following types are supported:

@example
_Float32 complex
_Float64 complex
_Float128 complex
_Float32x complex
_Float64x complex
_Float128x complex
@end example

This package implements complex floating--point numbers whose real and imaginary parts are
@objtype{_DecimalN} numbers through a custom data structure.  Such support does not implement all
the usual functions.

At package--configuration time: @value{PACKAGE} tries to determine if these types are supported and
it defines the following symbols in its header files.

@c ------------------------------------------------------------------------

We can use the following C preprocessor symbols with code like:

@example
#ifdef MMUX_CC_TYPES_HAS_LDOUBLE
... /* the type is available */
#endif
@end example

@macro MmuxDefineCppSymbolHaveType{CPPSTEM}
@defvr {C Preprocessor Symbol} MMUX_CC_TYPES_HAS_\CPPSTEM\
If this preprocessor symbol is defined and its use expands to @samp{1}: the corresponding C language
type is supported.
@end defvr

@end macro

@MmuxDefineCppSymbolHaveType{SLLONG}
@MmuxDefineCppSymbolHaveType{ULLONG}
@MmuxDefineCppSymbolHaveType{LDOUBLE}
@MmuxDefineCppSymbolHaveType{FLOAT32}
@MmuxDefineCppSymbolHaveType{FLOAT64}
@MmuxDefineCppSymbolHaveType{FLOAT128}
@MmuxDefineCppSymbolHaveType{FLOAT32X}
@MmuxDefineCppSymbolHaveType{FLOAT64X}
@MmuxDefineCppSymbolHaveType{FLOAT128X}
@MmuxDefineCppSymbolHaveType{DECIMAL32}
@MmuxDefineCppSymbolHaveType{DECIMAL64}
@MmuxDefineCppSymbolHaveType{DECIMAL128}
@MmuxDefineCppSymbolHaveType{COMPLEXF32}
@MmuxDefineCppSymbolHaveType{COMPLEXF64}
@MmuxDefineCppSymbolHaveType{COMPLEXF128}
@MmuxDefineCppSymbolHaveType{COMPLEXF32X}
@MmuxDefineCppSymbolHaveType{COMPLEXF64X}
@MmuxDefineCppSymbolHaveType{COMPLEXF128X}
@MmuxDefineCppSymbolHaveType{COMPLEXD32}
@MmuxDefineCppSymbolHaveType{COMPLEXD64}
@MmuxDefineCppSymbolHaveType{COMPLEXD128}

@c page
@node typedefs
@chapter Type definitions


@cindex Type stems
@cindex @code{pointer}, type stem
@cindex @code{pointerc}, type stem
@cindex @code{char}, type stem
@cindex @code{schar}, type stem
@cindex @code{uchar}, type stem
@cindex @code{sshort}, type stem
@cindex @code{ushort}, type stem
@cindex @code{sint}, type stem
@cindex @code{uint}, type stem
@cindex @code{slong}, type stem
@cindex @code{ulong}, type stem
@cindex @code{sllong}, type stem
@cindex @code{ullong}, type stem
@cindex @code{float}, type stem
@cindex @code{double}, type stem
@cindex @code{ldouble}, type stem

@cindex @code{float32}, type stem
@cindex @code{float64}, type stem
@cindex @code{float128}, type stem

@cindex @code{float32x}, type stem
@cindex @code{float64x}, type stem
@cindex @code{float128x}, type stem

@cindex @code{decimal32}, type stem
@cindex @code{decimal64}, type stem
@cindex @code{decimal128}, type stem

@cindex @code{complexf}, type stem
@cindex @code{complexd}, type stem
@cindex @code{complexld}, type stem

@cindex @code{complexf32}, type stem
@cindex @code{complexf64}, type stem
@cindex @code{complexf128}, type stem

@cindex @code{complexf32x}, type stem
@cindex @code{complexf64x}, type stem
@cindex @code{complexf128x}, type stem

@cindex @code{complexd32}, type stem
@cindex @code{complexd64}, type stem
@cindex @code{complexd128}, type stem

@cindex @code{sint8}, type stem
@cindex @code{uint8}, type stem
@cindex @code{sint16}, type stem
@cindex @code{uint16}, type stem
@cindex @code{sint32}, type stem
@cindex @code{uint32}, type stem
@cindex @code{sint64}, type stem
@cindex @code{uint64}, type stem

@cindex @code{ssize}, type stem
@cindex @code{usize}, type stem
@cindex @code{sintmax}, type stem
@cindex @code{uintmax}, type stem
@cindex @code{sintptr}, type stem
@cindex @code{uintptr}, type stem
@cindex @code{ptrdiff}, type stem
@cindex @code{mode}, type stem
@cindex @code{off}, type stem
@cindex @code{pid}, type stem
@cindex @code{uid}, type stem
@cindex @code{gid}, type stem
@cindex @code{wchar}, type stem
@cindex @code{wint}, type stem
@cindex @code{time}, type stem
@cindex @code{socklen}, type stem
@cindex @code{rlim}, type stem

@cindex @code{asciizp}, type stem
@cindex @code{asciizpp}, type stem
@cindex @code{asciizppp}, type stem
@cindex @code{asciizcp}, type stem
@cindex @code{asciizcpp}, type stem
@cindex @code{asciizcppp}, type stem

The following type definitions just alias the corresponding C language type; the type name is
composed from a ``stem'': a single word representing the name of the type.  Such uniform names are
useful when using preprocessor macros to generate code.

@macro MmuxDefineCAliasTypedef{STEM,TYPE}
@deftp {Typedef} mmux_\STEM\_t
Type definition aliasing the C language type @objtype{\TYPE\}.
@end deftp

@end macro

@macro MmuxDefineCAliasTypedefPart{COMPLEXSTEM,PARTSTEM}
@deftp {Typedef} mmux_\COMPLEXSTEM\_part_t
Type definition aliasing the C language type @objtype{mmux_\PARTSTEM\_t}, representing the real and
imaginary parts type of @objtype{mmux_\COMPLEXSTEM\_t}.
@end deftp

@end macro

@c ------------------------------------------------------------------------

@MmuxDefineCAliasTypedef{pointer,void *}
@MmuxDefineCAliasTypedef{pointerc,void const *}

@MmuxDefineCAliasTypedef{char,char}
@MmuxDefineCAliasTypedef{schar,signed char}
@MmuxDefineCAliasTypedef{uchar,unsigned char}
@MmuxDefineCAliasTypedef{sshort,signed short int}
@MmuxDefineCAliasTypedef{ushort,unsigned short int}
@MmuxDefineCAliasTypedef{sint,signed int}
@MmuxDefineCAliasTypedef{uint,unsigned int}
@MmuxDefineCAliasTypedef{slong,signed long}
@MmuxDefineCAliasTypedef{ulong,unsigned long}
@MmuxDefineCAliasTypedef{sllong,signed long long}
@MmuxDefineCAliasTypedef{ullong,unsigned long long}
@MmuxDefineCAliasTypedef{float,float}
@MmuxDefineCAliasTypedef{double,double}
@MmuxDefineCAliasTypedef{ldouble,long double}

@MmuxDefineCAliasTypedef{float32, _Float32}
@MmuxDefineCAliasTypedef{float64, _Float64}
@MmuxDefineCAliasTypedef{float128, _Float128}

@MmuxDefineCAliasTypedef{float32x, _Float32x}
@MmuxDefineCAliasTypedef{float64x, _Float64x}
@MmuxDefineCAliasTypedef{float128x, _Float128x}

@MmuxDefineCAliasTypedef{decimal32, _Decimal32}
@MmuxDefineCAliasTypedef{decimal64, _Decimal64}
@MmuxDefineCAliasTypedef{decimal128, _Decimal128}

@MmuxDefineCAliasTypedef{complexf,float complex}
@MmuxDefineCAliasTypedef{complexd,double complex}
@MmuxDefineCAliasTypedef{complexld,long double complex}

@MmuxDefineCAliasTypedef{complexf32, _Float32 complex}
@MmuxDefineCAliasTypedef{complexf64, _Float64 complex}
@MmuxDefineCAliasTypedef{complexf128, _Float128 complex}

@MmuxDefineCAliasTypedef{complexf32x, _Float32x complex}
@MmuxDefineCAliasTypedef{complexf64x, _Float64x complex}
@MmuxDefineCAliasTypedef{complexf128x, _Float128x complex}

@deftp {Typedef} mmux_complexd32_t
Non--standard type definition representing a complex floating--point number whose real and imaginary
parts are values of type @objtype{mmux_decimal32_t}.
@end deftp

@deftp {Typedef} mmux_complexd64_t
Non--standard type definition representing a complex floating--point number whose real and imaginary
parts are values of type @objtype{mmux_decimal64_t}.
@end deftp

@deftp {Typedef} mmux_complexd128_t
Non--standard type definition representing a complex floating--point number whose real and imaginary
parts are values of type @objtype{mmux_decimal128_t}.
@end deftp

@MmuxDefineCAliasTypedef{sint8,int8_t}
@MmuxDefineCAliasTypedef{uint8,uint8_t}
@MmuxDefineCAliasTypedef{sint16,int16_t}
@MmuxDefineCAliasTypedef{uint16,uint16_t}
@MmuxDefineCAliasTypedef{sint32,int32_t}
@MmuxDefineCAliasTypedef{uint32,uint32_t}
@MmuxDefineCAliasTypedef{sint64,int64_t}
@MmuxDefineCAliasTypedef{uint64,uint64_t}

@deftp {Typedef Alias} mmux_byte_t
An alias for @objtype{mmux_sint8_t}.
@end deftp

@deftp {Typedef Alias} mmux_octet_t
An alias for @objtype{mmux_uint8_t}.
@end deftp

@MmuxDefineCAliasTypedef{ssize,ssize_t}
@MmuxDefineCAliasTypedef{usize,size_t}
@MmuxDefineCAliasTypedef{sintmax, intmax_t}
@MmuxDefineCAliasTypedef{uintmax, uintmax_t}
@MmuxDefineCAliasTypedef{sintptr, intptr_t}
@MmuxDefineCAliasTypedef{uintptr, uintptr_t}
@MmuxDefineCAliasTypedef{ptrdiff, ptrdiff_t}
@MmuxDefineCAliasTypedef{mode, mode_t}
@MmuxDefineCAliasTypedef{off, off_t}
@MmuxDefineCAliasTypedef{pid, pid_t}
@MmuxDefineCAliasTypedef{uid, uid_t}
@MmuxDefineCAliasTypedef{gid, gid_t}
@MmuxDefineCAliasTypedef{wchar, wchar_t}
@MmuxDefineCAliasTypedef{wint, wint_t}
@MmuxDefineCAliasTypedef{time, time_t}
@MmuxDefineCAliasTypedef{socklen, socklen_t}
@MmuxDefineCAliasTypedef{rlim, rlim_t}


@MmuxDefineCAliasTypedefPart{complexf,float}
@MmuxDefineCAliasTypedefPart{complexd,double}
@MmuxDefineCAliasTypedefPart{complexld,ldouble}

@MmuxDefineCAliasTypedefPart{complexf32, float32}
@MmuxDefineCAliasTypedefPart{complexf64, float64}
@MmuxDefineCAliasTypedefPart{complexf128, float128}

@MmuxDefineCAliasTypedefPart{complexf32x, float32x}
@MmuxDefineCAliasTypedefPart{complexf64x, float64x}
@MmuxDefineCAliasTypedefPart{complexf128x, float128x}

@MmuxDefineCAliasTypedefPart{complexd32, decimal32}
@MmuxDefineCAliasTypedefPart{complexd64, decimal64}
@MmuxDefineCAliasTypedefPart{complexd128, decimal128}

@c ------------------------------------------------------------------------

@deftp {Typedef} mmux_asciizp_t
@deftpx {Typedef} mmux_asciizcp_t
Type definitions aliasing, respectively, the C language types @objtype{mmux_schar_t *} and
@objtype{mmux_schar_t const *}; they are meant to reference an @asciiz{} string.
@end deftp


@deftp {Typedef} mmux_asciizpp_t
@deftpx {Typedef} mmux_asciizcpp_t
Type definition aliasing the C language types @objtype{mmux_char_t * *} and @objtype{mmux_char_t
const * *}.
@end deftp


@deftp {Typedef} mmux_asciizppp_t
@deftpx {Typedef} mmux_asciizcppp_t
Type definition aliasing the C language types @objtype{mmux_char_t * * *} and @objtype{mmux_char_t
const * * *}.
@end deftp

@c page
@node literals
@chapter Generating literal constants


When a type is supported by @value{PACKAGE}: the corresponding C preprocessor macro generating
literals is defined.  We have to remember that the argument of these macros must be a compatible
number specification.


@deffn {Preprocessor Macro} MMUX_UNSIGNED_LITERAL (@var{INTEGER_NUMBER_LITERAL})
Expand into an unsigned integer number literal, using the suffix @samp{U}; the full type of the
unsigned integer is unspecified.

@example
mmux_uchar_t    A = MMUX_UNSIGNED_LITERAL(123);
mmux_ushort_t   B = MMUX_UNSIGNED_LITERAL(123);
mmux_uint_t     C = MMUX_UNSIGNED_LITERAL(123);
mmux_ulong_t    D = MMUX_UNSIGNED_LITERAL(123);
@end example
@end deffn

@c ------------------------------------------------------------------------

@macro MmuxDefineFlonumLiteralMacro{UPCASESTEM,LOCASESTEM,TYPEDEF,SUFFIX,ARGUMENT,LITERALEXAMPLE}
@deffn {Preprocessor Macro} MMUX_\UPCASESTEM\_LITERAL (@var{\ARGUMENT\})
Expand into a number literal of type @objtype{\TYPEDEF\}, using the suffix @samp{\SUFFIX\}.

@example
mmux_\LOCASESTEM\_t  value = MMUX_\UPCASESTEM\_LITERAL(LITERALEXAMPLE);
@end example
@end deffn

@end macro

@MmuxDefineFlonumLiteralMacro{SLLONG,sllong,signed long long int,LL,INTEGER_NUMBER_LITERAL,123}
@MmuxDefineFlonumLiteralMacro{ULLONG,ullong,unsigned long long int,ULL,INTEGER_NUMBER_LITERAL,123}

@MmuxDefineFlonumLiteralMacro{FLOAT,float,float,F,FLOATING_POINT_NUMBER_LITERAL,0.123}
@MmuxDefineFlonumLiteralMacro{LDOUBLE,ldouble,ldouble,L,FLOATING_POINT_NUMBER_LITERAL,0.123}

@MmuxDefineFlonumLiteralMacro{FLOAT32,float32,_Float32,f32,FLOATING_POINT_NUMBER_LITERAL,0.123}
@MmuxDefineFlonumLiteralMacro{FLOAT64,float64,_Float64,f64,FLOATING_POINT_NUMBER_LITERAL,0.123}
@MmuxDefineFlonumLiteralMacro{FLOAT128,float128,_Float128,f128,FLOATING_POINT_NUMBER_LITERAL,0.123}

@MmuxDefineFlonumLiteralMacro{FLOAT32X,float32x,_Float32x,f32x,FLOATING_POINT_NUMBER_LITERAL,0.123}
@MmuxDefineFlonumLiteralMacro{FLOAT64X,float64x,_Float64x,f64x,FLOATING_POINT_NUMBER_LITERAL,0.123}
@MmuxDefineFlonumLiteralMacro{FLOAT128X,float128x,_Float128x,f128x,FLOATING_POINT_NUMBER_LITERAL,0.123}

@MmuxDefineFlonumLiteralMacro{DECIMAL32,decimal32,_Decimal32,DF,FLOATING_POINT_NUMBER_LITERAL,0.123}
@MmuxDefineFlonumLiteralMacro{DECIMAL64,decimal64,_Decimal64,DD,FLOATING_POINT_NUMBER_LITERAL,0.123}
@MmuxDefineFlonumLiteralMacro{DECIMAL128,decimal128,_Decimal128,DL,FLOATING_POINT_NUMBER_LITERAL,0.123}

@c page
@node makers
@chapter Making values


The @dfn{maker} macros are used as follows:

@example
auto    A = mmux_sint_make(123);
auto    B = mmux_uint_make(123);
auto    C = mmux_ldouble_make(0.123);
auto    D = mmux_mode_make(MMUX_LIBC_O_RDWR);
@end example

@noindent
the macros expand as follows:

@example
mmux_sint_make(123)       @expansion{} ((mmux_sint_t)(0.123))
mmux_uint_make(123)       @expansion{} ((mmux_uint_t)(MMUX_UNSIGNED_LITERAL(123)))
mmux_ldouble_make(0.123)  @expansion{} ((mmux_ldouble_t)(MMUX_LDOUBLE_LITERAL(0.123)))
@end example

@noindent
there are no maker macros for complex types, because for those values we have to use the proper
constructor functions like @cfunc{mmux_complexd_make_rectangular}, @ref{complex make, Constructing
complex numbers}.


@macro MmuxDefineCMacroMaker{STEM}
@deftypefn {Preprocessor Macro} mmux_\STEM\_t mmux_\STEM\_make (@var{VALUE})
Return a value of the given type.
@end deftypefn

@end macro


@MmuxDefineCMacroMaker{pointer}
@MmuxDefineCMacroMaker{pointerc}

@MmuxDefineCMacroMaker{char}
@MmuxDefineCMacroMaker{schar}
@MmuxDefineCMacroMaker{uchar}
@MmuxDefineCMacroMaker{sshort}
@MmuxDefineCMacroMaker{ushort}
@MmuxDefineCMacroMaker{sint}
@MmuxDefineCMacroMaker{uint}
@MmuxDefineCMacroMaker{slong}
@MmuxDefineCMacroMaker{ulong}
@MmuxDefineCMacroMaker{sllong}
@MmuxDefineCMacroMaker{ullong}
@MmuxDefineCMacroMaker{float}
@MmuxDefineCMacroMaker{double}
@MmuxDefineCMacroMaker{ldouble}

@MmuxDefineCMacroMaker{float32}
@MmuxDefineCMacroMaker{float64}
@MmuxDefineCMacroMaker{float128}

@MmuxDefineCMacroMaker{float32x}
@MmuxDefineCMacroMaker{float64x}
@MmuxDefineCMacroMaker{float128x}

@MmuxDefineCMacroMaker{decimal32}
@MmuxDefineCMacroMaker{decimal64}
@MmuxDefineCMacroMaker{decimal128}

@MmuxDefineCMacroMaker{sint8}
@MmuxDefineCMacroMaker{uint8}
@MmuxDefineCMacroMaker{sint16}
@MmuxDefineCMacroMaker{uint16}
@MmuxDefineCMacroMaker{sint32}
@MmuxDefineCMacroMaker{uint32}
@MmuxDefineCMacroMaker{sint64}
@MmuxDefineCMacroMaker{uint64}

@MmuxDefineCMacroMaker{ssize}
@MmuxDefineCMacroMaker{usize}
@MmuxDefineCMacroMaker{sintmax}
@MmuxDefineCMacroMaker{uintmax}
@MmuxDefineCMacroMaker{sintptr}
@MmuxDefineCMacroMaker{uintptr}
@MmuxDefineCMacroMaker{ptrdiff}
@MmuxDefineCMacroMaker{mode}
@MmuxDefineCMacroMaker{off}
@MmuxDefineCMacroMaker{pid}
@MmuxDefineCMacroMaker{uid}
@MmuxDefineCMacroMaker{gid}
@MmuxDefineCMacroMaker{wchar}
@MmuxDefineCMacroMaker{wint}
@MmuxDefineCMacroMaker{time}
@MmuxDefineCMacroMaker{socklen}
@MmuxDefineCMacroMaker{rlim}

@MmuxDefineCMacroMaker{asciip}
@MmuxDefineCMacroMaker{asciipp}
@MmuxDefineCMacroMaker{asciippp}

@MmuxDefineCMacroMaker{asciizp}
@MmuxDefineCMacroMaker{asciizpp}
@MmuxDefineCMacroMaker{asciizppp}

@MmuxDefineCMacroMaker{asciicp}
@MmuxDefineCMacroMaker{asciicpp}
@MmuxDefineCMacroMaker{asciicppp}

@MmuxDefineCMacroMaker{asciizcp}
@MmuxDefineCMacroMaker{asciizcpp}
@MmuxDefineCMacroMaker{asciizcppp}

@c page
@node sizeof
@chapter Type size measured in bytes


@macro MmuxDefineCFunctionSizeof{STEM}
@deftypefun int mmux_\STEM\_sizeof (void)
Return a positive integer representing the size in bytes of the C language type
@objtype{mmux_\STEM\_t}.
@end deftypefun

@end macro


@MmuxDefineCFunctionSizeof{pointer}

@MmuxDefineCFunctionSizeof{char}
@MmuxDefineCFunctionSizeof{schar}
@MmuxDefineCFunctionSizeof{uchar}
@MmuxDefineCFunctionSizeof{sshort}
@MmuxDefineCFunctionSizeof{ushort}
@MmuxDefineCFunctionSizeof{sint}
@MmuxDefineCFunctionSizeof{uint}
@MmuxDefineCFunctionSizeof{slong}
@MmuxDefineCFunctionSizeof{ulong}
@MmuxDefineCFunctionSizeof{sllong}
@MmuxDefineCFunctionSizeof{ullong}
@MmuxDefineCFunctionSizeof{float}
@MmuxDefineCFunctionSizeof{double}
@MmuxDefineCFunctionSizeof{ldouble}

@MmuxDefineCFunctionSizeof{float32}
@MmuxDefineCFunctionSizeof{float64}
@MmuxDefineCFunctionSizeof{float128}

@MmuxDefineCFunctionSizeof{float32x}
@MmuxDefineCFunctionSizeof{float64x}
@MmuxDefineCFunctionSizeof{float128x}

@MmuxDefineCFunctionSizeof{decimal32}
@MmuxDefineCFunctionSizeof{decimal64}
@MmuxDefineCFunctionSizeof{decimal128}

@MmuxDefineCFunctionSizeof{complexf}
@MmuxDefineCFunctionSizeof{complexd}
@MmuxDefineCFunctionSizeof{complexld}

@MmuxDefineCFunctionSizeof{complexf32}
@MmuxDefineCFunctionSizeof{complexf64}
@MmuxDefineCFunctionSizeof{complexf128}

@MmuxDefineCFunctionSizeof{complexf32x}
@MmuxDefineCFunctionSizeof{complexf64x}
@MmuxDefineCFunctionSizeof{complexf128x}

@MmuxDefineCFunctionSizeof{complexd32}
@MmuxDefineCFunctionSizeof{complexd64}
@MmuxDefineCFunctionSizeof{complexd128}

@MmuxDefineCFunctionSizeof{sint8}
@MmuxDefineCFunctionSizeof{uint8}
@MmuxDefineCFunctionSizeof{sint16}
@MmuxDefineCFunctionSizeof{uint16}
@MmuxDefineCFunctionSizeof{sint32}
@MmuxDefineCFunctionSizeof{uint32}
@MmuxDefineCFunctionSizeof{sint64}
@MmuxDefineCFunctionSizeof{uint64}

@MmuxDefineCFunctionSizeof{ssize}
@MmuxDefineCFunctionSizeof{usize}
@MmuxDefineCFunctionSizeof{sintmax}
@MmuxDefineCFunctionSizeof{uintmax}
@MmuxDefineCFunctionSizeof{sintptr}
@MmuxDefineCFunctionSizeof{uintptr}
@MmuxDefineCFunctionSizeof{ptrdiff}
@MmuxDefineCFunctionSizeof{mode}
@MmuxDefineCFunctionSizeof{off}
@MmuxDefineCFunctionSizeof{pid}
@MmuxDefineCFunctionSizeof{uid}
@MmuxDefineCFunctionSizeof{gid}
@MmuxDefineCFunctionSizeof{wchar}
@MmuxDefineCFunctionSizeof{wint}
@MmuxDefineCFunctionSizeof{time}
@MmuxDefineCFunctionSizeof{socklen}
@MmuxDefineCFunctionSizeof{rlim}

@c page
@node limits
@chapter Type maximum and minimum values


The following functions return the maximum and minimum values representable by a C language real
number type; this is true even for floating--point numbers: the returned minimum value is the
minimum negative representable value.  This is different from the standard C language constants like
@code{FLT_MIN}, @code{DBL_MIN}, @code{LDBL_MIN}, which represent some sort of minimum representable
positive value.


@macro MmuxDefineCFunctionMaximum{STEM}
@deftypefun mmux_\STEM\_t mmux_\STEM\_maximum (void)
@deftypefunx mmux_\STEM\_t mmux_\STEM\_minimum (void)
Return the maximum and minimum values representable by the range of values of the type
@objtype{mmux_\STEM\_t}.
@end deftypefun

@end macro


@MmuxDefineCFunctionMaximum{pointer}

@MmuxDefineCFunctionMaximum{char}
@MmuxDefineCFunctionMaximum{schar}
@MmuxDefineCFunctionMaximum{uchar}
@MmuxDefineCFunctionMaximum{sshort}
@MmuxDefineCFunctionMaximum{ushort}
@MmuxDefineCFunctionMaximum{sint}
@MmuxDefineCFunctionMaximum{uint}
@MmuxDefineCFunctionMaximum{slong}
@MmuxDefineCFunctionMaximum{ulong}
@MmuxDefineCFunctionMaximum{sllong}
@MmuxDefineCFunctionMaximum{ullong}
@MmuxDefineCFunctionMaximum{float}
@MmuxDefineCFunctionMaximum{double}
@MmuxDefineCFunctionMaximum{ldouble}

@MmuxDefineCFunctionMaximum{float32}
@MmuxDefineCFunctionMaximum{float64}
@MmuxDefineCFunctionMaximum{float128}

@MmuxDefineCFunctionMaximum{float32x}
@MmuxDefineCFunctionMaximum{float64x}
@MmuxDefineCFunctionMaximum{float128x}

@MmuxDefineCFunctionMaximum{decimal32}
@MmuxDefineCFunctionMaximum{decimal64}
@MmuxDefineCFunctionMaximum{decimal128}

@MmuxDefineCFunctionMaximum{sint8}
@MmuxDefineCFunctionMaximum{uint8}
@MmuxDefineCFunctionMaximum{sint16}
@MmuxDefineCFunctionMaximum{uint16}
@MmuxDefineCFunctionMaximum{sint32}
@MmuxDefineCFunctionMaximum{uint32}
@MmuxDefineCFunctionMaximum{sint64}
@MmuxDefineCFunctionMaximum{uint64}

@MmuxDefineCFunctionMaximum{ssize}
@MmuxDefineCFunctionMaximum{usize}
@MmuxDefineCFunctionMaximum{sintmax}
@MmuxDefineCFunctionMaximum{uintmax}
@MmuxDefineCFunctionMaximum{sintptr}
@MmuxDefineCFunctionMaximum{uintptr}
@MmuxDefineCFunctionMaximum{ptrdiff}
@MmuxDefineCFunctionMaximum{mode}
@MmuxDefineCFunctionMaximum{off}
@MmuxDefineCFunctionMaximum{pid}
@MmuxDefineCFunctionMaximum{uid}
@MmuxDefineCFunctionMaximum{gid}
@MmuxDefineCFunctionMaximum{wchar}
@MmuxDefineCFunctionMaximum{wint}
@MmuxDefineCFunctionMaximum{time}
@MmuxDefineCFunctionMaximum{socklen}
@MmuxDefineCFunctionMaximum{rlim}

@c page
@node constants
@chapter Functions returning constant values


@macro MmuxDefineConstantFunction{STEM,FUNCSTEM,EXPR}
@deftypefun mmux_\STEM\_t mmux_\STEM\_constant_\FUNCSTEM\ (void)
Return a constant value corresponding to @math{\EXPR\}.
@end deftypefun

@end macro

@c ------------------------------------------------------------------------

@macro MmuxDefineConstantFunctions{STEM}
@MmuxDefineConstantFunction{\STEM\,E,e}
@MmuxDefineConstantFunction{\STEM\,LOG2E,log_2(e)}
@MmuxDefineConstantFunction{\STEM\,LOG10E,log_10(e)}
@MmuxDefineConstantFunction{\STEM\,LN2,ln(2)}
@MmuxDefineConstantFunction{\STEM\,LN10,ln(10)}
@MmuxDefineConstantFunction{\STEM\,PI,pi}
@MmuxDefineConstantFunction{\STEM\,PI_2,pi/2}
@MmuxDefineConstantFunction{\STEM\,PI_4,pi/4}
@MmuxDefineConstantFunction{\STEM\,1_PI,1/pi}
@MmuxDefineConstantFunction{\STEM\,2_PI,2/pi}
@MmuxDefineConstantFunction{\STEM\,2_SQRTPI,2/sqrt(pi)}
@MmuxDefineConstantFunction{\STEM\,SQRT2,sqrt(2)}
@MmuxDefineConstantFunction{\STEM\,SQRT1_2,sqrt(1/2)}
@end macro

@c ------------------------------------------------------------------------

@MmuxDefineConstantFunctions{float}
@MmuxDefineConstantFunctions{double}
@MmuxDefineConstantFunctions{ldouble}

@MmuxDefineConstantFunctions{float32}
@MmuxDefineConstantFunctions{float64}
@MmuxDefineConstantFunctions{float128}

@MmuxDefineConstantFunctions{float32x}
@MmuxDefineConstantFunctions{float64x}
@MmuxDefineConstantFunctions{float128x}

@MmuxDefineConstantFunctions{decimal32}
@MmuxDefineConstantFunctions{decimal64}
@MmuxDefineConstantFunctions{decimal128}

@c page
@node stringrep
@chapter String representations of supported types


@menu
* stringrep complex::           Peculiar string representation for complex floating--point numbers.
* stringrep predicates::        Type predicates for string representations.
* stringrep formats::           Selecting the printing format for floating--point numbers.
* stringrep parsers::           Parsing string representations of C language types.
* stringrep sprinters::         Printing string representations of C language types.
@end menu

@c page
@node stringrep complex
@section Peculiar string representation for complex floating--point numbers


This package's ``official'' representation of complex numbers is like this:

@example
(1.2)+i*(3.4)
@end example

@noindent
in which both the real part @samp{1.2} and the imaginary part @samp{3.4} are enclosed in
parentheses; this way any format for the real numbers can be used in the string representation of
complex numbers reducing the work needed by human eyes to parse the expression.  Example:

@example
(0x1.3333333333333p+0)+i*(0x1.b333333333333p+1)
@end example

@c page
@node stringrep predicates
@section Type predicates for string representations


@macro MmuxDefineCFunctionPredicate{STEM}
@deftypefun bool mmux_string_is_\STEM\ (char const * @var{str})
Return @ctrue{} if @var{str} references the string representation, in @asciiz{} format, of a value
of type @objtype{mmux_\STEM\_t}; otherwise return @cfalse{}.
@end deftypefun

@end macro


@MmuxDefineCFunctionPredicate{pointer}

@MmuxDefineCFunctionPredicate{char}
@MmuxDefineCFunctionPredicate{schar}
@MmuxDefineCFunctionPredicate{uchar}
@MmuxDefineCFunctionPredicate{sshort}
@MmuxDefineCFunctionPredicate{ushort}
@MmuxDefineCFunctionPredicate{sint}
@MmuxDefineCFunctionPredicate{uint}
@MmuxDefineCFunctionPredicate{slong}
@MmuxDefineCFunctionPredicate{ulong}
@MmuxDefineCFunctionPredicate{sllong}
@MmuxDefineCFunctionPredicate{ullong}
@MmuxDefineCFunctionPredicate{float}
@MmuxDefineCFunctionPredicate{double}
@MmuxDefineCFunctionPredicate{ldouble}

@MmuxDefineCFunctionPredicate{float32}
@MmuxDefineCFunctionPredicate{float64}
@MmuxDefineCFunctionPredicate{float128}

@MmuxDefineCFunctionPredicate{float32x}
@MmuxDefineCFunctionPredicate{float64x}
@MmuxDefineCFunctionPredicate{float128x}

@MmuxDefineCFunctionPredicate{decimal32}
@MmuxDefineCFunctionPredicate{decimal64}
@MmuxDefineCFunctionPredicate{decimal128}

@MmuxDefineCFunctionPredicate{complexf}
@MmuxDefineCFunctionPredicate{complexd}
@MmuxDefineCFunctionPredicate{complexld}

@MmuxDefineCFunctionPredicate{complexf32}
@MmuxDefineCFunctionPredicate{complexf64}
@MmuxDefineCFunctionPredicate{complexf128}

@MmuxDefineCFunctionPredicate{complexf32x}
@MmuxDefineCFunctionPredicate{complexf64x}
@MmuxDefineCFunctionPredicate{complexf128x}

@MmuxDefineCFunctionPredicate{complexd32}
@MmuxDefineCFunctionPredicate{complexd64}
@MmuxDefineCFunctionPredicate{complexd128}

@MmuxDefineCFunctionPredicate{sint8}
@MmuxDefineCFunctionPredicate{uint8}
@MmuxDefineCFunctionPredicate{sint16}
@MmuxDefineCFunctionPredicate{uint16}
@MmuxDefineCFunctionPredicate{sint32}
@MmuxDefineCFunctionPredicate{uint32}
@MmuxDefineCFunctionPredicate{sint64}
@MmuxDefineCFunctionPredicate{uint64}

@MmuxDefineCFunctionPredicate{ssize}
@MmuxDefineCFunctionPredicate{usize}
@MmuxDefineCFunctionPredicate{sintmax}
@MmuxDefineCFunctionPredicate{uintmax}
@MmuxDefineCFunctionPredicate{sintptr}
@MmuxDefineCFunctionPredicate{uintptr}
@MmuxDefineCFunctionPredicate{ptrdiff}
@MmuxDefineCFunctionPredicate{mode}
@MmuxDefineCFunctionPredicate{off}
@MmuxDefineCFunctionPredicate{pid}
@MmuxDefineCFunctionPredicate{uid}
@MmuxDefineCFunctionPredicate{gid}
@MmuxDefineCFunctionPredicate{wchar}
@MmuxDefineCFunctionPredicate{wint}
@MmuxDefineCFunctionPredicate{time}
@MmuxDefineCFunctionPredicate{socklen}
@MmuxDefineCFunctionPredicate{rlim}

@c page
@node stringrep formats
@section Selecting the printing format for floating--point numbers


@cindex Printing format for floating--point numbers
@cindex Formatting floating--point numbers


@value{PACKAGE} implements @cfunc{mmux_*_sprint} functions to convert numbers from a binary
representation to the corresponding @asciiz{} string representation.  For floating--point numbers
the following facilities are implemented to select the string format.

To select an output format for the result of the @cfunc{mmux_double_sprint} function, we do:

@example
char const * fmt = "%.4f";

if (mmux_double_set_output_format(fmt, __func__)) @{
  /* error: invalid format */
@}

/* call "mmux_double_sprint()" */
@end example

To save the current format and restore it later we do:

@example
char saved_fmt[MMUX_CC_TYPES_FLOAT_FORMAT_MAXLEN];

mmux_double_save_output_format(saved_fmt);
@{
  char const * fmt = "%.4f";

  if (mmux_double_set_output_format(fmt, __func__)) @{
    /* error: invalid format */
  @}
  /* call "mmux_double_sprint()" */
@}
mmux_double_set_output_format(saved_fmt, __func__);
@end example


String representations of complex floating--point numbers are composed using the format selected for
the corresponding real floating--point type.

For all the following functions:

@itemize
@item
If the format string @var{OUTPUT_FORMAT} is valid: it is duplicated into an internal library state
and the setter function returns @cfalse{}; otherwise nothing happens and the setter function returns
@ctrue{}.

@item
The string referenced by the pointer returned by the getter functions must not be mutated.

@item
The format--saving functions expect the destination buffer to be capable of holding a
@code{MMUX_CC_TYPES_FLOAT_FORMAT_MAXLEN} characters, nul--termination character included.
@end itemize


@defvr {C Preprocessor Symbol} MMUX_CC_TYPES_FLOAT_FORMAT_MAXLEN
The number of bytes required to hold a format specification string, @strong{including} the
terminating nul character.
@end defvr

@c ------------------------------------------------------------------------

@macro MmuxRealSelectOutputFormatFunction{STEM,DEFAULTFORMAT}
@deftypefun bool mmux_\STEM\_set_output_format (char const * @var{OUTPUT_FORMAT}, char const * @var{CALLER_NAME})
@deftypefunx {char const *} mmux_\STEM\_ref_output_format (void)
@deftypefunx void mmux_\STEM\_save_output_format (char * @var{DEST})
Select, retrieve or save the current format for string representations of floating--point numbers of
type @objtype{\STEM\}.  The default format is @samp{\DEFAULTFORMAT\}.

If the argument @var{CALLER_NAME} is not @cnull{}: when an error occurs an error message is
displayed on @stderr{} using @var{CALLER_NAME} as source of the message itself; it is meant to be
the expansion of the preprocessor macro @code{__func__} or something similar.
@end deftypefun

@end macro

@MmuxRealSelectOutputFormatFunction{float, %A}
@MmuxRealSelectOutputFormatFunction{double, %A}
@MmuxRealSelectOutputFormatFunction{ldouble, %A}

@MmuxRealSelectOutputFormatFunction{float32, %A}
@MmuxRealSelectOutputFormatFunction{float64, %A}
@MmuxRealSelectOutputFormatFunction{float128, %A}

@MmuxRealSelectOutputFormatFunction{float32x, %A}
@MmuxRealSelectOutputFormatFunction{float64x, %A}
@MmuxRealSelectOutputFormatFunction{float128x, %A}

@MmuxRealSelectOutputFormatFunction{decimal32, %f}
@MmuxRealSelectOutputFormatFunction{decimal64, %f}
@MmuxRealSelectOutputFormatFunction{decimal128, %f}

@c page
@node stringrep parsers
@section Parsing string representations of C language types


Type parsers convert string representations to C language values; to parse a @objtype{mmux_sint_t}
representation we do:

@example
char const *    arg = "123";
mmux_sint_t     value;
bool            rv;

rv = mmux_sint_parse(&value, arg, __func__);
@end example


@macro MmuxDefineCFunctionParser{STEM}
@deftypefun bool mmux_\STEM\_parse (mmux_\STEM\_t * @var{PTR}, char const * @var{STR}, char const * @var{WHO})
Parse a string which is meant to be the representation of a C language type @objtype{\STEM\}; when
successful store the result in the variable referenced by @var{PTR}, then return @cfalse{};
otherwise leave @var{PTR} untouched and return @ctrue{}.

In case of failure: if @var{WHO} is not @cnull{}, print on @stderr{} a message describing the
parsing error; @var{WHO} must reference an @asciiz{} string representing the entity that requested
the parsing operation, for example: the name of a C function.
@end deftypefun

@end macro


@MmuxDefineCFunctionParser{pointer}

@MmuxDefineCFunctionParser{char}
@MmuxDefineCFunctionParser{schar}
@MmuxDefineCFunctionParser{uchar}
@MmuxDefineCFunctionParser{sshort}
@MmuxDefineCFunctionParser{ushort}
@MmuxDefineCFunctionParser{sint}
@MmuxDefineCFunctionParser{uint}
@MmuxDefineCFunctionParser{slong}
@MmuxDefineCFunctionParser{ulong}
@MmuxDefineCFunctionParser{sllong}
@MmuxDefineCFunctionParser{ullong}
@MmuxDefineCFunctionParser{float}
@MmuxDefineCFunctionParser{double}
@MmuxDefineCFunctionParser{ldouble}

@MmuxDefineCFunctionParser{float32}
@MmuxDefineCFunctionParser{float64}
@MmuxDefineCFunctionParser{float128}

@MmuxDefineCFunctionParser{float32x}
@MmuxDefineCFunctionParser{float64x}
@MmuxDefineCFunctionParser{float128x}

@MmuxDefineCFunctionParser{decimal32}
@MmuxDefineCFunctionParser{decimal64}
@MmuxDefineCFunctionParser{decimal128}

@MmuxDefineCFunctionParser{complexf}
@MmuxDefineCFunctionParser{complexd}
@MmuxDefineCFunctionParser{complexld}

@MmuxDefineCFunctionParser{complexf32}
@MmuxDefineCFunctionParser{complexf64}
@MmuxDefineCFunctionParser{complexf128}

@MmuxDefineCFunctionParser{complexf32x}
@MmuxDefineCFunctionParser{complexf64x}
@MmuxDefineCFunctionParser{complexf128x}

@MmuxDefineCFunctionParser{complexd32}
@MmuxDefineCFunctionParser{complexd64}
@MmuxDefineCFunctionParser{complexd128}

@MmuxDefineCFunctionParser{sint8}
@MmuxDefineCFunctionParser{uint8}
@MmuxDefineCFunctionParser{sint16}
@MmuxDefineCFunctionParser{uint16}
@MmuxDefineCFunctionParser{sint32}
@MmuxDefineCFunctionParser{uint32}
@MmuxDefineCFunctionParser{sint64}
@MmuxDefineCFunctionParser{uint64}

@MmuxDefineCFunctionParser{ssize}
@MmuxDefineCFunctionParser{usize}
@MmuxDefineCFunctionParser{sintmax}
@MmuxDefineCFunctionParser{uintmax}
@MmuxDefineCFunctionParser{sintptr}
@MmuxDefineCFunctionParser{uintptr}
@MmuxDefineCFunctionParser{ptrdiff}
@MmuxDefineCFunctionParser{mode}
@MmuxDefineCFunctionParser{off}
@MmuxDefineCFunctionParser{pid}
@MmuxDefineCFunctionParser{uid}
@MmuxDefineCFunctionParser{gid}
@MmuxDefineCFunctionParser{wchar}
@MmuxDefineCFunctionParser{wint}
@MmuxDefineCFunctionParser{time}
@MmuxDefineCFunctionParser{socklen}
@MmuxDefineCFunctionParser{rlim}

@c page
@node stringrep sprinters
@section Printing string representations of C language types


Type string printers convert binary representations of C language values to string representations;
to print a @objtype{mmux_sint_t} string representation we do:

@example
auto    value           = mmux_sint_make(123);
auto    required_nbytes = mmux_sint_sprint_size(value);

if (0 > required_nbytes) @{
  /* error */
@} else @{
  char    str[required_nbytes];

  if (mmux_sint_sprint(str, required_nbytes, value)) @{
    /* error */
  @}
@}
@end example


@macro MmuxDefineCFunctionSprinter{STEM}
@deftypefun bool mmux_\STEM\_sprint (char * @var{STRPTR}, int @var{LEN}, mmux_\STEM\_t @var{VALUE})
@deftypefunx int mmux_\STEM\_sprint_size (mmux_\STEM\_t @var{VALUE})
The @samp{sprint} function generates a string representation of @var{VALUE} and stores it, in
@asciiz{} format, in the string referenced by @var{STRPTR}, which can hold at most @var{LEN}
characters (terminating zero included).  When successful return @cfalse{}; otherwise leave
@var{STRPTR} untouched and return @ctrue{}.

The @samp{sprint_size} function computes how many characters are needed to hold the string
representation of @var{VALUE}.  When successful returns the number of characters, @strong{including
the terminating zero}; otherwise return @samp{-1}.
@end deftypefun

@end macro


@MmuxDefineCFunctionSprinter{pointer}

@MmuxDefineCFunctionSprinter{char}
@MmuxDefineCFunctionSprinter{schar}
@MmuxDefineCFunctionSprinter{uchar}
@MmuxDefineCFunctionSprinter{sshort}
@MmuxDefineCFunctionSprinter{ushort}
@MmuxDefineCFunctionSprinter{sint}
@MmuxDefineCFunctionSprinter{uint}
@MmuxDefineCFunctionSprinter{slong}
@MmuxDefineCFunctionSprinter{ulong}
@MmuxDefineCFunctionSprinter{sllong}
@MmuxDefineCFunctionSprinter{ullong}
@MmuxDefineCFunctionSprinter{float}
@MmuxDefineCFunctionSprinter{double}
@MmuxDefineCFunctionSprinter{ldouble}

@MmuxDefineCFunctionSprinter{float32}
@MmuxDefineCFunctionSprinter{float64}
@MmuxDefineCFunctionSprinter{float128}

@MmuxDefineCFunctionSprinter{float32x}
@MmuxDefineCFunctionSprinter{float64x}
@MmuxDefineCFunctionSprinter{float128x}

@MmuxDefineCFunctionSprinter{decimal32}
@MmuxDefineCFunctionSprinter{decimal64}
@MmuxDefineCFunctionSprinter{decimal128}

@MmuxDefineCFunctionSprinter{complexf}
@MmuxDefineCFunctionSprinter{complexd}
@MmuxDefineCFunctionSprinter{complexld}

@MmuxDefineCFunctionSprinter{complexf32}
@MmuxDefineCFunctionSprinter{complexf64}
@MmuxDefineCFunctionSprinter{complexf128}

@MmuxDefineCFunctionSprinter{complexf32x}
@MmuxDefineCFunctionSprinter{complexf64x}
@MmuxDefineCFunctionSprinter{complexf128x}

@MmuxDefineCFunctionSprinter{complexd32}
@MmuxDefineCFunctionSprinter{complexd64}
@MmuxDefineCFunctionSprinter{complexd128}

@MmuxDefineCFunctionSprinter{sint8}
@MmuxDefineCFunctionSprinter{uint8}
@MmuxDefineCFunctionSprinter{sint16}
@MmuxDefineCFunctionSprinter{uint16}
@MmuxDefineCFunctionSprinter{sint32}
@MmuxDefineCFunctionSprinter{uint32}
@MmuxDefineCFunctionSprinter{sint64}
@MmuxDefineCFunctionSprinter{uint64}

@MmuxDefineCFunctionSprinter{ssize}
@MmuxDefineCFunctionSprinter{usize}
@MmuxDefineCFunctionSprinter{sintmax}
@MmuxDefineCFunctionSprinter{uintmax}
@MmuxDefineCFunctionSprinter{sintptr}
@MmuxDefineCFunctionSprinter{uintptr}
@MmuxDefineCFunctionSprinter{ptrdiff}
@MmuxDefineCFunctionSprinter{mode}
@MmuxDefineCFunctionSprinter{off}
@MmuxDefineCFunctionSprinter{pid}
@MmuxDefineCFunctionSprinter{uid}
@MmuxDefineCFunctionSprinter{gid}
@MmuxDefineCFunctionSprinter{wchar}
@MmuxDefineCFunctionSprinter{wint}
@MmuxDefineCFunctionSprinter{time}
@MmuxDefineCFunctionSprinter{socklen}
@MmuxDefineCFunctionSprinter{rlim}

@c page
@node printing
@chapter Printing string representations


To print a value to @stderr{}, we can do:

@example
auto    X = mmux_double_make(1.2);

if (mmux_double_dprintf(2, X)) @{
  /* error */
@}

if (mmux_double_fprintf(stderr, X)) @{
  /* error */
@}
@end example



@macro MmuxDefineCFunctionPrinters{STEM}
@deftypefun bool mmux_\STEM\_dprintf (mmux_sint_t @var{fd}, mmux_\STEM\_t @var{value})
@deftypefunx bool mmux_\STEM\_fprintf (mmux_pointer_t @var{stream}, mmux_\STEM\_t @var{value})
Print a string representation of @var{value} to the given file descriptor @var{fd} or stream
@var{stream}.  When successful return @cfalse{}, otherwise return @ctrue{}.
@end deftypefun

@end macro


@MmuxDefineCFunctionPrinters{pointer}

@MmuxDefineCFunctionPrinters{char}
@MmuxDefineCFunctionPrinters{schar}
@MmuxDefineCFunctionPrinters{uchar}
@MmuxDefineCFunctionPrinters{sshort}
@MmuxDefineCFunctionPrinters{ushort}
@MmuxDefineCFunctionPrinters{sint}
@MmuxDefineCFunctionPrinters{uint}
@MmuxDefineCFunctionPrinters{slong}
@MmuxDefineCFunctionPrinters{ulong}
@MmuxDefineCFunctionPrinters{sllong}
@MmuxDefineCFunctionPrinters{ullong}
@MmuxDefineCFunctionPrinters{float}
@MmuxDefineCFunctionPrinters{double}
@MmuxDefineCFunctionPrinters{ldouble}

@MmuxDefineCFunctionPrinters{float32}
@MmuxDefineCFunctionPrinters{float64}
@MmuxDefineCFunctionPrinters{float128}

@MmuxDefineCFunctionPrinters{float32x}
@MmuxDefineCFunctionPrinters{float64x}
@MmuxDefineCFunctionPrinters{float128x}

@MmuxDefineCFunctionPrinters{decimal32}
@MmuxDefineCFunctionPrinters{decimal64}
@MmuxDefineCFunctionPrinters{decimal128}

@MmuxDefineCFunctionPrinters{complexf}
@MmuxDefineCFunctionPrinters{complexd}
@MmuxDefineCFunctionPrinters{complexld}

@MmuxDefineCFunctionPrinters{complexf32}
@MmuxDefineCFunctionPrinters{complexf64}
@MmuxDefineCFunctionPrinters{complexf128}

@MmuxDefineCFunctionPrinters{complexf32x}
@MmuxDefineCFunctionPrinters{complexf64x}
@MmuxDefineCFunctionPrinters{complexf128x}

@MmuxDefineCFunctionPrinters{complexd32}
@MmuxDefineCFunctionPrinters{complexd64}
@MmuxDefineCFunctionPrinters{complexd128}

@MmuxDefineCFunctionPrinters{sint8}
@MmuxDefineCFunctionPrinters{uint8}
@MmuxDefineCFunctionPrinters{sint16}
@MmuxDefineCFunctionPrinters{uint16}
@MmuxDefineCFunctionPrinters{sint32}
@MmuxDefineCFunctionPrinters{uint32}
@MmuxDefineCFunctionPrinters{sint64}
@MmuxDefineCFunctionPrinters{uint64}

@MmuxDefineCFunctionPrinters{ssize}
@MmuxDefineCFunctionPrinters{usize}
@MmuxDefineCFunctionPrinters{sintmax}
@MmuxDefineCFunctionPrinters{uintmax}
@MmuxDefineCFunctionPrinters{sintptr}
@MmuxDefineCFunctionPrinters{uintptr}
@MmuxDefineCFunctionPrinters{ptrdiff}
@MmuxDefineCFunctionPrinters{mode}
@MmuxDefineCFunctionPrinters{off}
@MmuxDefineCFunctionPrinters{pid}
@MmuxDefineCFunctionPrinters{uid}
@MmuxDefineCFunctionPrinters{gid}
@MmuxDefineCFunctionPrinters{wchar}
@MmuxDefineCFunctionPrinters{wint}
@MmuxDefineCFunctionPrinters{time}
@MmuxDefineCFunctionPrinters{socklen}
@MmuxDefineCFunctionPrinters{rlim}

@c page
@node complex
@chapter Basic complex number operations


@menu
* complex make::        Constructing complex numbers.
* complex parts::       Extracting the real and imaginary parts.
* complex arg::         Computing the argument value.
* complex conj::        Computing the complex conjugate value.
@end menu

@c page
@node complex make
@section Constructing complex numbers


To construct a complex number from its real and imaginary parts, we do:

@example
mmux_double_t   rep = 1.2;
mmux_double_t   imp = 3.4;
mmux_complexd_t Z;

Z = mmux_complexd_make_rectangular(rep, imp);
@end example


@macro MmuxDefineComplexMakeRectangularFunction{CPLXSTEM,REALSTEM}
@deftypefun mmux_\CPLXSTEM\_t mmux_\CPLXSTEM\_make_rectangular (mmux_\REALSTEM\_t @var{REP}, mmux_\REALSTEM\_t @var{IMP})
Construct a complex number, of type @objtype{\CPLXSTEM\}, from the real and imaginary parts
@var{REP} and @var{IMP}, of type @objtype{\REALSTEM\}.  Return the result.
@end deftypefun

@end macro

@MmuxDefineComplexMakeRectangularFunction{complexf, float}
@MmuxDefineComplexMakeRectangularFunction{complexd, double}
@MmuxDefineComplexMakeRectangularFunction{complexld, ldouble}

@MmuxDefineComplexMakeRectangularFunction{complexf32, float32}
@MmuxDefineComplexMakeRectangularFunction{complexf64, float64}
@MmuxDefineComplexMakeRectangularFunction{complexf128, float128}

@MmuxDefineComplexMakeRectangularFunction{complexf32x, float32x}
@MmuxDefineComplexMakeRectangularFunction{complexf64x, float64x}
@MmuxDefineComplexMakeRectangularFunction{complexf128x, float128x}

@MmuxDefineComplexMakeRectangularFunction{complexd32, decimal32}
@MmuxDefineComplexMakeRectangularFunction{complexd64, decimal64}
@MmuxDefineComplexMakeRectangularFunction{complexd128, decimal128}

@c page
@node complex parts
@section Extracting the real and imaginary parts


To extract the real and imaginary parts from a complex number we do:

@example
mmux_complexd_t Z = ...;
mmux_double_t   rep;
mmux_double_t   imp;

rep = mmux_complexd_real_part(Z);
imp = mmux_complexd_real_part(Z);
@end example


@macro MmuxDefineComplexRealImagPartFunction{CPLXSTEM,REALSTEM}
@deftypefun  mmux_\REALSTEM\_t mmux_\CPLXSTEM\_real_part (mmux_\CPLXSTEM\_t @var{OP})
@deftypefunx mmux_\REALSTEM\_t mmux_\CPLXSTEM\_imag_part (mmux_\CPLXSTEM\_t @var{OP})
Extract and return the real or imaginary parts from the complex number @var{OP}.
@end deftypefun

@end macro

@MmuxDefineComplexRealImagPartFunction{complexf, float}
@MmuxDefineComplexRealImagPartFunction{complexd, double}
@MmuxDefineComplexRealImagPartFunction{complexld, ldouble}

@MmuxDefineComplexRealImagPartFunction{complexf32, float32}
@MmuxDefineComplexRealImagPartFunction{complexf64, float64}
@MmuxDefineComplexRealImagPartFunction{complexf128, float128}

@MmuxDefineComplexRealImagPartFunction{complexf32x, float32x}
@MmuxDefineComplexRealImagPartFunction{complexf64x, float64x}
@MmuxDefineComplexRealImagPartFunction{complexf128x, float128x}

@MmuxDefineComplexRealImagPartFunction{complexd32, decimal32}
@MmuxDefineComplexRealImagPartFunction{complexd64, decimal64}
@MmuxDefineComplexRealImagPartFunction{complexd128, decimal128}

@c page
@node complex arg
@section Computing the argument value


@macro MmuxDefineComplexArgFunction{CPLXSTEM,REALSTEM}
@deftypefun mmux_\REALSTEM\_t mmux_\CPLXSTEM\_arg (mmux_\CPLXSTEM\_t @var{OP})
Compute and return the argument value of the complex number @var{OP}.
@end deftypefun

@end macro

@MmuxDefineComplexArgFunction{complexf, float}
@MmuxDefineComplexArgFunction{complexd, double}
@MmuxDefineComplexArgFunction{complexld, ldouble}

@MmuxDefineComplexArgFunction{complexf32, float32}
@MmuxDefineComplexArgFunction{complexf64, float64}
@MmuxDefineComplexArgFunction{complexf128, float128}

@MmuxDefineComplexArgFunction{complexf32x, float32x}
@MmuxDefineComplexArgFunction{complexf64x, float64x}
@MmuxDefineComplexArgFunction{complexf128x, float128x}

@MmuxDefineComplexArgFunction{complexd32, decimal32}
@MmuxDefineComplexArgFunction{complexd64, decimal64}
@MmuxDefineComplexArgFunction{complexd128, decimal128}

@c page
@node complex conj
@section Computing the complex conjugate value


@macro MmuxDefineComplexConjFunction{CPLXSTEM,REALSTEM}
@deftypefun mmux_\CPLXSTEM\_t mmux_\CPLXSTEM\_conj (mmux_\CPLXSTEM\_t @var{OP})
Compute and return complex conjugate value of the complex number @var{OP}.
@end deftypefun

@end macro

@MmuxDefineComplexConjFunction{complexf, float}
@MmuxDefineComplexConjFunction{complexd, double}
@MmuxDefineComplexConjFunction{complexld, ldouble}

@MmuxDefineComplexConjFunction{complexf32, float32}
@MmuxDefineComplexConjFunction{complexf64, float64}
@MmuxDefineComplexConjFunction{complexf128, float128}

@MmuxDefineComplexConjFunction{complexf32x, float32x}
@MmuxDefineComplexConjFunction{complexf64x, float64x}
@MmuxDefineComplexConjFunction{complexf128x, float128x}

@MmuxDefineComplexConjFunction{complexd32, decimal32}
@MmuxDefineComplexConjFunction{complexd64, decimal64}
@MmuxDefineComplexConjFunction{complexd128, decimal128}

@c page
@node predicates
@chapter Type predicates


In the context of @value{PACKAGE}: complex numbers cannot be positive or negative, so the predicates
@samp{positive}, @samp{negative}, @samp{non_positive}, @samp{non_negative} always return @cfalse{}
when applied to a complex number.

The C language defines the zero for floating--point numbers as having a sign, so we have @samp{-0.0}
and @samp{+0.0}; this means zero can be positive or negative and the following predicates examine
the sign bit to determine the return value.


@deftypefun bool mmux_char_is_unsigned (void)
Return @ctrue{} if @objtype{mmux_char_t} is unsigned; otherwise return @cfalse{}.
@end deftypefun


@macro MmuxDefineTypePredicates{STEM}
@deftypefun bool mmux_\STEM\_is_zero (mmux_\STEM\_t @var{OP})
@deftypefunx bool mmux_\STEM\_is_positive (mmux_\STEM\_t @var{OP})
@deftypefunx bool mmux_\STEM\_is_negative (mmux_\STEM\_t @var{OP})
@deftypefunx bool mmux_\STEM\_is_non_positive (mmux_\STEM\_t @var{OP})
@deftypefunx bool mmux_\STEM\_is_non_negative (mmux_\STEM\_t @var{OP})
@deftypefunx bool mmux_\STEM\_is_infinite (mmux_\STEM\_t @var{OP})
@deftypefunx bool mmux_\STEM\_is_nan (mmux_\STEM\_t @var{OP})
Return @ctrue{} if @var{OP} is zero, positive, negative, non--positive, non--negative, infinite,
nan; otherwise return @cfalse{}.
@end deftypefun

@end macro

@MmuxDefineTypePredicates{pointer}

@MmuxDefineTypePredicates{char}
@MmuxDefineTypePredicates{schar}
@MmuxDefineTypePredicates{uchar}
@MmuxDefineTypePredicates{sshort}
@MmuxDefineTypePredicates{ushort}
@MmuxDefineTypePredicates{sint}
@MmuxDefineTypePredicates{uint}
@MmuxDefineTypePredicates{slong}
@MmuxDefineTypePredicates{ulong}
@MmuxDefineTypePredicates{sllong}
@MmuxDefineTypePredicates{ullong}
@MmuxDefineTypePredicates{float}
@MmuxDefineTypePredicates{double}
@MmuxDefineTypePredicates{ldouble}

@MmuxDefineTypePredicates{float32}
@MmuxDefineTypePredicates{float64}
@MmuxDefineTypePredicates{float128}

@MmuxDefineTypePredicates{float32x}
@MmuxDefineTypePredicates{float64x}
@MmuxDefineTypePredicates{float128x}

@MmuxDefineTypePredicates{decimal32}
@MmuxDefineTypePredicates{decimal64}
@MmuxDefineTypePredicates{decimal128}

@MmuxDefineTypePredicates{complexf}
@MmuxDefineTypePredicates{complexd}
@MmuxDefineTypePredicates{complexld}

@MmuxDefineTypePredicates{complexf32}
@MmuxDefineTypePredicates{complexf64}
@MmuxDefineTypePredicates{complexf128}

@MmuxDefineTypePredicates{complexf32x}
@MmuxDefineTypePredicates{complexf64x}
@MmuxDefineTypePredicates{complexf128x}

@MmuxDefineTypePredicates{complexd32}
@MmuxDefineTypePredicates{complexd64}
@MmuxDefineTypePredicates{complexd128}

@MmuxDefineTypePredicates{sint8}
@MmuxDefineTypePredicates{uint8}
@MmuxDefineTypePredicates{sint16}
@MmuxDefineTypePredicates{uint16}
@MmuxDefineTypePredicates{sint32}
@MmuxDefineTypePredicates{uint32}
@MmuxDefineTypePredicates{sint64}
@MmuxDefineTypePredicates{uint64}

@MmuxDefineTypePredicates{ssize}
@MmuxDefineTypePredicates{usize}
@MmuxDefineTypePredicates{sintmax}
@MmuxDefineTypePredicates{uintmax}
@MmuxDefineTypePredicates{sintptr}
@MmuxDefineTypePredicates{uintptr}
@MmuxDefineTypePredicates{ptrdiff}
@MmuxDefineTypePredicates{mode}
@MmuxDefineTypePredicates{off}
@MmuxDefineTypePredicates{pid}
@MmuxDefineTypePredicates{uid}
@MmuxDefineTypePredicates{gid}
@MmuxDefineTypePredicates{wchar}
@MmuxDefineTypePredicates{wint}
@MmuxDefineTypePredicates{time}
@MmuxDefineTypePredicates{socklen}
@MmuxDefineTypePredicates{rlim}

@c page
@node comparison
@chapter Comparison functions


@menu
* comparison exact::            Exact comparison functions.
* comparison mimmax::           Maximum and minimum values.
* comparison absmargin::        Absolute margin comparison criterion.
* comparison relepsilon::       Relative epsilon comparison criterion.
@end menu

@c page
@node comparison exact
@section Exact comparison functions


In the context of @value{PACKAGE}, when comparing complex numbers: the functions @samp{cmp},
@samp{equal}, @samp{less}, @samp{greater}, @samp{less_equal}, @samp{greater_equal} compare the
absolute value of the complex operands.

The @cfunc{mmux_*_cmp} functions perform the usual comparison with ternary result.  The predicate
functions return @ctrue{} if the operands are in the named relation; otherwise return @cfalse{}.

@c ------------------------------------------------------------------------

@macro MmuxDefineTypeComparisonExactFunction{STEM}
@deftypefun int mmux_\STEM\_cmp (mmux_\STEM\_t @vari{OP}, mmux_\STEM\_t @varii{OP})
@deftypefunx bool mmux_\STEM\_equal (mmux_\STEM\_t @vari{OP}, mmux_\STEM\_t @varii{OP})
@deftypefunx bool mmux_\STEM\_greater (mmux_\STEM\_t @vari{OP}, mmux_\STEM\_t @varii{OP})
@deftypefunx bool mmux_\STEM\_less (mmux_\STEM\_t @vari{OP}, mmux_\STEM\_t @varii{OP})
@deftypefunx bool mmux_\STEM\_greater_equal (mmux_\STEM\_t @vari{OP}, mmux_\STEM\_t @varii{OP})
@deftypefunx bool mmux_\STEM\_less_equal (mmux_\STEM\_t @vari{OP}, mmux_\STEM\_t @varii{OP})
Comparison between @objtype{mmux_\STEM\_t} values.
@end deftypefun

@end macro

@c ------------------------------------------------------------------------

@MmuxDefineTypeComparisonExactFunction{pointer}

@MmuxDefineTypeComparisonExactFunction{char}
@MmuxDefineTypeComparisonExactFunction{schar}
@MmuxDefineTypeComparisonExactFunction{uchar}
@MmuxDefineTypeComparisonExactFunction{sshort}
@MmuxDefineTypeComparisonExactFunction{ushort}
@MmuxDefineTypeComparisonExactFunction{sint}
@MmuxDefineTypeComparisonExactFunction{uint}
@MmuxDefineTypeComparisonExactFunction{slong}
@MmuxDefineTypeComparisonExactFunction{ulong}
@MmuxDefineTypeComparisonExactFunction{sllong}
@MmuxDefineTypeComparisonExactFunction{ullong}
@MmuxDefineTypeComparisonExactFunction{float}
@MmuxDefineTypeComparisonExactFunction{double}
@MmuxDefineTypeComparisonExactFunction{ldouble}

@MmuxDefineTypeComparisonExactFunction{float32}
@MmuxDefineTypeComparisonExactFunction{float64}
@MmuxDefineTypeComparisonExactFunction{float128}

@MmuxDefineTypeComparisonExactFunction{float32x}
@MmuxDefineTypeComparisonExactFunction{float64x}
@MmuxDefineTypeComparisonExactFunction{float128x}

@MmuxDefineTypeComparisonExactFunction{decimal32}
@MmuxDefineTypeComparisonExactFunction{decimal64}
@MmuxDefineTypeComparisonExactFunction{decimal128}

@MmuxDefineTypeComparisonExactFunction{complexf}
@MmuxDefineTypeComparisonExactFunction{complexd}
@MmuxDefineTypeComparisonExactFunction{complexld}

@MmuxDefineTypeComparisonExactFunction{complexf32}
@MmuxDefineTypeComparisonExactFunction{complexf64}
@MmuxDefineTypeComparisonExactFunction{complexf128}

@MmuxDefineTypeComparisonExactFunction{complexf32x}
@MmuxDefineTypeComparisonExactFunction{complexf64x}
@MmuxDefineTypeComparisonExactFunction{complexf128x}

@MmuxDefineTypeComparisonExactFunction{complexd32}
@MmuxDefineTypeComparisonExactFunction{complexd64}
@MmuxDefineTypeComparisonExactFunction{complexd128}

@MmuxDefineTypeComparisonExactFunction{sint8}
@MmuxDefineTypeComparisonExactFunction{uint8}
@MmuxDefineTypeComparisonExactFunction{sint16}
@MmuxDefineTypeComparisonExactFunction{uint16}
@MmuxDefineTypeComparisonExactFunction{sint32}
@MmuxDefineTypeComparisonExactFunction{uint32}
@MmuxDefineTypeComparisonExactFunction{sint64}
@MmuxDefineTypeComparisonExactFunction{uint64}

@MmuxDefineTypeComparisonExactFunction{ssize}
@MmuxDefineTypeComparisonExactFunction{usize}
@MmuxDefineTypeComparisonExactFunction{sintmax}
@MmuxDefineTypeComparisonExactFunction{uintmax}
@MmuxDefineTypeComparisonExactFunction{sintptr}
@MmuxDefineTypeComparisonExactFunction{uintptr}
@MmuxDefineTypeComparisonExactFunction{ptrdiff}
@MmuxDefineTypeComparisonExactFunction{mode}
@MmuxDefineTypeComparisonExactFunction{off}
@MmuxDefineTypeComparisonExactFunction{pid}
@MmuxDefineTypeComparisonExactFunction{uid}
@MmuxDefineTypeComparisonExactFunction{gid}
@MmuxDefineTypeComparisonExactFunction{wchar}
@MmuxDefineTypeComparisonExactFunction{wint}
@MmuxDefineTypeComparisonExactFunction{time}
@MmuxDefineTypeComparisonExactFunction{socklen}
@MmuxDefineTypeComparisonExactFunction{rlim}

@c page
@node comparison mimmax
@section Maximum and minimum values


@macro MmuxDefineTypeComparisonMinMaxFunction{STEM}
@deftypefun mmux_\STEM\_t mmux_\STEM\_max (mmux_\STEM\_t @vari{OP}, mmux_\STEM\_t @varii{OP})
@deftypefunx mmux_\STEM\_t mmux_\STEM\_min (mmux_\STEM\_t @vari{OP}, mmux_\STEM\_t @varii{OP})
Return the maximum or minimum value between the operands.
@end deftypefun

@end macro


@MmuxDefineTypeComparisonMinMaxFunction{pointer}

@MmuxDefineTypeComparisonMinMaxFunction{char}
@MmuxDefineTypeComparisonMinMaxFunction{schar}
@MmuxDefineTypeComparisonMinMaxFunction{uchar}
@MmuxDefineTypeComparisonMinMaxFunction{sshort}
@MmuxDefineTypeComparisonMinMaxFunction{ushort}
@MmuxDefineTypeComparisonMinMaxFunction{sint}
@MmuxDefineTypeComparisonMinMaxFunction{uint}
@MmuxDefineTypeComparisonMinMaxFunction{slong}
@MmuxDefineTypeComparisonMinMaxFunction{ulong}
@MmuxDefineTypeComparisonMinMaxFunction{sllong}
@MmuxDefineTypeComparisonMinMaxFunction{ullong}
@MmuxDefineTypeComparisonMinMaxFunction{float}
@MmuxDefineTypeComparisonMinMaxFunction{double}
@MmuxDefineTypeComparisonMinMaxFunction{ldouble}

@MmuxDefineTypeComparisonMinMaxFunction{float32}
@MmuxDefineTypeComparisonMinMaxFunction{float64}
@MmuxDefineTypeComparisonMinMaxFunction{float128}

@MmuxDefineTypeComparisonMinMaxFunction{float32x}
@MmuxDefineTypeComparisonMinMaxFunction{float64x}
@MmuxDefineTypeComparisonMinMaxFunction{float128x}

@MmuxDefineTypeComparisonMinMaxFunction{decimal32}
@MmuxDefineTypeComparisonMinMaxFunction{decimal64}
@MmuxDefineTypeComparisonMinMaxFunction{decimal128}

@MmuxDefineTypeComparisonMinMaxFunction{sint8}
@MmuxDefineTypeComparisonMinMaxFunction{uint8}
@MmuxDefineTypeComparisonMinMaxFunction{sint16}
@MmuxDefineTypeComparisonMinMaxFunction{uint16}
@MmuxDefineTypeComparisonMinMaxFunction{sint32}
@MmuxDefineTypeComparisonMinMaxFunction{uint32}
@MmuxDefineTypeComparisonMinMaxFunction{sint64}
@MmuxDefineTypeComparisonMinMaxFunction{uint64}

@MmuxDefineTypeComparisonMinMaxFunction{ssize}
@MmuxDefineTypeComparisonMinMaxFunction{usize}
@MmuxDefineTypeComparisonMinMaxFunction{sintmax}
@MmuxDefineTypeComparisonMinMaxFunction{uintmax}
@MmuxDefineTypeComparisonMinMaxFunction{sintptr}
@MmuxDefineTypeComparisonMinMaxFunction{uintptr}
@MmuxDefineTypeComparisonMinMaxFunction{ptrdiff}
@MmuxDefineTypeComparisonMinMaxFunction{mode}
@MmuxDefineTypeComparisonMinMaxFunction{off}
@MmuxDefineTypeComparisonMinMaxFunction{pid}
@MmuxDefineTypeComparisonMinMaxFunction{uid}
@MmuxDefineTypeComparisonMinMaxFunction{gid}
@MmuxDefineTypeComparisonMinMaxFunction{wchar}
@MmuxDefineTypeComparisonMinMaxFunction{wint}
@MmuxDefineTypeComparisonMinMaxFunction{time}
@MmuxDefineTypeComparisonMinMaxFunction{socklen}
@MmuxDefineTypeComparisonMinMaxFunction{rlim}

@c page
@node comparison absmargin
@section Absolute margin comparison criterion


To compare real numbers with the criterion of the absolute margin means to verify the predicate
between the real numbers @vari{OP}, @varii{OP}, @var{MARGIN}:

@example
abs(@vari{OP} - @varii{OP}) <= abs(@var{MARGIN})
@end example

@noindent
while to compare complex numbers means to verify the predicate between the complex numbers
@vari{OP}, @varii{OP}, @var{MARGIN}:

@example
abs(real(@vari{OP}) - real(@varii{OP})) <= abs(real(@var{MARGIN})) &&
abs(imag(@vari{OP}) - imag(@varii{OP})) <= abs(imag(@var{MARGIN}))
@end example

To compare two floating--point numbers with the criterion of the absolute margin, we do:

@example
mmux_double_t   op1    = 1.2;
mmux_double_t   op2    = 1.23;
mmux_double_t   margin = 1e-6;

if (mmux_double_equal_absmargin(op1, op2, margin)) @{
  ... /* equal */
@} else @{
  ... /* not equal */
@}
@end example


@macro MmuxDefineAbsmarginFunc{STEM}
@deftypefun bool mmux_\STEM\_equal_absmargin (mmux_\STEM\_t @vari{OP}, mmux_\STEM\_t @varii{OP}, mmux_\STEM\_t @vari{MARGIN})
Compare the operands using the given margin.
@end deftypefun

@end macro


@MmuxDefineAbsmarginFunc{double}
@MmuxDefineAbsmarginFunc{ldouble}
@MmuxDefineAbsmarginFunc{complexf}
@MmuxDefineAbsmarginFunc{complexd}
@MmuxDefineAbsmarginFunc{complexld}
@MmuxDefineAbsmarginFunc{float32}
@MmuxDefineAbsmarginFunc{float64}
@MmuxDefineAbsmarginFunc{float128}
@MmuxDefineAbsmarginFunc{float32x}
@MmuxDefineAbsmarginFunc{float64x}
@MmuxDefineAbsmarginFunc{float128x}
@MmuxDefineAbsmarginFunc{decimal32}
@MmuxDefineAbsmarginFunc{decimal64}
@MmuxDefineAbsmarginFunc{decimal128}
@MmuxDefineAbsmarginFunc{complexf32}
@MmuxDefineAbsmarginFunc{complexf64}
@MmuxDefineAbsmarginFunc{complexf128}
@MmuxDefineAbsmarginFunc{complexf32x}
@MmuxDefineAbsmarginFunc{complexf64x}
@MmuxDefineAbsmarginFunc{complexf128x}
@MmuxDefineAbsmarginFunc{complexd32}
@MmuxDefineAbsmarginFunc{complexd64}
@MmuxDefineAbsmarginFunc{complexd128}

@c page
@node comparison relepsilon
@section Relative epsilon comparison criterion


To compare real numbers with the criterion of the relative epsilon means to verify the predicate
between the real numbers @vari{OP}, @varii{OP}, @var{EPSILON}:

@example
abs(@vari{OP} - @varii{OP}) <= (abs(@var{EPSILON}) * max(abs(@vari{OP}), abs(@varii{OP})))
@end example

@noindent
while to compare complex numbers means to verify the predicate between the complex numbers
@vari{OP}, @varii{OP}, @var{EPSILON}:

@example
abs(real(@varo{OP}) - real(@var{OP})) <= (abs(real(@var{EPSILON})) * max(abs(real(@vari{OP})), real(abs(@varii{OP})))) &&
abs(imag(@varo{OP}) - imag(@var{OP})) <= (abs(imag(@var{EPSILON})) * max(abs(imag(@vari{OP})), imag(abs(@varii{OP}))))
@end example

To compare two floating--point numbers with the criterion of the relative epsilon, we do:

@example
mmux_double_t   op1     = 1.2;
mmux_double_t   op2     = 1.23;
mmux_double_t   epsilon = 1e-6;

if (mmux_double_equal_relepsilon(op1, op2, epsilon)) @{
  ... /* equal */
@} else @{
  ... /* not equal */
@}
@end example


@macro MmuxDefineRelepsilonFunc{STEM}
@deftypefun bool mmux_\STEM\_equal_relepsilon (mmux_\STEM\_t @vari{OP}, mmux_\STEM\_t @varii{OP}, mmux_\STEM\_t @vari{EPSILON})
Compare the operands using the given epsilon.
@end deftypefun

@end macro


@MmuxDefineRelepsilonFunc{double}
@MmuxDefineRelepsilonFunc{ldouble}
@MmuxDefineRelepsilonFunc{complexf}
@MmuxDefineRelepsilonFunc{complexd}
@MmuxDefineRelepsilonFunc{complexld}
@MmuxDefineRelepsilonFunc{float32}
@MmuxDefineRelepsilonFunc{float64}
@MmuxDefineRelepsilonFunc{float128}
@MmuxDefineRelepsilonFunc{float32x}
@MmuxDefineRelepsilonFunc{float64x}
@MmuxDefineRelepsilonFunc{float128x}
@MmuxDefineRelepsilonFunc{decimal32}
@MmuxDefineRelepsilonFunc{decimal64}
@MmuxDefineRelepsilonFunc{decimal128}
@MmuxDefineRelepsilonFunc{complexf32}
@MmuxDefineRelepsilonFunc{complexf64}
@MmuxDefineRelepsilonFunc{complexf128}
@MmuxDefineRelepsilonFunc{complexf32x}
@MmuxDefineRelepsilonFunc{complexf64x}
@MmuxDefineRelepsilonFunc{complexf128x}
@MmuxDefineRelepsilonFunc{complexd32}
@MmuxDefineRelepsilonFunc{complexd64}
@MmuxDefineRelepsilonFunc{complexd128}

@c page
@node arithmetics
@chapter Arithmetics operations


Notes on arithmetics functions:

@itemize
@item
Notice how the @code{neg} functions are defined for unsigned exact integers; the result of such an
operation is whatever the compile produces; for example:

@example
mmux_ulong_t    op  = 5;
auto            rop = mmux_ulong_neg(op);
dprintf(2, "rop = %lu\n", rop);
@print{} 18446744073709551611
@end example
@end itemize


@deftypefun mmux_pointer_t mmux_pointer_add (mmux_pointer_t @var{OP}, mmux_ptrdiff_t @var{DELTA})
Perform the addition between @var{PTR} and @var{DELTA}, return the result.
@end deftypefun


@deftypefun mmux_ptrdiff_t mmux_pointer_diff (mmux_pointer_t @vari{OP}, mmux_pointer_t @varii{OP})
Compute the difference between the operands @code{@vari{OP} - @varii{OP}}, interpreting the pointers
as @code{mmux_uint8_t *}, return the result.
@end deftypefun


@macro MmuxDefineNotIntegerRealArithmeticsFunc{STEM}
@deftypefun mmux_\STEM\_t mmux_\STEM\_add (mmux_\STEM\_t @vari{OP}, mmux_\STEM\_t @varii{OP})
@deftypefunx mmux_\STEM\_t mmux_\STEM\_sub (mmux_\STEM\_t @vari{OP}, mmux_\STEM\_t @varii{OP})
@deftypefunx mmux_\STEM\_t mmux_\STEM\_mul (mmux_\STEM\_t @vari{OP}, mmux_\STEM\_t @varii{OP})
@deftypefunx mmux_\STEM\_t mmux_\STEM\_div (mmux_\STEM\_t @vari{OP}, mmux_\STEM\_t @varii{OP})
@deftypefunx mmux_\STEM\_t mmux_\STEM\_neg (mmux_\STEM\_t @var{OP})
@deftypefunx mmux_\STEM\_t mmux_\STEM\_inv (mmux_\STEM\_t @var{OP})
@deftypefunx mmux_\STEM\_t mmux_\STEM\_abs (mmux_\STEM\_t @var{OP})
@deftypefunx mmux_\STEM\_t mmux_\STEM\_mod (mmux_\STEM\_t @vari{OP}, mmux_\STEM\_t @varii{OP})
@deftypefunx mmux_\STEM\_t mmux_\STEM\_incr (mmux_\STEM\_t @var{OP})
@deftypefunx mmux_\STEM\_t mmux_\STEM\_decr (mmux_\STEM\_t @var{OP})
Compute the addition, subtraction, multiplication, division, negation, inverse, absolute value,
remainder, increment, decrement.
@end deftypefun

@end macro

@macro MmuxDefineComplexArithmeticsFunc{CPLXSTEM,REALSTEM}
@deftypefun mmux_\CPLXSTEM\_t mmux_\CPLXSTEM\_add (mmux_\CPLXSTEM\_t @vari{OP}, mmux_\CPLXSTEM\_t @varii{OP})
@deftypefunx mmux_\CPLXSTEM\_t mmux_\CPLXSTEM\_sub (mmux_\CPLXSTEM\_t @vari{OP}, mmux_\CPLXSTEM\_t @varii{OP})
@deftypefunx mmux_\CPLXSTEM\_t mmux_\CPLXSTEM\_mul (mmux_\CPLXSTEM\_t @vari{OP}, mmux_\CPLXSTEM\_t @varii{OP})
@deftypefunx mmux_\CPLXSTEM\_t mmux_\CPLXSTEM\_div (mmux_\CPLXSTEM\_t @vari{OP}, mmux_\CPLXSTEM\_t @varii{OP})
@deftypefunx mmux_\CPLXSTEM\_t mmux_\CPLXSTEM\_neg (mmux_\CPLXSTEM\_t @var{OP})
@deftypefunx mmux_\CPLXSTEM\_t mmux_\CPLXSTEM\_inv (mmux_\CPLXSTEM\_t @var{OP})
@deftypefunx mmux_\REALSTEM\_t mmux_\CPLXSTEM\_abs (mmux_\CPLXSTEM\_t @var{OP})
Compute the addition, subtraction, multiplication, division, negation, inverse, absolute values.
@end deftypefun

@end macro

@macro MmuxDefineIntegerArithmeticsFunc{STEM}
@deftypefun mmux_\STEM\_t mmux_\STEM\_add (mmux_\STEM\_t @vari{OP}, mmux_\STEM\_t @varii{OP})
@deftypefunx mmux_\STEM\_t mmux_\STEM\_sub (mmux_\STEM\_t @vari{OP}, mmux_\STEM\_t @varii{OP})
@deftypefunx mmux_\STEM\_t mmux_\STEM\_mul (mmux_\STEM\_t @vari{OP}, mmux_\STEM\_t @varii{OP})
@deftypefunx mmux_\STEM\_t mmux_\STEM\_div (mmux_\STEM\_t @vari{OP}, mmux_\STEM\_t @varii{OP})
@deftypefunx mmux_\STEM\_t mmux_\STEM\_neg (mmux_\STEM\_t @var{OP})
@deftypefunx mmux_\STEM\_t mmux_\STEM\_inv (mmux_\STEM\_t @var{OP})
@deftypefunx mmux_\STEM\_t mmux_\STEM\_abs (mmux_\STEM\_t @var{OP})
@deftypefunx mmux_\STEM\_t mmux_\STEM\_mod (mmux_\STEM\_t @vari{OP}, mmux_\STEM\_t @varii{OP})
@deftypefunx mmux_\STEM\_t mmux_\STEM\_incr (mmux_\STEM\_t @var{OP})
@deftypefunx mmux_\STEM\_t mmux_\STEM\_decr (mmux_\STEM\_t @var{OP})
Compute the addition, subtraction, multiplication, division, negation, inverse, absolute value,
remainder, increment, decrement.
@end deftypefun

@end macro


@MmuxDefineIntegerArithmeticsFunc{char}
@MmuxDefineIntegerArithmeticsFunc{schar}
@MmuxDefineIntegerArithmeticsFunc{uchar}
@MmuxDefineIntegerArithmeticsFunc{sshort}
@MmuxDefineIntegerArithmeticsFunc{ushort}
@MmuxDefineIntegerArithmeticsFunc{sint}
@MmuxDefineIntegerArithmeticsFunc{uint}
@MmuxDefineIntegerArithmeticsFunc{slong}
@MmuxDefineIntegerArithmeticsFunc{ulong}
@MmuxDefineIntegerArithmeticsFunc{sllong}
@MmuxDefineIntegerArithmeticsFunc{ullong}
@MmuxDefineNotIntegerRealArithmeticsFunc{float}
@MmuxDefineNotIntegerRealArithmeticsFunc{double}
@MmuxDefineNotIntegerRealArithmeticsFunc{ldouble}

@MmuxDefineNotIntegerRealArithmeticsFunc{float32}
@MmuxDefineNotIntegerRealArithmeticsFunc{float64}
@MmuxDefineNotIntegerRealArithmeticsFunc{float128}

@MmuxDefineNotIntegerRealArithmeticsFunc{float32x}
@MmuxDefineNotIntegerRealArithmeticsFunc{float64x}
@MmuxDefineNotIntegerRealArithmeticsFunc{float128x}

@MmuxDefineNotIntegerRealArithmeticsFunc{decimal32}
@MmuxDefineNotIntegerRealArithmeticsFunc{decimal64}
@MmuxDefineNotIntegerRealArithmeticsFunc{decimal128}

@MmuxDefineComplexArithmeticsFunc{complexf,float}
@MmuxDefineComplexArithmeticsFunc{complexd,double}
@MmuxDefineComplexArithmeticsFunc{complexld,ldouble}

@MmuxDefineComplexArithmeticsFunc{complexf32,float32}
@MmuxDefineComplexArithmeticsFunc{complexf64,float64}
@MmuxDefineComplexArithmeticsFunc{complexf128,float128}

@MmuxDefineComplexArithmeticsFunc{complexf32x,float32x}
@MmuxDefineComplexArithmeticsFunc{complexf64x,float64x}
@MmuxDefineComplexArithmeticsFunc{complexf128x,float128x}

@MmuxDefineComplexArithmeticsFunc{complexd32,decimal32}
@MmuxDefineComplexArithmeticsFunc{complexd64,decimal64}
@MmuxDefineComplexArithmeticsFunc{complexd128,decimal128}

@MmuxDefineIntegerArithmeticsFunc{sint8}
@MmuxDefineIntegerArithmeticsFunc{uint8}
@MmuxDefineIntegerArithmeticsFunc{sint16}
@MmuxDefineIntegerArithmeticsFunc{uint16}
@MmuxDefineIntegerArithmeticsFunc{sint32}
@MmuxDefineIntegerArithmeticsFunc{uint32}
@MmuxDefineIntegerArithmeticsFunc{sint64}
@MmuxDefineIntegerArithmeticsFunc{uint64}

@MmuxDefineIntegerArithmeticsFunc{ssize}
@MmuxDefineIntegerArithmeticsFunc{usize}
@MmuxDefineIntegerArithmeticsFunc{sintmax}
@MmuxDefineIntegerArithmeticsFunc{uintmax}
@MmuxDefineIntegerArithmeticsFunc{sintptr}
@MmuxDefineIntegerArithmeticsFunc{uintptr}
@MmuxDefineIntegerArithmeticsFunc{ptrdiff}
@MmuxDefineIntegerArithmeticsFunc{mode}
@MmuxDefineIntegerArithmeticsFunc{off}
@MmuxDefineIntegerArithmeticsFunc{pid}
@MmuxDefineIntegerArithmeticsFunc{uid}
@MmuxDefineIntegerArithmeticsFunc{gid}
@MmuxDefineIntegerArithmeticsFunc{wchar}
@MmuxDefineIntegerArithmeticsFunc{wint}
@MmuxDefineIntegerArithmeticsFunc{time}
@MmuxDefineIntegerArithmeticsFunc{socklen}
@MmuxDefineIntegerArithmeticsFunc{rlim}

@c page
@node mathematics
@chapter Mathematics operations


@macro MmuxDefineMathRealFuncs{STEM}
@deftypefun mmux_\STEM\_t mmux_\STEM\_sin (mmux_\STEM\_t @var{OP})
@deftypefunx mmux_\STEM\_t mmux_\STEM\_cos (mmux_\STEM\_t @var{OP})
@deftypefunx mmux_\STEM\_t mmux_\STEM\_tan (mmux_\STEM\_t @var{OP})
@deftypefunx mmux_\STEM\_t mmux_\STEM\_asin (mmux_\STEM\_t @var{OP})
@deftypefunx mmux_\STEM\_t mmux_\STEM\_acos (mmux_\STEM\_t @var{OP})
@deftypefunx mmux_\STEM\_t mmux_\STEM\_atan (mmux_\STEM\_t @var{OP})
@deftypefunx mmux_\STEM\_t mmux_\STEM\_atan2 (mmux_\STEM\_t @vari{OP}, mmux_\STEM\_t @varii{OP})
@deftypefunx mmux_\STEM\_t mmux_\STEM\_sinh (mmux_\STEM\_t @var{OP})
@deftypefunx mmux_\STEM\_t mmux_\STEM\_cosh (mmux_\STEM\_t @var{OP})
@deftypefunx mmux_\STEM\_t mmux_\STEM\_tanh (mmux_\STEM\_t @var{OP})
@deftypefunx mmux_\STEM\_t mmux_\STEM\_asinh (mmux_\STEM\_t @var{OP})
@deftypefunx mmux_\STEM\_t mmux_\STEM\_acosh (mmux_\STEM\_t @var{OP})
@deftypefunx mmux_\STEM\_t mmux_\STEM\_atanh (mmux_\STEM\_t @var{OP})
@deftypefunx mmux_\STEM\_t mmux_\STEM\_exp (mmux_\STEM\_t @var{OP})
@deftypefunx mmux_\STEM\_t mmux_\STEM\_exp2 (mmux_\STEM\_t @var{OP})
@deftypefunx mmux_\STEM\_t mmux_\STEM\_exp10 (mmux_\STEM\_t @var{OP})
@deftypefunx mmux_\STEM\_t mmux_\STEM\_log (mmux_\STEM\_t @var{OP})
@deftypefunx mmux_\STEM\_t mmux_\STEM\_log10 (mmux_\STEM\_t @var{OP})
@deftypefunx mmux_\STEM\_t mmux_\STEM\_log2 (mmux_\STEM\_t @var{OP})
@deftypefunx mmux_\STEM\_t mmux_\STEM\_logb (mmux_\STEM\_t @var{OP})
@deftypefunx mmux_\STEM\_t mmux_\STEM\_pow (mmux_\STEM\_t @vari{OP}, mmux_\STEM\_t @varii{OP})
@deftypefunx mmux_\STEM\_t mmux_\STEM\_sqrt (mmux_\STEM\_t @var{OP})
@deftypefunx mmux_\STEM\_t mmux_\STEM\_cbrt (mmux_\STEM\_t @var{OP})
@deftypefunx mmux_\STEM\_t mmux_\STEM\_hypot (mmux_\STEM\_t @vari{OP}, mmux_\STEM\_t @varii{OP})
@deftypefunx mmux_\STEM\_t mmux_\STEM\_expm1 (mmux_\STEM\_t @var{OP})
@deftypefunx mmux_\STEM\_t mmux_\STEM\_log1p (mmux_\STEM\_t @var{OP})
@deftypefunx mmux_\STEM\_t mmux_\STEM\_erf (mmux_\STEM\_t @var{OP})
@deftypefunx mmux_\STEM\_t mmux_\STEM\_erfc (mmux_\STEM\_t @var{OP})
@deftypefunx mmux_\STEM\_t mmux_\STEM\_lgamma (mmux_\STEM\_t @var{OP})
@deftypefunx mmux_\STEM\_t mmux_\STEM\_tgamma (mmux_\STEM\_t @var{OP})
@deftypefunx mmux_\STEM\_t mmux_\STEM\_j0 (mmux_\STEM\_t @var{OP})
@deftypefunx mmux_\STEM\_t mmux_\STEM\_j1 (mmux_\STEM\_t @var{OP})
@deftypefunx mmux_\STEM\_t mmux_\STEM\_jn (mmux_sint_t @var{N}, mmux_\STEM\_t @var{OP})
@deftypefunx mmux_\STEM\_t mmux_\STEM\_y0 (mmux_\STEM\_t @var{OP})
@deftypefunx mmux_\STEM\_t mmux_\STEM\_y1 (mmux_\STEM\_t @var{OP})
@deftypefunx mmux_\STEM\_t mmux_\STEM\_yn (mmux_sint_t @var{N}, mmux_\STEM\_t @var{OP})
Compute the named C function.
@end deftypefun

@end macro

@c ------------------------------------------------------------------------

@macro MmuxDefineMathRealDecimalFuncs{STEM}
@deftypefun mmux_\STEM\_t mmux_\STEM\_sin (mmux_\STEM\_t @var{OP})
@deftypefunx mmux_\STEM\_t mmux_\STEM\_cos (mmux_\STEM\_t @var{OP})
@deftypefunx mmux_\STEM\_t mmux_\STEM\_tan (mmux_\STEM\_t @var{OP})
@deftypefunx mmux_\STEM\_t mmux_\STEM\_asin (mmux_\STEM\_t @var{OP})
@deftypefunx mmux_\STEM\_t mmux_\STEM\_acos (mmux_\STEM\_t @var{OP})
@deftypefunx mmux_\STEM\_t mmux_\STEM\_atan (mmux_\STEM\_t @var{OP})
@deftypefunx mmux_\STEM\_t mmux_\STEM\_atan2 (mmux_\STEM\_t @vari{OP}, mmux_\STEM\_t @varii{OP})
@deftypefunx mmux_\STEM\_t mmux_\STEM\_sinh (mmux_\STEM\_t @var{OP})
@deftypefunx mmux_\STEM\_t mmux_\STEM\_cosh (mmux_\STEM\_t @var{OP})
@deftypefunx mmux_\STEM\_t mmux_\STEM\_tanh (mmux_\STEM\_t @var{OP})
@deftypefunx mmux_\STEM\_t mmux_\STEM\_asinh (mmux_\STEM\_t @var{OP})
@deftypefunx mmux_\STEM\_t mmux_\STEM\_acosh (mmux_\STEM\_t @var{OP})
@deftypefunx mmux_\STEM\_t mmux_\STEM\_atanh (mmux_\STEM\_t @var{OP})
@deftypefunx mmux_\STEM\_t mmux_\STEM\_exp (mmux_\STEM\_t @var{OP})
@deftypefunx mmux_\STEM\_t mmux_\STEM\_exp2 (mmux_\STEM\_t @var{OP})
@deftypefunx mmux_\STEM\_t mmux_\STEM\_exp10 (mmux_\STEM\_t @var{OP})
@deftypefunx mmux_\STEM\_t mmux_\STEM\_log (mmux_\STEM\_t @var{OP})
@deftypefunx mmux_\STEM\_t mmux_\STEM\_log10 (mmux_\STEM\_t @var{OP})
@deftypefunx mmux_\STEM\_t mmux_\STEM\_log2 (mmux_\STEM\_t @var{OP})
@deftypefunx mmux_\STEM\_t mmux_\STEM\_logb (mmux_\STEM\_t @var{OP})
@deftypefunx mmux_\STEM\_t mmux_\STEM\_pow (mmux_\STEM\_t @vari{OP}, mmux_\STEM\_t @varii{OP})
@deftypefunx mmux_\STEM\_t mmux_\STEM\_sqrt (mmux_\STEM\_t @var{OP})
@deftypefunx mmux_\STEM\_t mmux_\STEM\_cbrt (mmux_\STEM\_t @var{OP})
@deftypefunx mmux_\STEM\_t mmux_\STEM\_hypot (mmux_\STEM\_t @vari{OP}, mmux_\STEM\_t @varii{OP})
@deftypefunx mmux_\STEM\_t mmux_\STEM\_expm1 (mmux_\STEM\_t @var{OP})
@deftypefunx mmux_\STEM\_t mmux_\STEM\_log1p (mmux_\STEM\_t @var{OP})
@deftypefunx mmux_\STEM\_t mmux_\STEM\_erf (mmux_\STEM\_t @var{OP})
@deftypefunx mmux_\STEM\_t mmux_\STEM\_erfc (mmux_\STEM\_t @var{OP})
@deftypefunx mmux_\STEM\_t mmux_\STEM\_lgamma (mmux_\STEM\_t @var{OP})
@deftypefunx mmux_\STEM\_t mmux_\STEM\_tgamma (mmux_\STEM\_t @var{OP})
@c @deftypefunx mmux_\STEM\_t mmux_\STEM\_j0 (mmux_\STEM\_t @var{OP})
@c @deftypefunx mmux_\STEM\_t mmux_\STEM\_j1 (mmux_\STEM\_t @var{OP})
@c @deftypefunx mmux_\STEM\_t mmux_\STEM\_jn (mmux_sint_t @var{N}, mmux_\STEM\_t @var{OP})
@c @deftypefunx mmux_\STEM\_t mmux_\STEM\_y0 (mmux_\STEM\_t @var{OP})
@c @deftypefunx mmux_\STEM\_t mmux_\STEM\_y1 (mmux_\STEM\_t @var{OP})
@c @deftypefunx mmux_\STEM\_t mmux_\STEM\_yn (mmux_sint_t @var{N}, mmux_\STEM\_t @var{OP})
Compute the named C function.
@end deftypefun

@end macro

@c ------------------------------------------------------------------------

@macro MmuxDefineMathComplexFuncs{STEM}
@deftypefun mmux_\STEM\_t mmux_\STEM\_sin (mmux_\STEM\_t @var{OP})
@deftypefunx mmux_\STEM\_t mmux_\STEM\_cos (mmux_\STEM\_t @var{OP})
@deftypefunx mmux_\STEM\_t mmux_\STEM\_tan (mmux_\STEM\_t @var{OP})
@deftypefunx mmux_\STEM\_t mmux_\STEM\_asin (mmux_\STEM\_t @var{OP})
@deftypefunx mmux_\STEM\_t mmux_\STEM\_acos (mmux_\STEM\_t @var{OP})
@deftypefunx mmux_\STEM\_t mmux_\STEM\_atan (mmux_\STEM\_t @var{OP})
@deftypefunx mmux_\STEM\_t mmux_\STEM\_sinh (mmux_\STEM\_t @var{OP})
@deftypefunx mmux_\STEM\_t mmux_\STEM\_cosh (mmux_\STEM\_t @var{OP})
@deftypefunx mmux_\STEM\_t mmux_\STEM\_tanh (mmux_\STEM\_t @var{OP})
@deftypefunx mmux_\STEM\_t mmux_\STEM\_asinh (mmux_\STEM\_t @var{OP})
@deftypefunx mmux_\STEM\_t mmux_\STEM\_acosh (mmux_\STEM\_t @var{OP})
@deftypefunx mmux_\STEM\_t mmux_\STEM\_atanh (mmux_\STEM\_t @var{OP})
@deftypefunx mmux_\STEM\_t mmux_\STEM\_exp (mmux_\STEM\_t @var{OP})
@deftypefunx mmux_\STEM\_t mmux_\STEM\_exp2 (mmux_\STEM\_t @var{OP})
@deftypefunx mmux_\STEM\_t mmux_\STEM\_exp10 (mmux_\STEM\_t @var{OP})
@deftypefunx mmux_\STEM\_t mmux_\STEM\_log (mmux_\STEM\_t @var{OP})
@deftypefunx mmux_\STEM\_t mmux_\STEM\_log2 (mmux_\STEM\_t @var{OP})
@deftypefunx mmux_\STEM\_t mmux_\STEM\_log10 (mmux_\STEM\_t @var{OP})
@deftypefunx mmux_\STEM\_t mmux_\STEM\_pow (mmux_\STEM\_t @vari{OP}, mmux_\STEM\_t @varii{OP})
@deftypefunx mmux_\STEM\_t mmux_\STEM\_sqrt (mmux_\STEM\_t @var{OP})
Compute the named C function.
@end deftypefun

@end macro

@c ------------------------------------------------------------------------

@MmuxDefineMathRealFuncs{float}
@MmuxDefineMathRealFuncs{double}
@MmuxDefineMathRealFuncs{ldouble}

@MmuxDefineMathRealFuncs{float32}
@MmuxDefineMathRealFuncs{float64}
@MmuxDefineMathRealFuncs{float128}

@MmuxDefineMathRealFuncs{float32x}
@MmuxDefineMathRealFuncs{float64x}
@MmuxDefineMathRealFuncs{float128x}

@MmuxDefineMathRealDecimalFuncs{decimal32}
@MmuxDefineMathRealDecimalFuncs{decimal64}
@MmuxDefineMathRealDecimalFuncs{decimal128}

@MmuxDefineMathComplexFuncs{complexf}
@MmuxDefineMathComplexFuncs{complexd}
@MmuxDefineMathComplexFuncs{complexld}

@MmuxDefineMathComplexFuncs{complexf32}
@MmuxDefineMathComplexFuncs{complexf64}
@MmuxDefineMathComplexFuncs{complexf128}

@MmuxDefineMathComplexFuncs{complexf32x}
@MmuxDefineMathComplexFuncs{complexf64x}
@MmuxDefineMathComplexFuncs{complexf128x}

@ignore
@MmuxDefineMathComplexFuncs{complexd32}
@MmuxDefineMathComplexFuncs{complexd64}
@MmuxDefineMathComplexFuncs{complexd128}
@end ignore

@c page
@node bitwise
@chapter Bitwise operations


@deftypefun mmux_pointer_t mmux_pointer_bitwise_and (mmux_pointer_t @var{OP}, mmux_uintptr_t @var{MASK})
@deftypefunx mmux_pointer_t mmux_pointer_bitwise_or (mmux_pointer_t @var{OP}, mmux_uintptr_t @var{MASK})
@deftypefunx mmux_pointer_t mmux_pointer_bitwise_xor (mmux_pointer_t @var{OP}, mmux_uintptr_t @var{MASK})
@deftypefunx mmux_pointer_t mmux_pointer_bitwise_not (mmux_pointer_t @var{OP})
@deftypefunx mmux_pointer_t mmux_pointer_bitwise_shl (mmux_pointer_t @var{OP}, mmux_sint_t @var{NBITS})
@deftypefunx mmux_pointer_t mmux_pointer_bitwise_shr (mmux_pointer_t @var{OP}, mmux_sint_t @var{NBITS})
Perform the bitwise operations on a pointer value.
@end deftypefun


@macro MmuxDefineBitwiseFuncs{STEM}
@deftypefun mmux_\STEM\_t mmux_\STEM\_bitwise_and (mmux_\STEM\_t @vari{OP}, mmux_\STEM\_t @varii{OP})
@deftypefunx mmux_\STEM\_t mmux_\STEM\_bitwise_or (mmux_\STEM\_t @vari{OP}, mmux_\STEM\_t @varii{OP})
@deftypefunx mmux_\STEM\_t mmux_\STEM\_bitwise_xor (mmux_\STEM\_t @vari{OP}, mmux_\STEM\_t @varii{OP})
@deftypefunx mmux_\STEM\_t mmux_\STEM\_bitwise_not (mmux_\STEM\_t @var{OP})
@deftypefunx mmux_\STEM\_t mmux_\STEM\_bitwise_shl (mmux_\STEM\_t @var{OP}, mmux_sint_t @var{NBITS})
@deftypefunx mmux_\STEM\_t mmux_\STEM\_bitwise_shr (mmux_\STEM\_t @var{OP}, mmux_sint_t @var{NBITS})
Perform the bitwise operations.
@end deftypefun

@end macro

@MmuxDefineBitwiseFuncs{char}
@MmuxDefineBitwiseFuncs{schar}
@MmuxDefineBitwiseFuncs{uchar}
@MmuxDefineBitwiseFuncs{sshort}
@MmuxDefineBitwiseFuncs{ushort}
@MmuxDefineBitwiseFuncs{sint}
@MmuxDefineBitwiseFuncs{uint}
@MmuxDefineBitwiseFuncs{slong}
@MmuxDefineBitwiseFuncs{ulong}
@MmuxDefineBitwiseFuncs{sllong}
@MmuxDefineBitwiseFuncs{ullong}

@MmuxDefineBitwiseFuncs{sint8}
@MmuxDefineBitwiseFuncs{uint8}
@MmuxDefineBitwiseFuncs{sint16}
@MmuxDefineBitwiseFuncs{uint16}
@MmuxDefineBitwiseFuncs{sint32}
@MmuxDefineBitwiseFuncs{uint32}
@MmuxDefineBitwiseFuncs{sint64}
@MmuxDefineBitwiseFuncs{uint64}

@MmuxDefineBitwiseFuncs{ssize}
@MmuxDefineBitwiseFuncs{usize}
@MmuxDefineBitwiseFuncs{sintmax}
@MmuxDefineBitwiseFuncs{uintmax}
@MmuxDefineBitwiseFuncs{sintptr}
@MmuxDefineBitwiseFuncs{uintptr}
@MmuxDefineBitwiseFuncs{ptrdiff}
@MmuxDefineBitwiseFuncs{mode}
@MmuxDefineBitwiseFuncs{off}
@MmuxDefineBitwiseFuncs{pid}
@MmuxDefineBitwiseFuncs{uid}
@MmuxDefineBitwiseFuncs{gid}
@MmuxDefineBitwiseFuncs{wchar}
@MmuxDefineBitwiseFuncs{wint}
@MmuxDefineBitwiseFuncs{time}
@MmuxDefineBitwiseFuncs{socklen}
@MmuxDefineBitwiseFuncs{rlim}

@c page
@c ------------------------------------------------------------
@c Appendices.
@c ------------------------------------------------------------

@include gpl-3.0.texi
@include fdl-1.3.texi

@c page
@node references
@appendix Bibliography and references


The documentation of @value{PACKAGE} is available online:

@center @value{DocumentationUrl}

@noindent
development takes place at:

@center @value{GithubUrl}

the package @code{libdfp} is available online:

@center @url{https://github.com/libdfp/libdfp}

@c page
@node concept index
@appendix An entry for each concept

@printindex cp

@node function index
@appendix An entry for each function.

@printindex fn

@node variable index
@appendix An entry for each variable.

@printindex vr

@node type index
@appendix An entry for each type.

@printindex tp

@contents
@bye

@c end of file

