\input texinfo.tex
@c %**start of header
@setfilename mmux-cc-types.info
@settitle MMUX CC Types
@c %**end of header

@c @include version.texi
@include mmux-version.texi
@include macros.texi
@include aliased-types.texi

@c page
@c ------------------------------------------------------------
@c Values.
@c ------------------------------------------------------------

@set TITLE                      MMUX CC Types

@c To be used as @value{PACKAGE} whenever we need to include the full
@c name of this package.
@set PACKAGE                    MMUX CC Types

@c To be used as @value{PACKAGE} whenever we need to include the
@c nickname of the project: the name that is used to compose the
@c distribution tarball or the web address.
@set PACKAGE_NICKNAME           mmux-cc-types

@c To be used as @value{AUTHOR} whenever we need to include the list of
@c authors of this document.
@set AUTHOR                     Marco Maggi

@c To be used as @value{AUTHOR_EMAIL} whenever we need to include the
@c email of the *single* author of this document.
@set AUTHOR_EMAIL               @email{mrc.mgg@@gmail.com}

@c To be used as @value{COPYRIGHT_YEARS} whenever we need to include the
@c list of copyright years.
@set COPYRIGHT_YEARS            2024, 2025

@c ------------------------------------------------------------

@set PackageAutoconfPrefix              MMUX_CC_TYPES
@set PackagePkgconfigModule             mmux-cc-types
@set PackageLibsVar                     @env{MMUX_CC_TYPES_LIBS}
@set PackageCflagsVar                   @env{MMUX_CC_TYPES_CFLAGS}
@c This is the stem of the library in "libmmux-cc-types.so".
@set PackageLibstem                     mmux-cc-types
@set PackageApiPrefixLower              mmux_
@set PackageApiPrefixUpper              MMUX_

@set PackageHeader                      mmux-cc-types.h
@set PackageHeaderFile                  @file{@value{PackageHeader}}

@set GithubUrl                 @url{https://github.com/marcomaggi/@value{PACKAGE_NICKNAME}}
@set DocumentationUrl          @url{https://marcomaggi.github.io/docs/@value{PACKAGE_NICKNAME}.html}

@c page
@c ------------------------------------------------------------
@c Local macros.
@c ------------------------------------------------------------

@ifinfo
@macro mbfl{}
@acronym{MBFL}
@end macro
@end ifinfo
@ifnotinfo
@macro mbfl{}
@acronym{mbfl}
@end macro
@end ifnotinfo

@ifinfo
@macro mmux{}
@acronym{MMUX}
@end macro
@end ifinfo
@ifnotinfo
@macro mmux{}
@acronym{mmux}
@end macro
@end ifnotinfo

@c page
@c ------------------------------------------------------------
@c Copyright notice.
@c ------------------------------------------------------------

@copying
This document describes version @value{MmuxPkgSemanticVersion} of @value{PACKAGE}, a C23 language
library, with @gnu{} C Compiler extensions, implementing an @api{} to interface C23 language types
with higher--level platforms.  The source code must be compiled with the @gnu{} C Compiler
(@command{gcc}) and it depends on the @gnu{} C Library (@command{glibc}) and the @emph{Decimal
Floating Point C Library} (@command{libdfp}).

The package targets @posix{} platforms.

This package is distributed under the terms of the @gnu{} General Public License (@gpl{}).

Development of this package takes place at:

@center @value{GithubUrl}

@noindent
Copyright @copyright{} @value{COPYRIGHT_YEARS} by @value{AUTHOR} @value{AUTHOR_EMAIL}

@quotation
Permission is granted to copy, distribute and/or modify this document under the terms of the @gnu{}
Free Documentation License, Version 1.3 or any later version published by the Free Software
Foundation; with Invariant Sections being ``@gnu{} Free Documentation License'' and ``@gnu{} Lesser
General Public License'', no Front--Cover Texts, and no Back--Cover Texts.  A copy of the license is
included in the section entitled ``@gnu{} Free Documentation License''.
@end quotation
@end copying

@c page
@c ------------------------------------------------------------
@c Headers.
@c ------------------------------------------------------------

@titlepage
@title @value{TITLE}
@subtitle Revision @value{MmuxPkgSemanticVersion}
@author @value{AUTHOR} @value{AUTHOR_EMAIL}
@page
@vskip 0pt plus 1filll
@insertcopying
@end titlepage

@c ------------------------------------------------------------

@ifinfo
@dircategory Development
@direntry
* mmux-cc-types: (mmux-cc-types).       C23 language library handling core types.
@end direntry
@end ifinfo

@c ------------------------------------------------------------

@ignore
@syncodeindex tp cp
@syncodeindex vr cp
@syncodeindex fn cp
@end ignore

@c page
@ifnottex
@node Top
@top @value{TITLE}

@insertcopying

@menu
* overview::                    Overview of the package.
* version::                     Version functions.
* initialisation::              Library initialisation.
* config::                      How to configure code to link the library.
* typedefs::                    Type definitions.
* literals::                    Generating literal constants.
* makers::                      Making values.
* constants::                   Functions returning constant values.
* stringrep::                   String representations of supported types.
* real::                        Basic real numbers operations.
* complex::                     Basic complex numbers operations.
* predicates::                  Type predicates.
* comparison::                  Comparison functions.
* arithmetics::                 Arithmetical operations.
* mathematics::                 Mathematical operations.
* bitwise::                     Bitwise operations.
* generic::                     Miscellaneous generic macros.

Appendices

* Package License::             GNU General Public License.
* Documentation License::       GNU Free Documentation License.
* references::                  Bibliography and references.

Indexes

* concept index::               An entry for each concept.
* function index::              An entry for each function.
* variable index::              An entry for each variable.
* type index::                  An entry for each type.
@end menu
@end ifnottex

@c page
@node overview
@chapter Overview of the package


This document describes version @value{MmuxPkgSemanticVersion} of @value{PACKAGE}, a C23 language
library, with @gnu{} C Compiler extensions, implementing an @api{} to interface C23 language types
with higher--level platforms.  The source code must be compiled with the @gnu{} C Compiler
(@command{gcc}) and it depends on the @gnu{} C Library (@command{glibc}) and the @emph{Decimal
Floating Point C Library} (@command{libdfp}).

@cindex @value{PackageHeaderFile}, header file
@cindex Header file @value{PackageHeaderFile}
@value{PACKAGE} installs multiple header files, of which @value{PackageHeaderFile} is the main one,
exporting the whole library @api{}.  All the function names in the @api{} are prefixed with
@code{@value{PackageApiPrefixLower}}; all the preprocessor symbol names are prefixed with
@code{@value{PackageApiPrefixUpper}}; all the type names are prefixed with
@code{@value{PackageApiPrefixLower}} and suffixed with @code{_t}.

The library is installed under @code{$libdir}; for example:

@example
/usr/local/lib64/lib@value{PackageLibstem}.so
@end example

@noindent
C language header files are installed under @code{$includedir}, for example:

@example
/usr/local/include/@value{PackageHeaderFile}
@end example

@menu
* overview decimal::            Support for the @objtype{_DecimalN} types.
* overview stems::              Specifying C language types with their stem.
* overview errors::             Error handling.
* overview linking::            Linking code with the shared library.
@end menu

@c page
@node overview decimal
@section Support for the @objtype{_DecimalN} types


Support for the @objtype{_DecimalN} types is enabled if availability of such types is detected at
package--configuration time.  This package relies on the availability of the external package
@code{libdfp}, the @emph{Decimal Floating Point C Library}.

@c page
@node overview stems
@section Specifying C language types with their stem


@cindex Type stems
@cindex @code{pointer}, type stem
@cindex @code{pointerc}, type stem
@cindex @code{char}, type stem
@cindex @code{schar}, type stem
@cindex @code{uchar}, type stem
@cindex @code{sshort}, type stem
@cindex @code{ushort}, type stem
@cindex @code{sint}, type stem
@cindex @code{uint}, type stem
@cindex @code{slong}, type stem
@cindex @code{ulong}, type stem
@cindex @code{sllong}, type stem
@cindex @code{ullong}, type stem
@cindex @code{sint8}, type stem
@cindex @code{uint8}, type stem
@cindex @code{sint16}, type stem
@cindex @code{uint16}, type stem
@cindex @code{sint32}, type stem
@cindex @code{uint32}, type stem
@cindex @code{sint64}, type stem
@cindex @code{uint64}, type stem

@cindex @code{byte}, type stem
@cindex @code{octet}, type stem

@cindex @code{ssize}, type stem
@cindex @code{usize}, type stem
@cindex @code{sintmax}, type stem
@cindex @code{uintmax}, type stem
@cindex @code{sintptr}, type stem
@cindex @code{uintptr}, type stem
@cindex @code{ptrdiff}, type stem
@cindex @code{mode}, type stem
@cindex @code{off}, type stem
@cindex @code{pid}, type stem
@cindex @code{uid}, type stem
@cindex @code{gid}, type stem
@cindex @code{wchar}, type stem
@cindex @code{wint}, type stem
@cindex @code{time}, type stem
@cindex @code{socklen}, type stem
@cindex @code{rlim}, type stem
@cindex @code{ino}, type stem
@cindex @code{dev}, type stem
@cindex @code{nlink}, type stem
@cindex @code{blkcnt}, type stem

@cindex @code{flonumfl}, type stem
@cindex @code{flonumdb}, type stem
@cindex @code{flonumldb}, type stem

@cindex @code{flonumf32}, type stem
@cindex @code{flonumf64}, type stem
@cindex @code{flonumf128}, type stem

@cindex @code{flonumf32x}, type stem
@cindex @code{flonumf64x}, type stem
@cindex @code{flonumf128x}, type stem

@cindex @code{flonumd32}, type stem
@cindex @code{flonumd64}, type stem
@cindex @code{flonumd128}, type stem

@cindex @code{flonumcfl}, type stem
@cindex @code{flonumcdb}, type stem
@cindex @code{flonumcldb}, type stem

@cindex @code{flonumcf32}, type stem
@cindex @code{flonumcf64}, type stem
@cindex @code{flonumcf128}, type stem

@cindex @code{flonumcf32x}, type stem
@cindex @code{flonumcf64x}, type stem
@cindex @code{flonumcf128x}, type stem

@cindex @code{flonumcd32}, type stem
@cindex @code{flonumcd64}, type stem
@cindex @code{flonumcd128}, type stem


The following word definitions just alias the corresponding C language type; such uniform names are
useful when using preprocessor macros to generate code.

If @value{PACKAGE} supports a type: it blindly implements all the possible operations for it, even
when it looks like an operation does not make much sense.  A type is a type.

@c ------------------------------------------------------------------------

@macro MmuxDefineTypeStem{STEM,TYPE}
@deftp {Type Stem} \STEM\
Single--word specification of a C language type supported by this package.  It is an alias for the C
language type @code{\TYPE\}.
@end deftp

@end macro

@macro MmuxDefineAliasedTypeStem{STEM,TYPE,ALIAS}
@deftp {Type Stem} \STEM\
Single--word specification of a C language type supported by this package.  It is an alias for the C
language type @code{\TYPE\}, which, as this instance of the package installation as been configured,
it is an alias for @code{@value{\ALIAS\}}.
@end deftp

@end macro

@c ------------------------------------------------------------------------

@MmuxDefineTypeStem{pointer,void *}
@MmuxDefineTypeStem{pointerc,void const *}

@MmuxDefineTypeStem{char,char}
@MmuxDefineTypeStem{schar,signed char}
@MmuxDefineTypeStem{uchar,unsigned char}
@MmuxDefineTypeStem{sshort,signed short int}
@MmuxDefineTypeStem{ushort,unsigned short int}
@MmuxDefineTypeStem{sint,signed int}
@MmuxDefineTypeStem{uint,unsigned int}
@MmuxDefineTypeStem{slong,signed long}
@MmuxDefineTypeStem{ulong,unsigned long}
@MmuxDefineTypeStem{sllong,signed long long}
@MmuxDefineTypeStem{ullong,unsigned long long}
@MmuxDefineTypeStem{sint8,int8_t}
@MmuxDefineTypeStem{uint8,uint8_t}
@MmuxDefineTypeStem{sint16,int16_t}
@MmuxDefineTypeStem{uint16,uint16_t}
@MmuxDefineTypeStem{sint32,int32_t}
@MmuxDefineTypeStem{uint32,uint32_t}
@MmuxDefineTypeStem{sint64,int64_t}
@MmuxDefineTypeStem{uint64,uint64_t}

@MmuxDefineTypeStem{byte,int8_t}
@MmuxDefineTypeStem{octet,uint8_t}

@MmuxDefineAliasedTypeStem{ssize,ssize_t,ALIASSSIZE}
@MmuxDefineAliasedTypeStem{usize,size_t,ALIASUSIZE}
@MmuxDefineAliasedTypeStem{sintmax, intmax_t,ALIASSINTMAX}
@MmuxDefineAliasedTypeStem{uintmax, uintmax_t,ALIASUINTMAX}
@MmuxDefineAliasedTypeStem{sintptr, intptr_t,ALIASSINTPTR}
@MmuxDefineAliasedTypeStem{uintptr, uintptr_t,ALIASUINTPTR}
@MmuxDefineAliasedTypeStem{ptrdiff, ptrdiff_t,ALIASPTRDIFF}
@MmuxDefineAliasedTypeStem{mode, mode_t,ALIASMODE}
@MmuxDefineAliasedTypeStem{off, off_t,ALIASOFF}
@MmuxDefineAliasedTypeStem{pid, pid_t,ALIASPID}
@MmuxDefineAliasedTypeStem{uid, uid_t,ALIASUID}
@MmuxDefineAliasedTypeStem{gid, gid_t,ALIASGID}
@MmuxDefineAliasedTypeStem{wchar, wchar_t,ALIASWCHAR}
@MmuxDefineAliasedTypeStem{wint, wint_t,ALIASWINT}
@MmuxDefineAliasedTypeStem{time, time_t,ALIASTIME}
@MmuxDefineAliasedTypeStem{socklen, socklen_t,ALIASSOCKLEN}
@MmuxDefineAliasedTypeStem{rlim, rlim_t,ALIASRLIM}
@MmuxDefineAliasedTypeStem{socklen, socklen_t,ALIASSOCKLEN}
@MmuxDefineAliasedTypeStem{ino, ino_t,ALIASINO}
@MmuxDefineAliasedTypeStem{dev, dev_t,ALIASDEV}
@MmuxDefineAliasedTypeStem{nlink, nlink_t,ALIASNLINK}
@MmuxDefineAliasedTypeStem{blkcnt, blkcnt_t,ALIASBLKCNT}

@MmuxDefineTypeStem{flonumfl,float}
@MmuxDefineTypeStem{flonumdb,flonumdb}
@MmuxDefineTypeStem{flonumldb,long flonumdb}

@MmuxDefineTypeStem{flonumf32, _Float32}
@MmuxDefineTypeStem{flonumf64, _Float64}
@MmuxDefineTypeStem{flonumf128, _Float128}

@MmuxDefineTypeStem{flonumf32x, _Float32x}
@MmuxDefineTypeStem{flonumf64x, _Float64x}
@MmuxDefineTypeStem{flonumf128x, _Float128x}

@MmuxDefineTypeStem{flonumd32, _Decimal32}
@MmuxDefineTypeStem{flonumd64, _Decimal64}
@MmuxDefineTypeStem{flonumd128, _Decimal128}

@MmuxDefineTypeStem{flonumcfl,float complex}
@MmuxDefineTypeStem{flonumcdb,flonumdb complex}
@MmuxDefineTypeStem{flonumcldb,long flonumdb complex}

@MmuxDefineTypeStem{flonumcf32, _Float32 complex}
@MmuxDefineTypeStem{flonumcf64, _Float64 complex}
@MmuxDefineTypeStem{flonumcf128, _Float128 complex}

@MmuxDefineTypeStem{flonumcf32x, _Float32 complex}
@MmuxDefineTypeStem{flonumcf64x, _Float64x complex}
@MmuxDefineTypeStem{flonumcf128x, _Float128x complex}

@deftp {Type Stem} flonumcd32
Single--word specification of a C language type supported by this package.  It is an alias for a
non--standard C language type implementing complex floating--point numbers having
@objtype{flonumd32} values as real and imaginary parts.
@end deftp


@deftp {Type Stem} flonumcd64
Single--word specification of a C language type supported by this package.  It is an alias for a
non--standard C language type implementing complex floating--point numbers having
@objtype{flonumd64} values as real and imaginary parts.
@end deftp


@deftp {Type Stem} flonumcd128
Single--word specification of a C language type supported by this package.  It is an alias for a
non--standard C language type implementing complex floating--point numbers having
@objtype{flonumd128} values as real and imaginary parts.
@end deftp

@c page
@node overview errors
@section Error handling


Most of the functions that can fail return a @objtype{bool} value: @cfalse{} when successful;
@ctrue{} when an error occurs.

@c page

@include overview-linking.texi

@c page
@node version
@chapter Version functions


The installed libraries follow version numbering as established by the @gnu{} Autotools.  For an
explanation of interface numbers as managed by @gnu{} Libtool @xref{Libtool versioning, interface,
Libtool's versioning system, libtool, Shared library support for @gnu{}}.


@deftypefun {mmux_asciizcp_t} mmux_cc_types_version_string (void)
Return a pointer to a statically allocated @asciiz{} string representing the interface version
number.
@end deftypefun


@deftypefun mmux_sint_t mmux_cc_types_version_interface_current (void)
Return an integer representing the library interface current number.
@end deftypefun


@deftypefun mmux_sint_t mmux_cc_types_version_interface_revision (void)
Return an integer representing the library interface current revision number.
@end deftypefun


@deftypefun mmux_sint_t mmux_cc_types_version_interface_age (void)
Return an integer representing the library interface current age.
@end deftypefun

@c page
@node initialisation
@chapter Library initialisation


@deftypefun bool mmux_cc_types_init (void)
Initialise library's internal state.  When successful return @cfalse{}; otherwise return @ctrue{}.
@end deftypefun


@deftypefun bool mmux_cc_types_final (void)
Finalise library's internal state.  It is the reverse of @cfunc{mmux_cc_types_init}.
@end deftypefun

@c page
@node config
@chapter How to configure code to link the library


@cindex Preprocessor constants, supported data types
@cindex Supported data types, preprocessor constants
@cindex Data types, preprocessor constants indicating support enabled


It happens that some rare platform may not implement the C language types @objtype{signed long long
int}, @objtype{unsigned long long int} and @objtype{long double float}; more platforms may not
implement the extension types @objtype{_FloatN} and @objtype{_FloatNx}, which usually are:

@example
_Flonumf32
_Flonumf64
_Flonumf128
_Flonumf32x
_Flonumf64x
_Flonumf128x
@end example

@noindent
even more platforms may not implement the extension types @objtype{_DecimalN}, which usually are:

@example
_Flonumd32
_Flonumd64
_Flonumd128
@end example

@noindent
these types are supported by @value{PACKAGE}.

This package assumes that: if the real floating--point types are supported, the corresponding
complex floating--point types are also supported; so the following types are supported:

@example
_Flonumf32 complex
_Flonumf64 complex
_Flonumf128 complex
_Flonumf32x complex
_Flonumf64x complex
_Flonumf128x complex
@end example

This package implements complex floating--point numbers whose real and imaginary parts are
@objtype{_DecimalN} numbers through a custom data structure.  Such support does not implement all
the usual functions.

At package--configuration time: @value{PACKAGE} tries to determine if these types are supported and
it defines the following symbols in its header files.

@c ------------------------------------------------------------------------

We can use the following C preprocessor symbols with code like:

@example
#ifdef MMUX_CC_TYPES_HAS_FLONUMLDB
... /* the type is available */
#endif
@end example

@macro MmuxDefineCppSymbolHaveType{CPPSTEM}
@defvr {C Preprocessor Symbol} MMUX_CC_TYPES_HAS_\CPPSTEM\
If this preprocessor symbol is defined and its use expands to @samp{1}: the corresponding C language
type is supported.
@end defvr

@end macro

@MmuxDefineCppSymbolHaveType{SLLONG}
@MmuxDefineCppSymbolHaveType{ULLONG}
@MmuxDefineCppSymbolHaveType{FLONUMLDB}
@MmuxDefineCppSymbolHaveType{FLONUMF32}
@MmuxDefineCppSymbolHaveType{FLONUMF64}
@MmuxDefineCppSymbolHaveType{FLONUMF128}
@MmuxDefineCppSymbolHaveType{FLONUMF32X}
@MmuxDefineCppSymbolHaveType{FLONUMF64X}
@MmuxDefineCppSymbolHaveType{FLONUMF128X}
@MmuxDefineCppSymbolHaveType{FLONUMD32}
@MmuxDefineCppSymbolHaveType{FLONUMD64}
@MmuxDefineCppSymbolHaveType{FLONUMD128}
@MmuxDefineCppSymbolHaveType{FLONUMCF32}
@MmuxDefineCppSymbolHaveType{FLONUMCF64}
@MmuxDefineCppSymbolHaveType{FLONUMCF128}
@MmuxDefineCppSymbolHaveType{FLONUMCF32X}
@MmuxDefineCppSymbolHaveType{FLONUMCF64X}
@MmuxDefineCppSymbolHaveType{FLONUMCF128X}
@MmuxDefineCppSymbolHaveType{FLONUMCD32}
@MmuxDefineCppSymbolHaveType{FLONUMCD64}
@MmuxDefineCppSymbolHaveType{FLONUMCD128}

@c page
@node typedefs
@chapter Type definitions


@cindex Type stems
@cindex @code{pointer}, type stem
@cindex @code{pointerc}, type stem
@cindex @code{char}, type stem
@cindex @code{schar}, type stem
@cindex @code{uchar}, type stem
@cindex @code{sshort}, type stem
@cindex @code{ushort}, type stem
@cindex @code{sint}, type stem
@cindex @code{uint}, type stem
@cindex @code{slong}, type stem
@cindex @code{ulong}, type stem
@cindex @code{sllong}, type stem
@cindex @code{ullong}, type stem
@cindex @code{flonumfl}, type stem
@cindex @code{flonumdb}, type stem
@cindex @code{flonumldb}, type stem

@cindex @code{flonumf32}, type stem
@cindex @code{flonumf64}, type stem
@cindex @code{flonumf128}, type stem

@cindex @code{flonumf32x}, type stem
@cindex @code{flonumf64x}, type stem
@cindex @code{flonumf128x}, type stem

@cindex @code{flonumd32}, type stem
@cindex @code{flonumd64}, type stem
@cindex @code{flonumd128}, type stem

@cindex @code{flonumcfl}, type stem
@cindex @code{flonumcdb}, type stem
@cindex @code{flonumcldb}, type stem

@cindex @code{flonumcf32}, type stem
@cindex @code{flonumcf64}, type stem
@cindex @code{flonumcf128}, type stem

@cindex @code{flonumcf32x}, type stem
@cindex @code{flonumcf64x}, type stem
@cindex @code{flonumcf128x}, type stem

@cindex @code{flonumcd32}, type stem
@cindex @code{flonumcd64}, type stem
@cindex @code{flonumcd128}, type stem

@cindex @code{sint8}, type stem
@cindex @code{uint8}, type stem
@cindex @code{sint16}, type stem
@cindex @code{uint16}, type stem
@cindex @code{sint32}, type stem
@cindex @code{uint32}, type stem
@cindex @code{sint64}, type stem
@cindex @code{uint64}, type stem

@cindex @code{ssize}, type stem
@cindex @code{usize}, type stem
@cindex @code{sintmax}, type stem
@cindex @code{uintmax}, type stem
@cindex @code{sintptr}, type stem
@cindex @code{uintptr}, type stem
@cindex @code{ptrdiff}, type stem
@cindex @code{mode}, type stem
@cindex @code{off}, type stem
@cindex @code{pid}, type stem
@cindex @code{uid}, type stem
@cindex @code{gid}, type stem
@cindex @code{wchar}, type stem
@cindex @code{wint}, type stem
@cindex @code{time}, type stem
@cindex @code{socklen}, type stem
@cindex @code{rlim}, type stem

@cindex @code{ino}, type stem
@cindex @code{dev}, type stem
@cindex @code{nlink}, type stem
@cindex @code{blkcnt}, type stem

@cindex @code{asciizp}, type stem
@cindex @code{asciizpp}, type stem
@cindex @code{asciizppp}, type stem
@cindex @code{asciizcp}, type stem
@cindex @code{asciizcpp}, type stem
@cindex @code{asciizcppp}, type stem

We use the following type definitions as aliases and placeholders for the corresponding C language
type; the type name is composed from a ``stem'': a single word representing the name of the type.
Such uniform names are useful when using preprocessor macros to generate code.

The definitions of some data structures leverage the @gnu{} C Compiler extension
@option{-fplan9-extensions} as follows:

@example
typedef struct mmux_ssize_t @{ mmux_@value{ALIASSSIZE}_t; @} mmux_ssize_t;
@end example

@noindent
notice the anonymous field; it means that a pointer to @objtype{mmux_ssize_t} is seen by the
compiler as a pointer to @objtype{mmux_@value{ALIASSSIZE}_t} and also we can write:

@example
mmux_ssize_t    val = @{ .value = mmux_standard_ssize_literal(123) @};

do_something_with(val.value);
@end example

@noindent
because the field @code{value} of @objtype{mmux_@value{ALIASSSIZE}_t} is also seen as a field of
@objtype{mmux_ssize_t}.  Regarding this coding example, notice that, to define a local variable, we
can just write:

@example
auto    val = mmux_ssize_literal(123);

do_something_with(val.value);
@end example

@noindent
which is equivalent to the code above.

@c ------------------------------------------------------------------------

@macro MmuxDefineCAliasTypedef{STEM,TYPE}
@deftp {Typedef} mmux_\STEM\_t
@deftpx {Typedef} mmux_standard_\STEM\_t
The type @objtype{mmux_standard_\STEM\_t} is a simple alias for @objtype{\TYPE\}:

@example
typedef \TYPE\  mmux_standard_\STEM\_t;
@end example

The type @objtype{mmux_\STEM\_t} is a data structure with definition:

@example
typedef struct mmux_\STEM\_t @{ mmux_standard_\STEM\_t value; @} mmux_\STEM\_t;
@end example
@end deftp

@end macro

@c ------------------------------------------------------------------------

@macro MmuxDefineCAliasTypedefForAliasedType{STEM,TYPE,ALIASTYPE}
@deftp {Typedef} mmux_\STEM\_t
@deftpx {Typedef} mmux_standard_\STEM\_t
The type @objtype{mmux_standard_\STEM\_t} is a simple alias for @objtype{\TYPE\}:

@example
typedef \TYPE\  mmux_standard_\STEM\_t;
@end example

The type @objtype{mmux_\STEM\_t} is a data structure with definition:

@example
typedef struct mmux_\STEM\_t @{ mmux_\ALIASTYPE\_t; @} mmux_\STEM\_t;
@end example
@end deftp

@end macro

@c ------------------------------------------------------------------------

@macro MmuxDefineCAliasTypedefPart{COMPLEXSTEM,PARTSTEM}
@deftp {Typedef} mmux_\COMPLEXSTEM\_part_t
Type definition aliasing the C language type @objtype{mmux_\PARTSTEM\_t}, representing the real and
imaginary parts type of @objtype{mmux_\COMPLEXSTEM\_t}.
@end deftp

@end macro

@c ------------------------------------------------------------------------

@deftp {Typedef} mmux_pointer_t
@deftpx {Typedef} mmux_standard_pointer_t
Aliases for @code{void *}.
@end deftp


@deftp {Typedef} mmux_pointerc_t
@deftpx {Typedef} mmux_standard_pointerc_t
Aliases for @code{void const *}.
@end deftp

@c ------------------------------------------------------------------------

@deftp {Typedef} mmux_asciizp_t
@deftpx {Typedef} mmux_asciizcp_t
Type definitions aliasing, respectively, the C language types @code{char *} and @code{char const *};
they are meant to reference an @asciiz{} string.
@end deftp


@deftp {Typedef} mmux_asciizpp_t
@deftpx {Typedef} mmux_asciizcpp_t
Type definition aliasing the C language types @code{char * *} and @code{char const * *}.
@end deftp


@deftp {Typedef} mmux_asciizppp_t
@deftpx {Typedef} mmux_asciizcppp_t
Type definition aliasing the C language types @code{char * * *} and @code{char const * * *}.
@end deftp

@c ------------------------------------------------------------------------

@MmuxDefineCAliasTypedef{char,char}
@MmuxDefineCAliasTypedef{schar,signed char}
@MmuxDefineCAliasTypedef{uchar,unsigned char}
@MmuxDefineCAliasTypedef{sshort,signed short int}
@MmuxDefineCAliasTypedef{ushort,unsigned short int}
@MmuxDefineCAliasTypedef{sint,signed int}
@MmuxDefineCAliasTypedef{uint,unsigned int}
@MmuxDefineCAliasTypedef{slong,signed long}
@MmuxDefineCAliasTypedef{ulong,unsigned long}
@MmuxDefineCAliasTypedef{sllong,signed long long}
@MmuxDefineCAliasTypedef{ullong,unsigned long long}
@MmuxDefineCAliasTypedef{flonumfl,float}
@MmuxDefineCAliasTypedef{flonumdb,double float}
@MmuxDefineCAliasTypedef{flonumldb,long double float}

@MmuxDefineCAliasTypedef{flonumf32, _Flonumf32}
@MmuxDefineCAliasTypedef{flonumf64, _Flonumf64}
@MmuxDefineCAliasTypedef{flonumf128, _Flonumf128}

@MmuxDefineCAliasTypedef{flonumf32x, _Flonumf32x}
@MmuxDefineCAliasTypedef{flonumf64x, _Flonumf64x}
@MmuxDefineCAliasTypedef{flonumf128x, _Flonumf128x}

@MmuxDefineCAliasTypedef{flonumd32, _Flonumd32}
@MmuxDefineCAliasTypedef{flonumd64, _Flonumd64}
@MmuxDefineCAliasTypedef{flonumd128, _Flonumd128}

@MmuxDefineCAliasTypedef{flonumcfl,float complex}
@MmuxDefineCAliasTypedef{flonumcdb,flonumdb complex}
@MmuxDefineCAliasTypedef{flonumcldb,long flonumdb complex}

@MmuxDefineCAliasTypedef{flonumcf32, _Flonumf32 complex}
@MmuxDefineCAliasTypedef{flonumcf64, _Flonumf64 complex}
@MmuxDefineCAliasTypedef{flonumcf128, _Flonumf128 complex}

@MmuxDefineCAliasTypedef{flonumcf32x, _Flonumf32x complex}
@MmuxDefineCAliasTypedef{flonumcf64x, _Flonumf64x complex}
@MmuxDefineCAliasTypedef{flonumcf128x, _Flonumf128x complex}

@deftp {Typedef} mmux_flonumcd32_t
Non--standard type definition representing a complex floating--point number whose real and imaginary
parts are values of type @objtype{mmux_flonumd32_t}.
@end deftp

@deftp {Typedef} mmux_flonumcd64_t
Non--standard type definition representing a complex floating--point number whose real and imaginary
parts are values of type @objtype{mmux_flonumd64_t}.
@end deftp

@deftp {Typedef} mmux_flonumcd128_t
Non--standard type definition representing a complex floating--point number whose real and imaginary
parts are values of type @objtype{mmux_flonumd128_t}.
@end deftp

@MmuxDefineCAliasTypedef{sint8,int8_t}
@MmuxDefineCAliasTypedef{uint8,uint8_t}
@MmuxDefineCAliasTypedef{sint16,int16_t}
@MmuxDefineCAliasTypedef{uint16,uint16_t}
@MmuxDefineCAliasTypedef{sint32,int32_t}
@MmuxDefineCAliasTypedef{uint32,uint32_t}
@MmuxDefineCAliasTypedef{sint64,int64_t}
@MmuxDefineCAliasTypedef{uint64,uint64_t}

@MmuxDefineCAliasTypedefForAliasedType{byte,            sint8_t,        sint8}
@MmuxDefineCAliasTypedefForAliasedType{octet,           uint8_t,        uint8}

@MmuxDefineCAliasTypedefForAliasedType{ssize,           ssize_t,        @value{ALIASSSIZE}}
@MmuxDefineCAliasTypedefForAliasedType{usize,           size_t,         @value{ALIASUSIZE}}
@MmuxDefineCAliasTypedefForAliasedType{sintmax,         intmax_t,       @value{ALIASSINTMAX}}
@MmuxDefineCAliasTypedefForAliasedType{uintmax,         uintmax_t,      @value{ALIASUINTMAX}}
@MmuxDefineCAliasTypedefForAliasedType{sintptr,         intptr_t,       @value{ALIASSINTPTR}}
@MmuxDefineCAliasTypedefForAliasedType{uintptr,         uintptr_t,      @value{ALIASUINTPTR}}
@MmuxDefineCAliasTypedefForAliasedType{ptrdiff,         ptrdiff_t,      @value{ALIASPTRDIFF}}
@MmuxDefineCAliasTypedefForAliasedType{mode,            mode_t,         @value{ALIASMODE}}
@MmuxDefineCAliasTypedefForAliasedType{off,             off_t,          @value{ALIASOFF}}
@MmuxDefineCAliasTypedefForAliasedType{pid,             pid_t,          @value{ALIASPID}}
@MmuxDefineCAliasTypedefForAliasedType{uid,             uid_t,          @value{ALIASUID}}
@MmuxDefineCAliasTypedefForAliasedType{gid,             gid_t,          @value{ALIASGID}}
@MmuxDefineCAliasTypedefForAliasedType{wchar,           wchar_t,        @value{ALIASWCHAR}}
@MmuxDefineCAliasTypedefForAliasedType{wint,            wint_t,         @value{ALIASWINT}}
@MmuxDefineCAliasTypedefForAliasedType{time,            time_t,         @value{ALIASTIME}}
@MmuxDefineCAliasTypedefForAliasedType{socklen,         socklen_t,      @value{ALIASSOCKLEN}}
@MmuxDefineCAliasTypedefForAliasedType{rlim,            rlim_t,         @value{ALIASRLIM}}
@MmuxDefineCAliasTypedefForAliasedType{ino,             ino_t,          @value{ALIASINO}}
@MmuxDefineCAliasTypedefForAliasedType{dev,             dev_t,          @value{ALIASDEV}}
@MmuxDefineCAliasTypedefForAliasedType{nlink,           nlink_t,        @value{ALIASNLINK}}
@MmuxDefineCAliasTypedefForAliasedType{blkcnt,          blkcnt_t,       @value{ALIASBLKCNT}}

@MmuxDefineCAliasTypedefPart{flonumcfl,float}
@MmuxDefineCAliasTypedefPart{flonumcdb,flonumdb}
@MmuxDefineCAliasTypedefPart{flonumcldb,flonumldb}

@MmuxDefineCAliasTypedefPart{flonumcf32, flonumf32}
@MmuxDefineCAliasTypedefPart{flonumcf64, flonumf64}
@MmuxDefineCAliasTypedefPart{flonumcf128, flonumf128}

@MmuxDefineCAliasTypedefPart{flonumcf32x, flonumf32x}
@MmuxDefineCAliasTypedefPart{flonumcf64x, flonumf64x}
@MmuxDefineCAliasTypedefPart{flonumcf128x, flonumf128x}

@MmuxDefineCAliasTypedefPart{flonumcd32, flonumd32}
@MmuxDefineCAliasTypedefPart{flonumcd64, flonumd64}
@MmuxDefineCAliasTypedefPart{flonumcd128, flonumd128}

@c page
@node literals
@chapter Generating literal constants


When a type is supported by @value{PACKAGE}: the corresponding C preprocessor macro generating
literals is defined.  We have to remember that the argument of these macros must be a compatible
number specification.


@deffn {Preprocessor Macro} mmux_standard_unsigned_literal (@var{INTEGER_NUMBER_LITERAL})
Expand into an unsigned integer number literal, using the suffix @samp{U}; the full type of the
unsigned integer is unspecified.

@example
mmux_uchar_t    A = mmux_standard_unsigned_literal(123);
mmux_ushort_t   B = mmux_standard_unsigned_literal(123);
mmux_uint_t     C = mmux_standard_unsigned_literal(123);
mmux_ulong_t    D = mmux_standard_unsigned_literal(123);
@end example
@end deffn

@c ------------------------------------------------------------------------

@macro MmuxDefineLiteralMacro{STEM}
@deffn {Preprocessor Macro} mmux_standard_\STEM\_literal (@var{ARG})
This macro implements the following expansion:

@example
mmux_standard_\STEM\_literal(@var{ARG})
@expansion{} ((mmux_standard_\STEM\_t) (@var{ARG}))
@end example

@noindent
and we can use it as follows:

@example
auto    val = mmux_standard_\STEM\_literal(13)
@end example
@end deffn

@end macro

@c ------------------------------------------------------------------------

@macro MmuxDefineLiteralMacroCplx{STEM,RSTEM}
@deffn {Preprocessor Macro} mmux_standard_\STEM\_literal (@var{ARGRE}, @var{ARGIM})
This macro implements the following expansion:

@example
mmux_standard_\STEM\_literal(@var{ARGRE}, @var{ARGIM})
@expansion{} mmux_standard_\STEM\_rectangular(mmux_standard_\RSTEM\_literal(@var{ARGRE}),
                                        mmux_standard_\RSTEM\_literal(@var{ARGIM}))
@end example

@noindent
and we can use it as follows:

@example
auto    val = mmux_standard_\STEM\_literal(1.2,3.4)
@end example
@end deffn

@end macro

@c ------------------------------------------------------------------------

@macro MmuxDefineLiteralMacroUnsignedInteger{STEM}
@deffn {Preprocessor Macro} mmux_standard_\STEM\_literal (@var{ARG})
This macro implements the following expansion:

@example
mmux_standard_\STEM\_literal(@var{ARG})
@expansion{} ((mmux_standard_\STEM\_t) (mmux_standard_unsigned_literal(@var{ARG})))
@end example

@noindent
and we can use it as follows:

@example
auto    val = mmux_standard_\STEM\_literal(13)
@end example
@end deffn

@end macro

@c ------------------------------------------------------------------------

@macro MmuxDefineLiteralMacroWithSuffix{STEM,SUFFIX,LITERALEXAMPLE}
@deffn {Preprocessor Macro} mmux_standard_\STEM\_literal (@var{ARG})
This macro implements the following expansion:

@example
mmux_standard_\STEM\_literal(@var{ARG})
@expansion{} ((mmux_standard_\STEM\_t) (@var{ARG} ## \SUFFIX\))
@end example

@noindent
and we can use it as follows:

@example
auto    val = mmux_standard_\STEM\_literal(\LITERALEXAMPLE\)
@end example
@end deffn

@end macro

@c ------------------------------------------------------------------------

@deftypefn {Preprocessor Macro} mmux_standard_pointer_t mmux_standard_pointer_literal (@var{ARG})
This macro implements the following expansion:

@example
mmux_standard_pointer_literal(@var{ARG})
@expansion{} ((mmux_standard_pointer_t) (mmux_standard_unsigned_literal(@var{ARG})))
@end example
@end deftypefn


@deftypefn {Preprocessor Macro} mmux_standard_pointerc_t mmux_standard_pointerc_literal (@var{ARG})
This macro implements the following expansion:

@example
mmux_standard_pointerc_literal(@var{ARG})
@expansion{} ((mmux_standard_pointerc_t) (mmux_standard_unsigned_literal(@var{ARG})))
@end example
@end deftypefn

@c ------------------------------------------------------------------------

@MmuxDefineLiteralMacro{char}

@MmuxDefineLiteralMacro{schar}
@MmuxDefineLiteralMacroUnsignedInteger{uchar}

@MmuxDefineLiteralMacro{sshort}
@MmuxDefineLiteralMacroUnsignedInteger{ushort}

@MmuxDefineLiteralMacro{sint}
@MmuxDefineLiteralMacroUnsignedInteger{uint}

@MmuxDefineLiteralMacro{slong}
@MmuxDefineLiteralMacroUnsignedInteger{ulong}

@MmuxDefineLiteralMacroWithSuffix{sllong,LL,123}
@MmuxDefineLiteralMacroWithSuffix{ullong,ULL,123}

@MmuxDefineLiteralMacro{sint8}
@MmuxDefineLiteralMacroUnsignedInteger{uint8}

@MmuxDefineLiteralMacro{sint16}
@MmuxDefineLiteralMacroUnsignedInteger{uint16}

@MmuxDefineLiteralMacro{sint32}
@MmuxDefineLiteralMacroUnsignedInteger{uint32}

@MmuxDefineLiteralMacro{sint64}
@MmuxDefineLiteralMacroUnsignedInteger{uint64}

@MmuxDefineLiteralMacro{byte}
@MmuxDefineLiteralMacroUnsignedInteger{octet}

@MmuxDefineLiteralMacro{ssize}
@MmuxDefineLiteralMacroUnsignedInteger{usize}
@MmuxDefineLiteralMacro{sintmax}
@MmuxDefineLiteralMacroUnsignedInteger{uintmax}
@MmuxDefineLiteralMacro{sintptr}
@MmuxDefineLiteralMacroUnsignedInteger{uintptr}
@MmuxDefineLiteralMacroUnsignedInteger{mode}
@MmuxDefineLiteralMacro{off}
@MmuxDefineLiteralMacro{pid}
@MmuxDefineLiteralMacroUnsignedInteger{uid}
@MmuxDefineLiteralMacroUnsignedInteger{gid}
@MmuxDefineLiteralMacro{ptrdiff}
@MmuxDefineLiteralMacro{wchar}
@MmuxDefineLiteralMacroUnsignedInteger{wint}
@MmuxDefineLiteralMacro{time}
@MmuxDefineLiteralMacroUnsignedInteger{socklen}
@MmuxDefineLiteralMacroUnsignedInteger{rlim}
@MmuxDefineLiteralMacroUnsignedInteger{ino}
@MmuxDefineLiteralMacroUnsignedInteger{dev}
@MmuxDefineLiteralMacroUnsignedInteger{nlink}
@MmuxDefineLiteralMacroUnsignedInteger{blkcnt}

@MmuxDefineLiteralMacroWithSuffix{flonumfl,F,0.123}
@MmuxDefineLiteralMacro{flonumdb}
@MmuxDefineLiteralMacroWithSuffix{flonumldb,L,0.123}

@MmuxDefineLiteralMacroWithSuffix{flonumf32,f32,0.123}
@MmuxDefineLiteralMacroWithSuffix{flonumf64,f64,0.123}
@MmuxDefineLiteralMacroWithSuffix{flonumf128,f128,0.123}

@MmuxDefineLiteralMacroWithSuffix{flonumf32x,f32x,0.123}
@MmuxDefineLiteralMacroWithSuffix{flonumf64x,f64x,0.123}
@MmuxDefineLiteralMacroWithSuffix{flonumf128x,f128x,0.123}

@MmuxDefineLiteralMacroWithSuffix{flonumd32,DF,0.123}
@MmuxDefineLiteralMacroWithSuffix{flonumd64,DD,0.123}
@MmuxDefineLiteralMacroWithSuffix{flonumd128,DL,0.123}

@MmuxDefineLiteralMacroCplx{flonumcfl,flonumfl}
@MmuxDefineLiteralMacroCplx{flonumcdb,flonumdb}
@MmuxDefineLiteralMacroCplx{flonumcldb,flonumldb}

@MmuxDefineLiteralMacroCplx{flonumcf32,flonumf32}
@MmuxDefineLiteralMacroCplx{flonumcf64,flonumf64}
@MmuxDefineLiteralMacroCplx{flonumcf128,flonumf128}

@MmuxDefineLiteralMacroCplx{flonumcf32x,flonumf32x}
@MmuxDefineLiteralMacroCplx{flonumcf64x,flonumf64x}
@MmuxDefineLiteralMacroCplx{flonumcf128x,flonumf128x}

@MmuxDefineLiteralMacroCplx{flonumcd32,flonumd32}
@MmuxDefineLiteralMacroCplx{flonumcd64,flonumd64}
@MmuxDefineLiteralMacroCplx{flonumcd128,flonumd128}

@c page
@node makers
@chapter Making values


@cindex Maker functions
@cindex Literal maker macros
@cindex How to specify a literal value
@cindex How to make a value
@cindex Constructing a value
@cindex Constructing a literal value
@cindex Constructors for values


The @dfn{maker} functions are used as follows:

@example
auto    A = mmux_sint(123);
auto    B = mmux_uint(123);
auto    C = mmux_flonumldb(0.123);
auto    D = mmux_mode(MMUX_LIBC_O_RDWR);

auto    Z = mmux_sint_add(mmux_sint(123), mmux_sint(456));
@end example

@noindent
the return values are data structures of the named type; all the maker functions are @code{inline}.
As an exception: when the type is a pointer, the returned value is the pointer itself.

If a literal value requires a suffix to be correctly specified: we can use the @dfn{literal makers};
these are preprocessor macros we can use as follows:

@example
auto    F = mmux_flonumf64_literal(123.456e5);
auto    G = mmux_flonumd64_literal(-7.4e-4);
@end example

@noindent
it is a generally good practice to use the literal maker every time a value does not result from an
expression.

To construct a complex number from its real and imaginary parts, we do:

@example
auto    rep = mmux_flonumdb_literal(1.2);
auto    imp = mmux_flonumdb_literal(3.4);
auto    Z   = mmux_flonumcdb_rectangular(rep, imp);
@end example

@noindent
or:

@example
auto    Z   = mmux_flonumcldb_rectangular_literal(1.2, 3.4);
@end example

@c ------------------------------------------------------------------------

@macro MmuxDefineCMacroMaker{STEM}
@deftypefn {Function} mmux_\STEM\_t mmux_\STEM\ (mmux_standard_\STEM\_t @var{VALUE})
@deftypefnx {Preprocessor Macro} mmux_\STEM\_t mmux_\STEM\_literal (@var{LITERAL_ARG})
Return a data structure of the named type.  The macro implements the following expansion:

@example
mmux_\STEM\_literal(@var{LITERAL_ARG})
@expansion{} mmux_\STEM\(mmux_standard_\STEM\_literal(@var{LITERAL_ARG}))
@end example
@end deftypefn

@end macro

@macro MmuxDefineComplexMakeRectangularFunction{CPLXSTEM,REALSTEM}
@deftypefn {Function} mmux_\CPLXSTEM\_t mmux_\CPLXSTEM\_rectangular (mmux_\REALSTEM\_t @var{REP}, mmux_\REALSTEM\_t @var{IMP})
@deftypefnx {Preprocessor Macro} mmux_\CPLXSTEM\_t mmux_\CPLXSTEM\_rectangular_literal (@var{LITERAL_REP}, @var{LITERAL_IMP})
Make a data structure holding a complex number, of type @objtype{\CPLXSTEM\}, from the real and
imaginary parts @var{REP} and @var{IMP}, of type @objtype{\REALSTEM\}; return the result.

The macro implements the following expansion:

@example
mmux_\CPLXSTEM\_rectangular_literal (@var{LITERAL_REP}, @var{LITERAL_IMP})
@expansion{} mmux_\CPLXSTEM\_rectangular(mmux_standard_\REALSTEM\_literal(@var{LITERAL_REP}),
                                    mmux_standard_\REALSTEM\_literal(@var{LITERAL_IMP}))
@end example
@end deftypefn

@end macro

@c ------------------------------------------------------------------------

@MmuxDefineCMacroMaker{pointer}
@MmuxDefineCMacroMaker{pointerc}

@MmuxDefineCMacroMaker{char}
@MmuxDefineCMacroMaker{schar}
@MmuxDefineCMacroMaker{uchar}
@MmuxDefineCMacroMaker{sshort}
@MmuxDefineCMacroMaker{ushort}
@MmuxDefineCMacroMaker{sint}
@MmuxDefineCMacroMaker{uint}
@MmuxDefineCMacroMaker{slong}
@MmuxDefineCMacroMaker{ulong}
@MmuxDefineCMacroMaker{sllong}
@MmuxDefineCMacroMaker{ullong}
@MmuxDefineCMacroMaker{sint8}
@MmuxDefineCMacroMaker{uint8}
@MmuxDefineCMacroMaker{sint16}
@MmuxDefineCMacroMaker{uint16}
@MmuxDefineCMacroMaker{sint32}
@MmuxDefineCMacroMaker{uint32}
@MmuxDefineCMacroMaker{sint64}
@MmuxDefineCMacroMaker{uint64}

@MmuxDefineCMacroMaker{byte}
@MmuxDefineCMacroMaker{octet}

@MmuxDefineCMacroMaker{ssize}
@MmuxDefineCMacroMaker{usize}
@MmuxDefineCMacroMaker{sintmax}
@MmuxDefineCMacroMaker{uintmax}
@MmuxDefineCMacroMaker{sintptr}
@MmuxDefineCMacroMaker{uintptr}
@MmuxDefineCMacroMaker{ptrdiff}
@MmuxDefineCMacroMaker{mode}
@MmuxDefineCMacroMaker{off}
@MmuxDefineCMacroMaker{pid}
@MmuxDefineCMacroMaker{uid}
@MmuxDefineCMacroMaker{gid}
@MmuxDefineCMacroMaker{wchar}
@MmuxDefineCMacroMaker{wint}
@MmuxDefineCMacroMaker{time}
@MmuxDefineCMacroMaker{socklen}
@MmuxDefineCMacroMaker{rlim}
@MmuxDefineCMacroMaker{ino}
@MmuxDefineCMacroMaker{dev}
@MmuxDefineCMacroMaker{nlink}
@MmuxDefineCMacroMaker{blkcnt}

@MmuxDefineCMacroMaker{asciip}
@MmuxDefineCMacroMaker{asciipp}
@MmuxDefineCMacroMaker{asciippp}

@MmuxDefineCMacroMaker{asciizp}
@MmuxDefineCMacroMaker{asciizpp}
@MmuxDefineCMacroMaker{asciizppp}

@MmuxDefineCMacroMaker{asciicp}
@MmuxDefineCMacroMaker{asciicpp}
@MmuxDefineCMacroMaker{asciicppp}

@MmuxDefineCMacroMaker{asciizcp}
@MmuxDefineCMacroMaker{asciizcpp}
@MmuxDefineCMacroMaker{asciizcppp}

@MmuxDefineCMacroMaker{flonumfl}
@MmuxDefineCMacroMaker{flonumdb}
@MmuxDefineCMacroMaker{flonumldb}

@MmuxDefineCMacroMaker{flonumf32}
@MmuxDefineCMacroMaker{flonumf64}
@MmuxDefineCMacroMaker{flonumf128}

@MmuxDefineCMacroMaker{flonumf32x}
@MmuxDefineCMacroMaker{flonumf64x}
@MmuxDefineCMacroMaker{flonumf128x}

@MmuxDefineCMacroMaker{flonumd32}
@MmuxDefineCMacroMaker{flonumd64}
@MmuxDefineCMacroMaker{flonumd128}

@c ------------------------------------------------------------------------

@MmuxDefineComplexMakeRectangularFunction{flonumcfl, flonumfl}
@MmuxDefineComplexMakeRectangularFunction{flonumcdb, flonumdb}
@MmuxDefineComplexMakeRectangularFunction{flonumcldb, flonumldb}

@MmuxDefineComplexMakeRectangularFunction{flonumcf32, flonumf32}
@MmuxDefineComplexMakeRectangularFunction{flonumcf64, flonumf64}
@MmuxDefineComplexMakeRectangularFunction{flonumcf128, flonumf128}

@MmuxDefineComplexMakeRectangularFunction{flonumcf32x, flonumf32x}
@MmuxDefineComplexMakeRectangularFunction{flonumcf64x, flonumf64x}
@MmuxDefineComplexMakeRectangularFunction{flonumcf128x, flonumf128x}

@MmuxDefineComplexMakeRectangularFunction{flonumcd32, flonumd32}
@MmuxDefineComplexMakeRectangularFunction{flonumcd64, flonumd64}
@MmuxDefineComplexMakeRectangularFunction{flonumcd128, flonumd128}

@c page
@node constants
@chapter Functions returning constant values


@menu
* constants sizeof::            Size of data types.
* constants limits::            Type maximum and minimum values.
* constants flonum::            Floating--point numbers mathematical constants.
* constants exact::             Exact integer--point numbers constants.
@end menu

@c page
@node constants sizeof
@section Type size measured in bytes


@macro MmuxDefineCFunctionSizeof{STEM}
@deftypefun mmux_sint_t mmux_\STEM\_constant_sizeof (void)
Return a positive integer representing the size in bytes of the C language type
@objtype{mmux_\STEM\_t}.
@end deftypefun

@end macro


@MmuxDefineCFunctionSizeof{pointer}

@MmuxDefineCFunctionSizeof{char}
@MmuxDefineCFunctionSizeof{schar}
@MmuxDefineCFunctionSizeof{uchar}
@MmuxDefineCFunctionSizeof{sshort}
@MmuxDefineCFunctionSizeof{ushort}
@MmuxDefineCFunctionSizeof{sint}
@MmuxDefineCFunctionSizeof{uint}
@MmuxDefineCFunctionSizeof{slong}
@MmuxDefineCFunctionSizeof{ulong}
@MmuxDefineCFunctionSizeof{sllong}
@MmuxDefineCFunctionSizeof{ullong}
@MmuxDefineCFunctionSizeof{flonumfl}
@MmuxDefineCFunctionSizeof{flonumdb}
@MmuxDefineCFunctionSizeof{flonumldb}

@MmuxDefineCFunctionSizeof{flonumf32}
@MmuxDefineCFunctionSizeof{flonumf64}
@MmuxDefineCFunctionSizeof{flonumf128}

@MmuxDefineCFunctionSizeof{flonumf32x}
@MmuxDefineCFunctionSizeof{flonumf64x}
@MmuxDefineCFunctionSizeof{flonumf128x}

@MmuxDefineCFunctionSizeof{flonumd32}
@MmuxDefineCFunctionSizeof{flonumd64}
@MmuxDefineCFunctionSizeof{flonumd128}

@MmuxDefineCFunctionSizeof{flonumcfl}
@MmuxDefineCFunctionSizeof{flonumcdb}
@MmuxDefineCFunctionSizeof{flonumcldb}

@MmuxDefineCFunctionSizeof{flonumcf32}
@MmuxDefineCFunctionSizeof{flonumcf64}
@MmuxDefineCFunctionSizeof{flonumcf128}

@MmuxDefineCFunctionSizeof{flonumcf32x}
@MmuxDefineCFunctionSizeof{flonumcf64x}
@MmuxDefineCFunctionSizeof{flonumcf128x}

@MmuxDefineCFunctionSizeof{flonumcd32}
@MmuxDefineCFunctionSizeof{flonumcd64}
@MmuxDefineCFunctionSizeof{flonumcd128}

@MmuxDefineCFunctionSizeof{sint8}
@MmuxDefineCFunctionSizeof{uint8}
@MmuxDefineCFunctionSizeof{sint16}
@MmuxDefineCFunctionSizeof{uint16}
@MmuxDefineCFunctionSizeof{sint32}
@MmuxDefineCFunctionSizeof{uint32}
@MmuxDefineCFunctionSizeof{sint64}
@MmuxDefineCFunctionSizeof{uint64}

@MmuxDefineCFunctionSizeof{ssize}
@MmuxDefineCFunctionSizeof{usize}
@MmuxDefineCFunctionSizeof{sintmax}
@MmuxDefineCFunctionSizeof{uintmax}
@MmuxDefineCFunctionSizeof{sintptr}
@MmuxDefineCFunctionSizeof{uintptr}
@MmuxDefineCFunctionSizeof{ptrdiff}
@MmuxDefineCFunctionSizeof{mode}
@MmuxDefineCFunctionSizeof{off}
@MmuxDefineCFunctionSizeof{pid}
@MmuxDefineCFunctionSizeof{uid}
@MmuxDefineCFunctionSizeof{gid}
@MmuxDefineCFunctionSizeof{wchar}
@MmuxDefineCFunctionSizeof{wint}
@MmuxDefineCFunctionSizeof{time}
@MmuxDefineCFunctionSizeof{socklen}
@MmuxDefineCFunctionSizeof{rlim}

@MmuxDefineCFunctionSizeof{ino}
@MmuxDefineCFunctionSizeof{dev}
@MmuxDefineCFunctionSizeof{nlink}
@MmuxDefineCFunctionSizeof{blkcnt}

@c page
@node constants limits
@section Type maximum and minimum values


The following functions return the maximum and minimum values representable by a C language real
number type; this is true even for floating--point numbers: the returned minimum value is the
minimum negative representable value.  This is different from the standard C language constants like
@code{FLT_MIN}, @code{DBL_MIN}, @code{LDBL_MIN}, which represent some sort of minimum representable
positive value.


@macro MmuxDefineCFunctionMaximum{STEM}
@deftypefun mmux_\STEM\_t mmux_\STEM\_constant_maximum (void)
@deftypefunx mmux_\STEM\_t mmux_\STEM\_constant_minimum (void)
Return the maximum and minimum values representable by the range of values of the type
@objtype{mmux_\STEM\_t}.
@end deftypefun

@end macro


@MmuxDefineCFunctionMaximum{pointer}

@MmuxDefineCFunctionMaximum{char}
@MmuxDefineCFunctionMaximum{schar}
@MmuxDefineCFunctionMaximum{uchar}
@MmuxDefineCFunctionMaximum{sshort}
@MmuxDefineCFunctionMaximum{ushort}
@MmuxDefineCFunctionMaximum{sint}
@MmuxDefineCFunctionMaximum{uint}
@MmuxDefineCFunctionMaximum{slong}
@MmuxDefineCFunctionMaximum{ulong}
@MmuxDefineCFunctionMaximum{sllong}
@MmuxDefineCFunctionMaximum{ullong}
@MmuxDefineCFunctionMaximum{flonumfl}
@MmuxDefineCFunctionMaximum{flonumdb}
@MmuxDefineCFunctionMaximum{flonumldb}

@MmuxDefineCFunctionMaximum{flonumf32}
@MmuxDefineCFunctionMaximum{flonumf64}
@MmuxDefineCFunctionMaximum{flonumf128}

@MmuxDefineCFunctionMaximum{flonumf32x}
@MmuxDefineCFunctionMaximum{flonumf64x}
@MmuxDefineCFunctionMaximum{flonumf128x}

@MmuxDefineCFunctionMaximum{flonumd32}
@MmuxDefineCFunctionMaximum{flonumd64}
@MmuxDefineCFunctionMaximum{flonumd128}

@MmuxDefineCFunctionMaximum{sint8}
@MmuxDefineCFunctionMaximum{uint8}
@MmuxDefineCFunctionMaximum{sint16}
@MmuxDefineCFunctionMaximum{uint16}
@MmuxDefineCFunctionMaximum{sint32}
@MmuxDefineCFunctionMaximum{uint32}
@MmuxDefineCFunctionMaximum{sint64}
@MmuxDefineCFunctionMaximum{uint64}

@MmuxDefineCFunctionMaximum{ssize}
@MmuxDefineCFunctionMaximum{usize}
@MmuxDefineCFunctionMaximum{sintmax}
@MmuxDefineCFunctionMaximum{uintmax}
@MmuxDefineCFunctionMaximum{sintptr}
@MmuxDefineCFunctionMaximum{uintptr}
@MmuxDefineCFunctionMaximum{ptrdiff}
@MmuxDefineCFunctionMaximum{mode}
@MmuxDefineCFunctionMaximum{off}
@MmuxDefineCFunctionMaximum{pid}
@MmuxDefineCFunctionMaximum{uid}
@MmuxDefineCFunctionMaximum{gid}
@MmuxDefineCFunctionMaximum{wchar}
@MmuxDefineCFunctionMaximum{wint}
@MmuxDefineCFunctionMaximum{time}
@MmuxDefineCFunctionMaximum{socklen}
@MmuxDefineCFunctionMaximum{rlim}
@MmuxDefineCFunctionMaximum{ino}
@MmuxDefineCFunctionMaximum{dev}
@MmuxDefineCFunctionMaximum{nlink}
@MmuxDefineCFunctionMaximum{blkcnt}

@c page
@node constants flonum
@section Floating--point numbers mathematical constants


@macro MmuxDefineFlonumConstantFunction{STEM,FUNCSTEM,EXPR}
@deftypefun mmux_\STEM\_t mmux_\STEM\_constant_\FUNCSTEM\ (void)
Return a constant value corresponding to @samp{\EXPR\}.
@end deftypefun

@end macro

@c ------------------------------------------------------------------------

@macro MmuxDefineFlonumConstantFunctions{STEM}
@MmuxDefineFlonumConstantFunction{\STEM\,zero,0.0}
@MmuxDefineFlonumConstantFunction{\STEM\,one,1.0}
@MmuxDefineFlonumConstantFunction{\STEM\,two,2.0}
@MmuxDefineFlonumConstantFunction{\STEM\,ten,10.0}
@MmuxDefineFlonumConstantFunction{\STEM\,one_half,1.0/2.0}
@MmuxDefineFlonumConstantFunction{\STEM\,one_third,1.0/3.0}

@MmuxDefineFlonumConstantFunction{\STEM\,positive_zero,+0.0}
@MmuxDefineFlonumConstantFunction{\STEM\,negative_zero,-0.0}
@MmuxDefineFlonumConstantFunction{\STEM\,positive_infinity,+inf.0}
@MmuxDefineFlonumConstantFunction{\STEM\,negative_infinity,-inf.0}

@MmuxDefineFlonumConstantFunction{\STEM\,nan,+nan.0}
@MmuxDefineFlonumConstantFunction{\STEM\,E,e}
@MmuxDefineFlonumConstantFunction{\STEM\,LOG2E,log_2(e)}
@MmuxDefineFlonumConstantFunction{\STEM\,LOG10E,log_10(e)}
@MmuxDefineFlonumConstantFunction{\STEM\,LN2,ln(2)}
@MmuxDefineFlonumConstantFunction{\STEM\,LN10,ln(10)}
@MmuxDefineFlonumConstantFunction{\STEM\,PI,pi}
@MmuxDefineFlonumConstantFunction{\STEM\,PI_2,pi/2}
@MmuxDefineFlonumConstantFunction{\STEM\,PI_4,pi/4}
@MmuxDefineFlonumConstantFunction{\STEM\,1_PI,1/pi}
@MmuxDefineFlonumConstantFunction{\STEM\,2_PI,2/pi}
@MmuxDefineFlonumConstantFunction{\STEM\,2_SQRTPI,2/sqrt(pi)}
@MmuxDefineFlonumConstantFunction{\STEM\,SQRT2,sqrt(2)}
@MmuxDefineFlonumConstantFunction{\STEM\,SQRT1_2,sqrt(1/2)}
@end macro

@c ------------------------------------------------------------------------

@MmuxDefineFlonumConstantFunctions{flonumfl}
@MmuxDefineFlonumConstantFunctions{flonumdb}
@MmuxDefineFlonumConstantFunctions{flonumldb}

@MmuxDefineFlonumConstantFunctions{flonumf32}
@MmuxDefineFlonumConstantFunctions{flonumf64}
@MmuxDefineFlonumConstantFunctions{flonumf128}

@MmuxDefineFlonumConstantFunctions{flonumf32x}
@MmuxDefineFlonumConstantFunctions{flonumf64x}
@MmuxDefineFlonumConstantFunctions{flonumf128x}

@MmuxDefineFlonumConstantFunctions{flonumd32}
@MmuxDefineFlonumConstantFunctions{flonumd64}
@MmuxDefineFlonumConstantFunctions{flonumd128}

@c page
@node constants exact
@section Exact integer--point numbers constants


@macro MmuxDefineExactConstantFunction{STEM,FUNCSTEM,EXPR}
@deftypefun mmux_\STEM\_t mmux_\STEM\_constant_\FUNCSTEM\ (void)
Return a constant value corresponding to @samp{\EXPR\}.
@end deftypefun

@end macro

@c ------------------------------------------------------------------------

@macro MmuxDefineExactConstantFunctions{STEM}
@MmuxDefineExactConstantFunction{\STEM\,zero,0}
@MmuxDefineExactConstantFunction{\STEM\,one,1}
@MmuxDefineExactConstantFunction{\STEM\,two,2}
@MmuxDefineExactConstantFunction{\STEM\,ten,10}
@end macro

@c ------------------------------------------------------------------------

@MmuxDefineExactConstantFunctions{char}
@MmuxDefineExactConstantFunctions{schar}
@MmuxDefineExactConstantFunctions{uchar}
@MmuxDefineExactConstantFunctions{sshort}
@MmuxDefineExactConstantFunctions{ushort}
@MmuxDefineExactConstantFunctions{sint}
@MmuxDefineExactConstantFunctions{uint}
@MmuxDefineExactConstantFunctions{slong}
@MmuxDefineExactConstantFunctions{ulong}
@MmuxDefineExactConstantFunctions{sllong}
@MmuxDefineExactConstantFunctions{ullong}
@MmuxDefineExactConstantFunctions{sint8}
@MmuxDefineExactConstantFunctions{uint8}
@MmuxDefineExactConstantFunctions{sint16}
@MmuxDefineExactConstantFunctions{uint16}
@MmuxDefineExactConstantFunctions{sint32}
@MmuxDefineExactConstantFunctions{uint32}
@MmuxDefineExactConstantFunctions{sint64}
@MmuxDefineExactConstantFunctions{uint64}

@MmuxDefineExactConstantFunctions{byte}
@MmuxDefineExactConstantFunctions{octet}
@MmuxDefineExactConstantFunctions{ssize}
@MmuxDefineExactConstantFunctions{usize}
@MmuxDefineExactConstantFunctions{sintmax}
@MmuxDefineExactConstantFunctions{uintmax}
@MmuxDefineExactConstantFunctions{sintptr}
@MmuxDefineExactConstantFunctions{uintptr}
@MmuxDefineExactConstantFunctions{mode}
@MmuxDefineExactConstantFunctions{off}
@MmuxDefineExactConstantFunctions{pid}
@MmuxDefineExactConstantFunctions{uid}
@MmuxDefineExactConstantFunctions{gid}
@MmuxDefineExactConstantFunctions{ptrdiff}
@MmuxDefineExactConstantFunctions{wchar}
@MmuxDefineExactConstantFunctions{wint}
@MmuxDefineExactConstantFunctions{time}
@MmuxDefineExactConstantFunctions{socklen}
@MmuxDefineExactConstantFunctions{rlim}

@c page
@node stringrep
@chapter String representations of supported types


@menu
* stringrep complex::           Peculiar string representation for complex floating--point numbers.
* stringrep predicates::        Type predicates for string representations.
* stringrep formats::           Selecting the printing format for floating--point numbers.
* stringrep parsers::           Parsing string representations of C language types.
* stringrep sprinters::         Printing string representations of C language types.
@end menu

@c page
@node stringrep complex
@section Peculiar string representation for complex floating--point numbers


This package's ``official'' representation of complex numbers is like this:

@example
(1.2)+i*(3.4)
@end example

@noindent
in which both the real part @samp{1.2} and the imaginary part @samp{3.4} are enclosed in
parentheses; this way any format for the real numbers can be used in the string representation of
complex numbers reducing the work needed by human eyes to parse the expression.  Example:

@example
(0x1.3333333333333p+0)+i*(0x1.b333333333333p+1)
@end example

@c page
@node stringrep predicates
@section Type predicates for string representations


@macro MmuxDefineCFunctionPredicate{STEM}
@deftypefun bool mmux_string_is_\STEM\ (char const * @var{str})
Return @ctrue{} if @var{str} references the string representation, in @asciiz{} format, of a value
of type @objtype{mmux_\STEM\_t}; otherwise return @cfalse{}.
@end deftypefun

@end macro


@MmuxDefineCFunctionPredicate{pointer}

@MmuxDefineCFunctionPredicate{char}
@MmuxDefineCFunctionPredicate{schar}
@MmuxDefineCFunctionPredicate{uchar}
@MmuxDefineCFunctionPredicate{sshort}
@MmuxDefineCFunctionPredicate{ushort}
@MmuxDefineCFunctionPredicate{sint}
@MmuxDefineCFunctionPredicate{uint}
@MmuxDefineCFunctionPredicate{slong}
@MmuxDefineCFunctionPredicate{ulong}
@MmuxDefineCFunctionPredicate{sllong}
@MmuxDefineCFunctionPredicate{ullong}
@MmuxDefineCFunctionPredicate{flonumfl}
@MmuxDefineCFunctionPredicate{flonumdb}
@MmuxDefineCFunctionPredicate{flonumldb}

@MmuxDefineCFunctionPredicate{flonumf32}
@MmuxDefineCFunctionPredicate{flonumf64}
@MmuxDefineCFunctionPredicate{flonumf128}

@MmuxDefineCFunctionPredicate{flonumf32x}
@MmuxDefineCFunctionPredicate{flonumf64x}
@MmuxDefineCFunctionPredicate{flonumf128x}

@MmuxDefineCFunctionPredicate{flonumd32}
@MmuxDefineCFunctionPredicate{flonumd64}
@MmuxDefineCFunctionPredicate{flonumd128}

@MmuxDefineCFunctionPredicate{flonumcfl}
@MmuxDefineCFunctionPredicate{flonumcdb}
@MmuxDefineCFunctionPredicate{flonumcldb}

@MmuxDefineCFunctionPredicate{flonumcf32}
@MmuxDefineCFunctionPredicate{flonumcf64}
@MmuxDefineCFunctionPredicate{flonumcf128}

@MmuxDefineCFunctionPredicate{flonumcf32x}
@MmuxDefineCFunctionPredicate{flonumcf64x}
@MmuxDefineCFunctionPredicate{flonumcf128x}

@MmuxDefineCFunctionPredicate{flonumcd32}
@MmuxDefineCFunctionPredicate{flonumcd64}
@MmuxDefineCFunctionPredicate{flonumcd128}

@MmuxDefineCFunctionPredicate{sint8}
@MmuxDefineCFunctionPredicate{uint8}
@MmuxDefineCFunctionPredicate{sint16}
@MmuxDefineCFunctionPredicate{uint16}
@MmuxDefineCFunctionPredicate{sint32}
@MmuxDefineCFunctionPredicate{uint32}
@MmuxDefineCFunctionPredicate{sint64}
@MmuxDefineCFunctionPredicate{uint64}

@MmuxDefineCFunctionPredicate{byte}
@MmuxDefineCFunctionPredicate{octet}

@MmuxDefineCFunctionPredicate{ssize}
@MmuxDefineCFunctionPredicate{usize}
@MmuxDefineCFunctionPredicate{sintmax}
@MmuxDefineCFunctionPredicate{uintmax}
@MmuxDefineCFunctionPredicate{sintptr}
@MmuxDefineCFunctionPredicate{uintptr}
@MmuxDefineCFunctionPredicate{ptrdiff}
@MmuxDefineCFunctionPredicate{mode}
@MmuxDefineCFunctionPredicate{off}
@MmuxDefineCFunctionPredicate{pid}
@MmuxDefineCFunctionPredicate{uid}
@MmuxDefineCFunctionPredicate{gid}
@MmuxDefineCFunctionPredicate{wchar}
@MmuxDefineCFunctionPredicate{wint}
@MmuxDefineCFunctionPredicate{time}
@MmuxDefineCFunctionPredicate{socklen}
@MmuxDefineCFunctionPredicate{rlim}
@MmuxDefineCFunctionPredicate{ino}
@MmuxDefineCFunctionPredicate{dev}
@MmuxDefineCFunctionPredicate{nlink}
@MmuxDefineCFunctionPredicate{blkcnt}

@c page
@node stringrep formats
@section Selecting the printing format for floating--point numbers


@cindex Printing format for floating--point numbers
@cindex Formatting floating--point numbers
@cindex String format for infinities
@cindex Output format for infinities
@cindex Infinities, string format
@cindex Infinities, Output format
@cindex @samp{+inf.0} positive infinity string representation
@cindex @samp{-inf.0} negative infinity string representation
@cindex @samp{+nan.0} not--a--number string representation


@value{PACKAGE} implements @cfunc{mmux_*_sprint} functions to convert numbers from a binary
representation to the corresponding @asciiz{} string representation.  For floating--point numbers
the following facilities are implemented to select the string format.

To select an output format for the result of the @cfunc{mmux_flonumdb_sprint} function, we do:

@example
char const * fmt = "%.4f";

if (mmux_flonumdb_set_output_format(fmt, __func__)) @{
  /* error: invalid format */
@}

/* call "mmux_flonumdb_sprint()" */
@end example

To save the current format and restore it later we do:

@example
char saved_fmt[MMUX_CC_TYPES_FLOAT_FORMAT_MAXLEN];

mmux_flonumdb_save_output_format(saved_fmt);
@{
  char const * fmt = "%.4f";

  if (mmux_flonumdb_set_output_format(fmt, __func__)) @{
    /* error: invalid format */
  @}
  /* call "mmux_flonumdb_sprint()" */
@}
mmux_flonumdb_set_output_format(saved_fmt, __func__);
@end example

String representations of complex floating--point numbers are composed using the format selected for
the corresponding real floating--point type.

For all the following functions:

@itemize
@item
If the format string @var{OUTPUT_FORMAT} is valid: it is duplicated into an internal library state
and the setter function returns @cfalse{}; otherwise nothing happens and the setter function returns
@ctrue{}.

@item
The string referenced by the pointer returned by the getter functions must not be mutated.

@item
The format--saving functions expect the destination buffer to be capable of holding a
@code{MMUX_CC_TYPES_FLOAT_FORMAT_MAXLEN} characters, nul--termination character included.
@end itemize

Notice that the following special string representations are adopted:

@table @code
@item +inf.0
@itemx -inf.0
positive and negative infinities;

@item +nan.0
not--a--number;
@end table

@noindent
with these representations: if the first character of a token is a digit or a plus or a minus: the
token is a number.


@defvr {C Preprocessor Symbol} MMUX_CC_TYPES_FLOAT_FORMAT_MAXLEN
The number of bytes required to hold a format specification string, @strong{including} the
terminating nul character.
@end defvr

@c ------------------------------------------------------------------------

@macro MmuxRealSelectOutputFormatFunction{STEM,DEFAULTFORMAT}
@deftypefun bool mmux_\STEM\_set_output_format (char const * @var{OUTPUT_FORMAT}, char const * @var{CALLER_NAME})
@deftypefunx {char const *} mmux_\STEM\_ref_output_format (void)
@deftypefunx void mmux_\STEM\_save_output_format (char * @var{DEST})
Select, retrieve or save the current format for string representations of floating--point numbers of
type @objtype{\STEM\}.  The default format is @samp{\DEFAULTFORMAT\}.

If the argument @var{CALLER_NAME} is not @cnull{}: when an error occurs an error message is
displayed on @stderr{} using @var{CALLER_NAME} as source of the message itself; it is meant to be
the expansion of the preprocessor macro @code{__func__} or something similar.
@end deftypefun

@end macro

@MmuxRealSelectOutputFormatFunction{flonumfl, %A}
@MmuxRealSelectOutputFormatFunction{flonumdb, %A}
@MmuxRealSelectOutputFormatFunction{flonumldb, %A}

@MmuxRealSelectOutputFormatFunction{flonumf32, %A}
@MmuxRealSelectOutputFormatFunction{flonumf64, %A}
@MmuxRealSelectOutputFormatFunction{flonumf128, %A}

@MmuxRealSelectOutputFormatFunction{flonumf32x, %A}
@MmuxRealSelectOutputFormatFunction{flonumf64x, %A}
@MmuxRealSelectOutputFormatFunction{flonumf128x, %A}

@MmuxRealSelectOutputFormatFunction{flonumd32, %f}
@MmuxRealSelectOutputFormatFunction{flonumd64, %f}
@MmuxRealSelectOutputFormatFunction{flonumd128, %f}

@c page
@node stringrep parsers
@section Parsing string representations of C language types


Type parsers convert string representations to C language values; to parse a @objtype{mmux_sint_t}
representation we do:

@example
mmux_asciizc_t  arg = "123";
mmux_sint_t     value;
bool            rv;

rv = mmux_sint_parse(&value, arg, __func__);
@end example


@macro MmuxDefineCFunctionParser{STEM}
@deftypefun bool mmux_\STEM\_parse (mmux_\STEM\_t * @var{PTR}, mmux_asciizcp_t @var{STR}, mmux_asciizcp_t @var{WHO})
Parse a string which is meant to be the representation of a C language type @objtype{\STEM\}; when
successful store the result in the variable referenced by @var{PTR}, then return @cfalse{};
otherwise leave @var{PTR} untouched and return @ctrue{}.

In case of failure: if @var{WHO} is not @cnull{}, print on @stderr{} a message describing the
parsing error; @var{WHO} must reference an @asciiz{} string representing the entity that requested
the parsing operation, for example: the name of a C function.
@end deftypefun

@end macro


@MmuxDefineCFunctionParser{pointer}

@MmuxDefineCFunctionParser{char}
@MmuxDefineCFunctionParser{schar}
@MmuxDefineCFunctionParser{uchar}
@MmuxDefineCFunctionParser{sshort}
@MmuxDefineCFunctionParser{ushort}
@MmuxDefineCFunctionParser{sint}
@MmuxDefineCFunctionParser{uint}
@MmuxDefineCFunctionParser{slong}
@MmuxDefineCFunctionParser{ulong}
@MmuxDefineCFunctionParser{sllong}
@MmuxDefineCFunctionParser{ullong}
@MmuxDefineCFunctionParser{flonumfl}
@MmuxDefineCFunctionParser{flonumdb}
@MmuxDefineCFunctionParser{flonumldb}

@MmuxDefineCFunctionParser{flonumf32}
@MmuxDefineCFunctionParser{flonumf64}
@MmuxDefineCFunctionParser{flonumf128}

@MmuxDefineCFunctionParser{flonumf32x}
@MmuxDefineCFunctionParser{flonumf64x}
@MmuxDefineCFunctionParser{flonumf128x}

@MmuxDefineCFunctionParser{flonumd32}
@MmuxDefineCFunctionParser{flonumd64}
@MmuxDefineCFunctionParser{flonumd128}

@MmuxDefineCFunctionParser{flonumcfl}
@MmuxDefineCFunctionParser{flonumcdb}
@MmuxDefineCFunctionParser{flonumcldb}

@MmuxDefineCFunctionParser{flonumcf32}
@MmuxDefineCFunctionParser{flonumcf64}
@MmuxDefineCFunctionParser{flonumcf128}

@MmuxDefineCFunctionParser{flonumcf32x}
@MmuxDefineCFunctionParser{flonumcf64x}
@MmuxDefineCFunctionParser{flonumcf128x}

@MmuxDefineCFunctionParser{flonumcd32}
@MmuxDefineCFunctionParser{flonumcd64}
@MmuxDefineCFunctionParser{flonumcd128}

@MmuxDefineCFunctionParser{sint8}
@MmuxDefineCFunctionParser{uint8}
@MmuxDefineCFunctionParser{sint16}
@MmuxDefineCFunctionParser{uint16}
@MmuxDefineCFunctionParser{sint32}
@MmuxDefineCFunctionParser{uint32}
@MmuxDefineCFunctionParser{sint64}
@MmuxDefineCFunctionParser{uint64}

@MmuxDefineCFunctionParser{byte}
@MmuxDefineCFunctionParser{octet}

@MmuxDefineCFunctionParser{ssize}
@MmuxDefineCFunctionParser{usize}
@MmuxDefineCFunctionParser{sintmax}
@MmuxDefineCFunctionParser{uintmax}
@MmuxDefineCFunctionParser{sintptr}
@MmuxDefineCFunctionParser{uintptr}
@MmuxDefineCFunctionParser{ptrdiff}
@MmuxDefineCFunctionParser{mode}
@MmuxDefineCFunctionParser{off}
@MmuxDefineCFunctionParser{pid}
@MmuxDefineCFunctionParser{uid}
@MmuxDefineCFunctionParser{gid}
@MmuxDefineCFunctionParser{wchar}
@MmuxDefineCFunctionParser{wint}
@MmuxDefineCFunctionParser{time}
@MmuxDefineCFunctionParser{socklen}
@MmuxDefineCFunctionParser{rlim}
@MmuxDefineCFunctionParser{ino}
@MmuxDefineCFunctionParser{dev}
@MmuxDefineCFunctionParser{nlink}
@MmuxDefineCFunctionParser{blkcnt}

@c page
@node stringrep sprinters
@section Printing string representations of C language types


@menu
* stringrep sprinters general::         General string representations.
* stringrep sprinters integers::        Exact integer string representations.
* stringrep sprinters printing::        Printing string representations.
@end menu

@c page
@node stringrep sprinters general
@subsection General string representations


Type string printers convert binary representations of C language values to string representations;
to construct a @objtype{mmux_flonumdb_t} string representation we do:

@example
mmux_flonumdb_t  value = mmux_flonumdb_literal(0.123);
mmux_usize_t     required_nbytes;

if (mmux_flonumdb_sprint_size(&required_nbytes, value)) @{
  /* error */
@} else @{
  char    str[required_nbytes.value];

  if (mmux_flonumdb_sprint(str, required_nbytes, value)) @{
    /* error */
  @}
@}
@end example

@noindent
or more generically:

@example
auto            value = mmux_flonumdb_literal(0.123);
mmux_usize_t    required_nbytes;

if (mmux_flonumdb_sprint_size(&required_nbytes, value)) @{
  /* error */
@} else @{
  char    str[required_nbytes.value];

  if (mmux_ctype_sprint(str, required_nbytes, value)) @{
    /* error */
  @}
@}
@end example

@c ------------------------------------------------------------------------

@macro MmuxDefineCFunctionSprinter{STEM}
@deftypefun bool mmux_\STEM\_sprint (mmux_asciizp_t @var{STRPTR}, mmux_usize_t @var{LEN}, mmux_\STEM\_t @var{VALUE})
@deftypefunx bool mmux_\STEM\_sprint_size (mmux_usize_t * @var{result_required_nbytes_p}, mmux_\STEM\_t @var{VALUE})
The @samp{sprint} function generates a string representation of @var{VALUE} and stores it, in
@asciiz{} format, in the string referenced by @var{STRPTR}, which can hold at most @var{LEN}
characters (terminating zero included).  When successful return @cfalse{}; otherwise leave
@var{STRPTR} untouched and return @ctrue{}.

The @samp{sprint_size} function computes how many characters are needed to hold the string
representation of @var{VALUE}.  When successful: it stores the number of characters,
@strong{including the terminating zero}, in the variable referenced by
@var{result_required_nbytes_p} then it returns @cfalse{}; otherwise it returns @ctrue{}.
@end deftypefun

@end macro

@c ------------------------------------------------------------------------

@deftypefn {Generic Macro} bool mmux_ctype_sprint (mmux_asciizp_t @var{STRPTR}, mmux_usize_t @var{LEN}, mmux_ctype_t @var{VALUE})
@deftypefnx {Generic Macro} bool mmux_ctype_sprint_size (mmux_usize_t @var{result_required_nbytes_p}, mmux_ctype_t @var{VALUE})
Generic macros.  The type @objtype{mmux_ctype_t} is a placeholder for the type of the operand.
@end deftypefn


@MmuxDefineCFunctionSprinter{pointer}

@MmuxDefineCFunctionSprinter{char}
@MmuxDefineCFunctionSprinter{schar}
@MmuxDefineCFunctionSprinter{uchar}
@MmuxDefineCFunctionSprinter{sshort}
@MmuxDefineCFunctionSprinter{ushort}
@MmuxDefineCFunctionSprinter{sint}
@MmuxDefineCFunctionSprinter{uint}
@MmuxDefineCFunctionSprinter{slong}
@MmuxDefineCFunctionSprinter{ulong}
@MmuxDefineCFunctionSprinter{sllong}
@MmuxDefineCFunctionSprinter{ullong}
@MmuxDefineCFunctionSprinter{sint8}
@MmuxDefineCFunctionSprinter{uint8}
@MmuxDefineCFunctionSprinter{sint16}
@MmuxDefineCFunctionSprinter{uint16}
@MmuxDefineCFunctionSprinter{sint32}
@MmuxDefineCFunctionSprinter{uint32}
@MmuxDefineCFunctionSprinter{sint64}
@MmuxDefineCFunctionSprinter{uint64}

@MmuxDefineCFunctionSprinter{ssize}
@MmuxDefineCFunctionSprinter{usize}
@MmuxDefineCFunctionSprinter{sintmax}
@MmuxDefineCFunctionSprinter{uintmax}
@MmuxDefineCFunctionSprinter{sintptr}
@MmuxDefineCFunctionSprinter{uintptr}
@MmuxDefineCFunctionSprinter{ptrdiff}
@MmuxDefineCFunctionSprinter{mode}
@MmuxDefineCFunctionSprinter{off}
@MmuxDefineCFunctionSprinter{pid}
@MmuxDefineCFunctionSprinter{uid}
@MmuxDefineCFunctionSprinter{gid}
@MmuxDefineCFunctionSprinter{wchar}
@MmuxDefineCFunctionSprinter{wint}
@MmuxDefineCFunctionSprinter{time}
@MmuxDefineCFunctionSprinter{socklen}
@MmuxDefineCFunctionSprinter{rlim}
@MmuxDefineCFunctionSprinter{ino}
@MmuxDefineCFunctionSprinter{dev}
@MmuxDefineCFunctionSprinter{nlink}
@MmuxDefineCFunctionSprinter{blkcnt}

@MmuxDefineCFunctionSprinter{flonumfl}
@MmuxDefineCFunctionSprinter{flonumdb}
@MmuxDefineCFunctionSprinter{flonumldb}

@MmuxDefineCFunctionSprinter{flonumf32}
@MmuxDefineCFunctionSprinter{flonumf64}
@MmuxDefineCFunctionSprinter{flonumf128}

@MmuxDefineCFunctionSprinter{flonumf32x}
@MmuxDefineCFunctionSprinter{flonumf64x}
@MmuxDefineCFunctionSprinter{flonumf128x}

@MmuxDefineCFunctionSprinter{flonumd32}
@MmuxDefineCFunctionSprinter{flonumd64}
@MmuxDefineCFunctionSprinter{flonumd128}

@MmuxDefineCFunctionSprinter{flonumcfl}
@MmuxDefineCFunctionSprinter{flonumcdb}
@MmuxDefineCFunctionSprinter{flonumcldb}

@MmuxDefineCFunctionSprinter{flonumcf32}
@MmuxDefineCFunctionSprinter{flonumcf64}
@MmuxDefineCFunctionSprinter{flonumcf128}

@MmuxDefineCFunctionSprinter{flonumcf32x}
@MmuxDefineCFunctionSprinter{flonumcf64x}
@MmuxDefineCFunctionSprinter{flonumcf128x}

@MmuxDefineCFunctionSprinter{flonumcd32}
@MmuxDefineCFunctionSprinter{flonumcd64}
@MmuxDefineCFunctionSprinter{flonumcd128}

@c page
@node stringrep sprinters integers
@subsection Exact integer string representations


The following functions @cfunc{mmux_*_sprint_with_base} generate a string representation of the
exact integer @var{VALUE} and store it, in @mmuxascii{} format, in the string referenced by
@var{BUFPTR}.  When successful return @cfalse{}; otherwise leave @var{BUFPTR} untouched and return
@ctrue{}.

The following functions @cfunc{mmux_*_dprintf_with_base} generate a string representation of the
exact integer @var{VALUE} and write it to the file descriptor @var{FD}.  When successful return
@cfalse{}; otherwise return @ctrue{}.

Behavioural notes for the functions @cfunc{mmux_*_sprint_with_base}:

@itemize
@item
The generated string @strong{does not} include a terminating zero character.

@item
If there is not enough room in the buffer referenced by @var{BUFPTR} to contain the generated
string: the buffer is left untouched and the return value is @ctrue{}.

@item
Regarding the argument @var{BUFLEN_P}:

@itemize -
@item
upon entering a function call: it must reference a variable representing the maximum number of
characters that can be stored in the buffer referenced by @var{BUFPTR};

@item
upon successfully returning from a function call: it is set to the number of characters stored in
the buffer referenced by by @var{BUFPTR};

@item
upon returning with failure from a function call: it is left untouched.
@end itemize

@item
If the exact integer is negative: the variable referenced by @var{IS_NEGATIVE_P} is set to @ctrue{};
otherwise it is set to @cfalse{}.  The generated string @strong{does not} include a sign character.

@item
The @var{base} argument represents the base of the string representation; it can be between @samp{2}
included and @samp{62} included.

@item
The longest generated string happens when the base is @samp{2} and it is @samp{64} characters long.

@item
Internally all the exact integers are converted to @objtype{mmux_sint64_t} or
@objtype{mmux_uint64_t}, then the conversion is performed.

@item
No padding is performed for the generated string.
@end itemize

The cipher to output character map is:

@example
0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz
@end example

@noindent
and it has 62 characters.  It is similar to the mapping used by the @gnu{} Multiple Precision
library, @xref{I/O of Integers, Input and Output Functions, Input and Output Functions, gmp}.

Some usage examples:

@example
#define DOIT(LITERAL, BASE) \
  mmux_ctype_dprintf_with_base(2, \
    mmux_sint64_literal(LITERAL), \
    mmux_uint_literal(BASE))

DOIT(+123,       2);    @print{} +1111011
DOIT(+123,      10);    @print{} +123
DOIT(+1234,     10);    @print{} +1234
DOIT(-1234,     10);    @print{} -1234
DOIT(+123,      16);    @print{} +7B
DOIT(-123,      16);    @print{} -7B

DOIT(10,        11);    @print{} +A
DOIT(20,        21);    @print{} +K
DOIT(30,        31);    @print{} +U
DOIT(40,        41);    @print{} +e
DOIT(50,        51);    @print{} +o
DOIT(60,        61);    @print{} +y
DOIT(61,        62);    @print{} +z
@end example

@c ------------------------------------------------------------------------

@macro MmuxDefineCFunctionExactIntegerSprinter{STEM}
@deftypefun bool mmux_\STEM\_sprint_with_base (mmux_asciizp_t @var{BUFPTR}, mmux_usize_t * @var{BUFLEN_P}, bool * @var{IS_NEGATIVE_P}, mmux_\STEM\_t @var{VALUE})
@deftypefunx bool mmux_\STEM\_dprintf_with_base (int @var{FD}, mmux_\STEM\_t @var{VALUE}, mmux_uint_t @var{BASE})
Generate or print a string representation of the exact integer @var{VALUE}.
@end deftypefun

@end macro

@c ------------------------------------------------------------------------

@deftypefn {Generic Macro} bool mmux_ctype_sprint_with_base (mmux_asciizp_t @var{BUFPTR}, mmux_usize_t * @var{BUFLEN_P}, bool * @var{IS_NEGATIVE_P}, mmux_ctype_t @var{VALUE})
@deftypefnx {Generic Macro} bool mmux_ctype_dprintf_with_base (int @var{FD}, mmux_ctype_t @var{VALUE}, mmux_uint_t @var{BASE})
Generic macros.  Generate or print a string representation of the exact integer @var{VALUE}.  The
type @objtype{mmux_ctype_t} is a placeholder for the type of the operand.
@end deftypefn

@c ------------------------------------------------------------------------

@MmuxDefineCFunctionExactIntegerSprinter{pointer}

@MmuxDefineCFunctionExactIntegerSprinter{char}
@MmuxDefineCFunctionExactIntegerSprinter{schar}
@MmuxDefineCFunctionExactIntegerSprinter{uchar}
@MmuxDefineCFunctionExactIntegerSprinter{sshort}
@MmuxDefineCFunctionExactIntegerSprinter{ushort}
@MmuxDefineCFunctionExactIntegerSprinter{sint}
@MmuxDefineCFunctionExactIntegerSprinter{uint}
@MmuxDefineCFunctionExactIntegerSprinter{slong}
@MmuxDefineCFunctionExactIntegerSprinter{ulong}
@MmuxDefineCFunctionExactIntegerSprinter{sllong}
@MmuxDefineCFunctionExactIntegerSprinter{ullong}

@MmuxDefineCFunctionExactIntegerSprinter{sint8}
@MmuxDefineCFunctionExactIntegerSprinter{uint8}
@MmuxDefineCFunctionExactIntegerSprinter{sint16}
@MmuxDefineCFunctionExactIntegerSprinter{uint16}
@MmuxDefineCFunctionExactIntegerSprinter{sint32}
@MmuxDefineCFunctionExactIntegerSprinter{uint32}
@MmuxDefineCFunctionExactIntegerSprinter{sint64}
@MmuxDefineCFunctionExactIntegerSprinter{uint64}

@MmuxDefineCFunctionExactIntegerSprinter{ssize}
@MmuxDefineCFunctionExactIntegerSprinter{usize}
@MmuxDefineCFunctionExactIntegerSprinter{sintmax}
@MmuxDefineCFunctionExactIntegerSprinter{uintmax}
@MmuxDefineCFunctionExactIntegerSprinter{sintptr}
@MmuxDefineCFunctionExactIntegerSprinter{uintptr}
@MmuxDefineCFunctionExactIntegerSprinter{ptrdiff}
@MmuxDefineCFunctionExactIntegerSprinter{mode}
@MmuxDefineCFunctionExactIntegerSprinter{off}
@MmuxDefineCFunctionExactIntegerSprinter{pid}
@MmuxDefineCFunctionExactIntegerSprinter{uid}
@MmuxDefineCFunctionExactIntegerSprinter{gid}
@MmuxDefineCFunctionExactIntegerSprinter{wchar}
@MmuxDefineCFunctionExactIntegerSprinter{wint}
@MmuxDefineCFunctionExactIntegerSprinter{time}
@MmuxDefineCFunctionExactIntegerSprinter{socklen}
@MmuxDefineCFunctionExactIntegerSprinter{rlim}
@MmuxDefineCFunctionExactIntegerSprinter{ino}
@MmuxDefineCFunctionExactIntegerSprinter{dev}
@MmuxDefineCFunctionExactIntegerSprinter{nlink}
@MmuxDefineCFunctionExactIntegerSprinter{blkcnt}

@c page
@node stringrep sprinters printing
@subsection Printing string representations


To print a value to @stderr{}, we can do:

@example
mmux_flonumdb_t  X = mmux_flonumdb_literal(1.2);

if (mmux_flonumdb_dprintf(2, X)) @{
  /* error */
@}

if (mmux_flonumdb_fprintf(stderr, X)) @{
  /* error */
@}
@end example

@noindent
or more generically:

@example
auto  X = mmux_flonumdb_literal(1.2);

if (mmux_ctype_dprintf(2, X)) @{
  /* error */
@}

if (mmux_ctype_fprintf(stderr, X)) @{
  /* error */
@}
@end example

@c ------------------------------------------------------------------------

@macro MmuxDefineCFunctionPrinters{STEM}
@deftypefun bool mmux_\STEM\_dprintf (int @var{fd}, mmux_\STEM\_t @var{value})
@deftypefunx bool mmux_\STEM\_fprintf (mmux_pointer_t @var{stream}, mmux_\STEM\_t @var{value})
Print a string representation of @var{value} to the given file descriptor @var{fd} or stream
@var{stream}.  When successful return @cfalse{}, otherwise return @ctrue{}.
@end deftypefun

@end macro

@c ------------------------------------------------------------------------


@deftypefn {Generic macro} bool mmux_ctype_dprintf (int @var{fd}, mmux_ctype_t @var{value})
@deftypefnx {Generic macro} bool mmux_ctype_fprintf (mmux_pointer_t @var{stream}, mmux_ctype_t @var{value})
Generic macros.  The type @objtype{mmux_ctype_t} is a placeholder for the type of the operand.
@end deftypefn


@MmuxDefineCFunctionPrinters{pointer}

@MmuxDefineCFunctionPrinters{char}
@MmuxDefineCFunctionPrinters{schar}
@MmuxDefineCFunctionPrinters{uchar}
@MmuxDefineCFunctionPrinters{sshort}
@MmuxDefineCFunctionPrinters{ushort}
@MmuxDefineCFunctionPrinters{sint}
@MmuxDefineCFunctionPrinters{uint}
@MmuxDefineCFunctionPrinters{slong}
@MmuxDefineCFunctionPrinters{ulong}
@MmuxDefineCFunctionPrinters{sllong}
@MmuxDefineCFunctionPrinters{ullong}
@MmuxDefineCFunctionPrinters{sint8}
@MmuxDefineCFunctionPrinters{uint8}
@MmuxDefineCFunctionPrinters{sint16}
@MmuxDefineCFunctionPrinters{uint16}
@MmuxDefineCFunctionPrinters{sint32}
@MmuxDefineCFunctionPrinters{uint32}
@MmuxDefineCFunctionPrinters{sint64}
@MmuxDefineCFunctionPrinters{uint64}

@MmuxDefineCFunctionPrinters{byte}
@MmuxDefineCFunctionPrinters{octet}

@MmuxDefineCFunctionPrinters{ssize}
@MmuxDefineCFunctionPrinters{usize}
@MmuxDefineCFunctionPrinters{sintmax}
@MmuxDefineCFunctionPrinters{uintmax}
@MmuxDefineCFunctionPrinters{sintptr}
@MmuxDefineCFunctionPrinters{uintptr}
@MmuxDefineCFunctionPrinters{ptrdiff}
@MmuxDefineCFunctionPrinters{mode}
@MmuxDefineCFunctionPrinters{off}
@MmuxDefineCFunctionPrinters{pid}
@MmuxDefineCFunctionPrinters{uid}
@MmuxDefineCFunctionPrinters{gid}
@MmuxDefineCFunctionPrinters{wchar}
@MmuxDefineCFunctionPrinters{wint}
@MmuxDefineCFunctionPrinters{time}
@MmuxDefineCFunctionPrinters{socklen}
@MmuxDefineCFunctionPrinters{rlim}
@MmuxDefineCFunctionPrinters{ino}
@MmuxDefineCFunctionPrinters{dev}
@MmuxDefineCFunctionPrinters{nlink}
@MmuxDefineCFunctionPrinters{blkcnt}

@MmuxDefineCFunctionPrinters{flonumfl}
@MmuxDefineCFunctionPrinters{flonumdb}
@MmuxDefineCFunctionPrinters{flonumldb}

@MmuxDefineCFunctionPrinters{flonumf32}
@MmuxDefineCFunctionPrinters{flonumf64}
@MmuxDefineCFunctionPrinters{flonumf128}

@MmuxDefineCFunctionPrinters{flonumf32x}
@MmuxDefineCFunctionPrinters{flonumf64x}
@MmuxDefineCFunctionPrinters{flonumf128x}

@MmuxDefineCFunctionPrinters{flonumd32}
@MmuxDefineCFunctionPrinters{flonumd64}
@MmuxDefineCFunctionPrinters{flonumd128}

@MmuxDefineCFunctionPrinters{flonumcfl}
@MmuxDefineCFunctionPrinters{flonumcdb}
@MmuxDefineCFunctionPrinters{flonumcldb}

@MmuxDefineCFunctionPrinters{flonumcf32}
@MmuxDefineCFunctionPrinters{flonumcf64}
@MmuxDefineCFunctionPrinters{flonumcf128}

@MmuxDefineCFunctionPrinters{flonumcf32x}
@MmuxDefineCFunctionPrinters{flonumcf64x}
@MmuxDefineCFunctionPrinters{flonumcf128x}

@MmuxDefineCFunctionPrinters{flonumcd32}
@MmuxDefineCFunctionPrinters{flonumcd64}
@MmuxDefineCFunctionPrinters{flonumcd128}

@c page
@node real
@chapter Basic real numbers operations


@menu
* real sign::                   Sign of floating-point numbers.
* real rounding::               Rounding floating-point numbers.
* real exact rounding::         Rounding floating-point numbers to exact integers.
* real splitting::              Splitting floating-point numbers.
@end menu

@c page
@node real sign
@section Sign of floating--point numbers


To determine the sign of a number we do:

@example
mmux_flonumf128_t  A = mmux_flonumf128_literal(0.123);
mmux_flonumf128_t  S = mmux_flonumf128_sign(A);

mmux_flonumf128_dprintf(2, S);  @print{} 1.0
@end example

@noindent
or more generically:

@example
auto  A = mmux_flonumf128_literal(0.123);
auto  S = mmux_ctype_sign(A);

mmux_ctype_dprintf(2, S);       @print{} 1.0
@end example

Notes on operations:

@itemize
@item
The @code{sign} function returns @samp{+1}, @samp{-1}, @samp{0} depending on the sign of its
operand; for @code{flonum} operands the result is always @samp{+1.0} or @samp{-1.0} because
@code{flonum} zero has a sign; for @code{flonumc} operands the result is a complex number whose real
and imaginary parts represent the signs of the real and imaginary parts of the operand.
@end itemize

@c ------------------------------------------------------------------------

@macro MmuxDefineExactIntegerSignFunctions{STEM}
@deftypefun mmux_\STEM\_t mmux_\STEM\_sign (mmux_\STEM\_t @var{OP})
Compute the sign of the operand.
@end deftypefun

@end macro

@c ------------------------------------------------------------------------

@macro MmuxDefineRealFlonumSignFunctions{STEM}
@deftypefun mmux_\STEM\_t mmux_\STEM\_sign (mmux_\STEM\_t @var{OP})
Compute the sign of the operand.
@end deftypefun

@end macro

@c ------------------------------------------------------------------------

@macro MmuxDefineCplxFlonumSignFunctions{STEM}
@deftypefun mmux_\STEM\_t mmux_\STEM\_sign (mmux_\STEM\_t @var{OP})
Compute the sign of the operand.
@end deftypefun

@end macro

@c ------------------------------------------------------------------------

@deftypefn {Generic Macro} mmux_ctype_t mmux_ctype_sign (mmux_ctype_t @var{OP})
Compute the sign of the operand.  The type @objtype{mmux_ctype_t} is a placeholder for the type of
the operands and result.
@end deftypefn

@c ------------------------------------------------------------------------

@MmuxDefineExactIntegerSignFunctions{char}
@MmuxDefineExactIntegerSignFunctions{schar}
@MmuxDefineExactIntegerSignFunctions{uchar}
@MmuxDefineExactIntegerSignFunctions{sshort}
@MmuxDefineExactIntegerSignFunctions{ushort}
@MmuxDefineExactIntegerSignFunctions{sint}
@MmuxDefineExactIntegerSignFunctions{uint}
@MmuxDefineExactIntegerSignFunctions{slong}
@MmuxDefineExactIntegerSignFunctions{ulong}
@MmuxDefineExactIntegerSignFunctions{sllong}
@MmuxDefineExactIntegerSignFunctions{ullong}
@MmuxDefineExactIntegerSignFunctions{sint8}
@MmuxDefineExactIntegerSignFunctions{uint8}
@MmuxDefineExactIntegerSignFunctions{sint16}
@MmuxDefineExactIntegerSignFunctions{uint16}
@MmuxDefineExactIntegerSignFunctions{sint32}
@MmuxDefineExactIntegerSignFunctions{uint32}
@MmuxDefineExactIntegerSignFunctions{sint64}
@MmuxDefineExactIntegerSignFunctions{uint64}

@MmuxDefineExactIntegerSignFunctions{byte}
@MmuxDefineExactIntegerSignFunctions{octet}

@MmuxDefineExactIntegerSignFunctions{ssize}
@MmuxDefineExactIntegerSignFunctions{usize}
@MmuxDefineExactIntegerSignFunctions{sintmax}
@MmuxDefineExactIntegerSignFunctions{uintmax}
@MmuxDefineExactIntegerSignFunctions{sintptr}
@MmuxDefineExactIntegerSignFunctions{uintptr}
@MmuxDefineExactIntegerSignFunctions{ptrdiff}
@MmuxDefineExactIntegerSignFunctions{off}
@MmuxDefineExactIntegerSignFunctions{wchar}
@MmuxDefineExactIntegerSignFunctions{wint}
@MmuxDefineExactIntegerSignFunctions{time}

@MmuxDefineRealFlonumSignFunctions{flonumfl}
@MmuxDefineRealFlonumSignFunctions{flonumdb}
@MmuxDefineRealFlonumSignFunctions{flonumldb}

@MmuxDefineRealFlonumSignFunctions{flonumf32}
@MmuxDefineRealFlonumSignFunctions{flonumf64}
@MmuxDefineRealFlonumSignFunctions{flonumf128}

@MmuxDefineRealFlonumSignFunctions{flonumf32x}
@MmuxDefineRealFlonumSignFunctions{flonumf64x}
@MmuxDefineRealFlonumSignFunctions{flonumf128x}

@MmuxDefineRealFlonumSignFunctions{flonumd32}
@MmuxDefineRealFlonumSignFunctions{flonumd64}
@MmuxDefineRealFlonumSignFunctions{flonumd128}

@MmuxDefineCplxFlonumSignFunctions{flonumcfl}
@MmuxDefineCplxFlonumSignFunctions{flonumcdb}
@MmuxDefineCplxFlonumSignFunctions{flonumcldb}

@MmuxDefineCplxFlonumSignFunctions{flonumcf32}
@MmuxDefineCplxFlonumSignFunctions{flonumcf64}
@MmuxDefineCplxFlonumSignFunctions{flonumcf128}

@MmuxDefineCplxFlonumSignFunctions{flonumcf32x}
@MmuxDefineCplxFlonumSignFunctions{flonumcf64x}
@MmuxDefineCplxFlonumSignFunctions{flonumcf128x}

@MmuxDefineCplxFlonumSignFunctions{flonumcd32}
@MmuxDefineCplxFlonumSignFunctions{flonumcd64}
@MmuxDefineCplxFlonumSignFunctions{flonumcd128}

@c page
@node real rounding
@section Rounding floating-point numbers


To compute the ceil of a number we do:

@example
mmux_flonumf128_t  A = mmux_flonumf128_literal(0.123);
mmux_flonumf128_t  B = mmux_flonumf128_ceil(A);

mmux_flonumf128_dprintf(2, B);  @print{} 1.0
@end example

@noindent
or more generically:

@example
auto  A = mmux_flonumf128_literal(0.123);
auto  B = mmux_ctype_ceil(A);

mmux_ctype_dprintf(2, B);       @print{} 1.0
@end example

@c ------------------------------------------------------------------------

Notes on operations:

@itemize
@item
When a rounding function is applied to a complex number: the rounding operation is applied to both
the real and imaginary parts.
@end itemize

@c ------------------------------------------------------------------------

@macro MmuxDefineRealFlonumRoundingFunctions{STEM}
@deftypefun mmux_\STEM\_t mmux_\STEM\_ceil (mmux_\STEM\_t @var{OP})
@deftypefunx mmux_\STEM\_t mmux_\STEM\_floor (mmux_\STEM\_t @var{OP})
@deftypefunx mmux_\STEM\_t mmux_\STEM\_trunc (mmux_\STEM\_t @var{OP})
@deftypefunx mmux_\STEM\_t mmux_\STEM\_rint (mmux_\STEM\_t @var{OP})
@deftypefunx mmux_\STEM\_t mmux_\STEM\_nearbyint (mmux_\STEM\_t @var{OP})
@deftypefunx mmux_\STEM\_t mmux_\STEM\_round (mmux_\STEM\_t @var{OP})
@deftypefunx mmux_\STEM\_t mmux_\STEM\_roundeven (mmux_\STEM\_t @var{OP})
Compute the rounded result of the operand.
@end deftypefun

@end macro

@c ------------------------------------------------------------------------

@macro MmuxDefineCplxFlonumRoundingFunctions{STEM}
@deftypefun mmux_\STEM\_t mmux_\STEM\_ceil (mmux_\STEM\_t @var{OP})
@deftypefunx mmux_\STEM\_t mmux_\STEM\_floor (mmux_\STEM\_t @var{OP})
@deftypefunx mmux_\STEM\_t mmux_\STEM\_trunc (mmux_\STEM\_t @var{OP})
@deftypefunx mmux_\STEM\_t mmux_\STEM\_rint (mmux_\STEM\_t @var{OP})
@deftypefunx mmux_\STEM\_t mmux_\STEM\_nearbyint (mmux_\STEM\_t @var{OP})
@deftypefunx mmux_\STEM\_t mmux_\STEM\_round (mmux_\STEM\_t @var{OP})
@deftypefunx mmux_\STEM\_t mmux_\STEM\_roundeven (mmux_\STEM\_t @var{OP})
Compute the rounded result of the operand.
@end deftypefun

@end macro

@c ------------------------------------------------------------------------

@deftypefn {Generic Macro} mmux_ctype_t mmux_ctype_ceil (mmux_ctype_t @var{OP})
@deftypefnx {Generic Macro} mmux_ctype_t mmux_ctype_floor (mmux_ctype_t @var{OP})
@deftypefnx {Generic Macro} mmux_ctype_t mmux_ctype_trunc (mmux_ctype_t @var{OP})
@deftypefnx {Generic Macro} mmux_ctype_t mmux_ctype_rint (mmux_ctype_t @var{OP})
@deftypefnx {Generic Macro} mmux_ctype_t mmux_ctype_nearbyint (mmux_ctype_t @var{OP})
@deftypefnx {Generic Macro} mmux_ctype_t mmux_ctype_round (mmux_ctype_t @var{OP})
@deftypefnx {Generic Macro} mmux_ctype_t mmux_ctype_roundeven (mmux_ctype_t @var{OP})
Compute the rounded result of the operand.  The type @objtype{mmux_ctype_t} is a placeholder for the
type of the operands and result.
@end deftypefn

@c ------------------------------------------------------------------------

@MmuxDefineRealFlonumRoundingFunctions{flonumfl}
@MmuxDefineRealFlonumRoundingFunctions{flonumdb}
@MmuxDefineRealFlonumRoundingFunctions{flonumldb}

@MmuxDefineRealFlonumRoundingFunctions{flonumf32}
@MmuxDefineRealFlonumRoundingFunctions{flonumf64}
@MmuxDefineRealFlonumRoundingFunctions{flonumf128}

@MmuxDefineRealFlonumRoundingFunctions{flonumf32x}
@MmuxDefineRealFlonumRoundingFunctions{flonumf64x}
@MmuxDefineRealFlonumRoundingFunctions{flonumf128x}

@MmuxDefineRealFlonumRoundingFunctions{flonumd32}
@MmuxDefineRealFlonumRoundingFunctions{flonumd64}
@MmuxDefineRealFlonumRoundingFunctions{flonumd128}

@MmuxDefineCplxFlonumRoundingFunctions{flonumcfl}
@MmuxDefineCplxFlonumRoundingFunctions{flonumcdb}
@MmuxDefineCplxFlonumRoundingFunctions{flonumcldb}

@MmuxDefineCplxFlonumRoundingFunctions{flonumcf32}
@MmuxDefineCplxFlonumRoundingFunctions{flonumcf64}
@MmuxDefineCplxFlonumRoundingFunctions{flonumcf128}

@MmuxDefineCplxFlonumRoundingFunctions{flonumcf32x}
@MmuxDefineCplxFlonumRoundingFunctions{flonumcf64x}
@MmuxDefineCplxFlonumRoundingFunctions{flonumcf128x}

@MmuxDefineCplxFlonumRoundingFunctions{flonumcd32}
@MmuxDefineCplxFlonumRoundingFunctions{flonumcd64}
@MmuxDefineCplxFlonumRoundingFunctions{flonumcd128}

@c page
@node real exact rounding
@section Rounding floating--point numbers to exact integers


To round to an exact integer a floating--point number we do:

@example
mmux_flonumf128_t A = mmux_flonumf128_literal(123.456);
mmux_slong_t      B = mmux_flonumf128_lrint(A);

mmux_slong_dprintf(2, B);       @print{} 123
@end example

@noindent
or more generically:

@example
auto      A = mmux_flonumf128_literal(123.456);
auto      B = mmux_ctype_lrint(A);

mmux_ctype_dprintf(2, B);       @print{} 123
@end example

@c ------------------------------------------------------------------------

@macro MmuxDefineRealFlonumRoundingToExactFunctions{STEM}
@deftypefun mmux_slong_t mmux_\STEM\_lrint (mmux_\STEM\_t @var{OP})
@deftypefunx mmux_slong_t mmux_\STEM\_lround (mmux_\STEM\_t @var{OP})
@deftypefunx mmux_sllong_t mmux_\STEM\_llrint (mmux_\STEM\_t @var{OP})
@deftypefunx mmux_sllong_t mmux_\STEM\_llround (mmux_\STEM\_t @var{OP})
Compute the rounded result of the operand.
@end deftypefun

@end macro

@c ------------------------------------------------------------------------

@deftypefn {Generic Macro} mmux_slong_t mmux_ctype_lrint (mmux_ctype_t @var{OP})
@deftypefnx {Generic Macro} mmux_slong_t mmux_ctype_lround (mmux_ctype_t @var{OP})
@deftypefnx {Generic Macro} mmux_sllong_t mmux_ctype_llrint (mmux_ctype_t @var{OP})
@deftypefnx {Generic Macro} mmux_sllong_t mmux_ctype_llround (mmux_ctype_t @var{OP})
Compute the rounded result of the operand.  The type @objtype{mmux_ctype_t} is a placeholder for the
type of the operands.
@end deftypefn

@c ------------------------------------------------------------------------

@MmuxDefineRealFlonumRoundingToExactFunctions{flonumfl}
@MmuxDefineRealFlonumRoundingToExactFunctions{flonumdb}
@MmuxDefineRealFlonumRoundingToExactFunctions{flonumldb}

@MmuxDefineRealFlonumRoundingToExactFunctions{flonumf32}
@MmuxDefineRealFlonumRoundingToExactFunctions{flonumf64}
@MmuxDefineRealFlonumRoundingToExactFunctions{flonumf128}

@MmuxDefineRealFlonumRoundingToExactFunctions{flonumf32x}
@MmuxDefineRealFlonumRoundingToExactFunctions{flonumf64x}
@MmuxDefineRealFlonumRoundingToExactFunctions{flonumf128x}

@MmuxDefineRealFlonumRoundingToExactFunctions{flonumd32}
@MmuxDefineRealFlonumRoundingToExactFunctions{flonumd64}
@MmuxDefineRealFlonumRoundingToExactFunctions{flonumd128}

@c page
@node real splitting
@section Splitting floating--point numbers


@cindex Splitting a floating--point number in integer and fractional parts
@cindex Floating--point numbers, splitting in integer and fractional parts
@cindex Flonums, splitting in integer and fractional parts
@cindex Integer part of a floating--point number
@cindex Fractional part of a floating--point number


To split a floating--point number into integer and fractional parts we do:

@example
mmux_flonumf128_t       A = mmux_flonumf128_literal(123.456);
mmux_flonumf128_t       integer_of_A;
mmux_flonumf128_t       fractional_of_A = mmux_flonumf128_modf(A, &integer_of_A);

mmux_flonumf128_dprintf(2, integer_of_A);       @print{} 123.0
mmux_flonumf128_dprintf(2, fractional_of_A);    @print{} 0.456
@end example

@noindent
or more generically:

@example
auto            A = mmux_flonumf128_literal(123.456);
typeof(A)       integer_of_A;
auto            fractional_of_A = mmux_ctype_modf(A, &integer_of_A);

mmux_ctype_dprintf(2, integer_of_A);            @print{} 123.0
mmux_ctype_dprintf(2, fractional_of_A);         @print{} 0.456
@end example

@c ------------------------------------------------------------------------

@macro MmuxDefineRealFlonumModfFunctions{STEM}
@deftypefun mmux_\STEM\_t mmux_\STEM\_modf (mmux_\STEM\_t @var{OP}, mmux_\STEM\_t * @var{INTEGER_PART_P})
Compute the result from the operand.
@end deftypefun

@end macro

@c ------------------------------------------------------------------------

@deftypefn {Generic Macro} mmux_ctype_t mmux_ctype_modf (mmux_ctype_t @var{OP}, mmux_ctype_t * @var{INTEGER_PART_P})
Compute the result from the operand.  The type @objtype{mmux_ctype_t} is a placeholder for the type
of the operands.
@end deftypefn

@c ------------------------------------------------------------------------

@MmuxDefineRealFlonumModfFunctions{flonumfl}
@MmuxDefineRealFlonumModfFunctions{flonumdb}
@MmuxDefineRealFlonumModfFunctions{flonumldb}

@MmuxDefineRealFlonumModfFunctions{flonumf32}
@MmuxDefineRealFlonumModfFunctions{flonumf64}
@MmuxDefineRealFlonumModfFunctions{flonumf128}

@MmuxDefineRealFlonumModfFunctions{flonumf32x}
@MmuxDefineRealFlonumModfFunctions{flonumf64x}
@MmuxDefineRealFlonumModfFunctions{flonumf128x}

@MmuxDefineRealFlonumModfFunctions{flonumd32}
@MmuxDefineRealFlonumModfFunctions{flonumd64}
@MmuxDefineRealFlonumModfFunctions{flonumd128}

@c page
@node complex
@chapter Basic complex numbers operations


@menu
* complex parts::               Extracting the real and imaginary parts.
* complex argument::            Computing the argument value.
* complex conjugate::           Computing the complex conjugate value.
@end menu

@c page
@node complex parts
@section Extracting the real and imaginary parts


To extract the real and imaginary parts from a complex number we do:

@example
mmux_flonumcf64_t  Z   = mmux_flonumcf64_rectangular_literal(1.2,3.4);
mmux_flonumf64_t   Zre = mmux_flonumcf64_real_part(Z);
mmux_flonumf64_t   Zim = mmux_flonumcf64_imag_part(Z);

mmux_flonumf64_dprintf(2, Zre);         @print{} 1.2
mmux_flonumf64_dprintf(2, Zim);         @print{} 3.4
@end example

@noindent
or more generically:

@example
auto    Z   = mmux_flonumcf64_rectangular_literal(1.2,3.4);
auto    Zre = mmux_ctype_real_part(Z);
auto    Zim = mmux_ctype_imag_part(Z);

mmux_ctype_dprintf(2, Zre);     @print{} 1.2
mmux_ctype_dprintf(2, Zim);     @print{} 3.4
@end example

To extract the real and imaginary parts from a real number we do:

@example
mmux_flonumf64_t   Z   = mmux_flonumf64_literal(0.123);
mmux_flonumf64_t   Zre = mmux_flonumf64_real_part(Z);
mmux_flonumf64_t   Zim = mmux_flonumf64_imag_part(Z);

mmux_flonumf64_dprintf(2, Zre); @print{} 0.123
mmux_flonumf64_dprintf(2, Zim); @print{} 0.0
@end example

@noindent
or more generically:

@example
auto      Z   = mmux_flonumf64_literal(0.123);
auto      Zre = mmux_ctype_real_part(Z);
auto      Zim = mmux_ctype_imag_part(Z);

mmux_ctype_dprintf(2, Zre); @print{} 0.123
mmux_ctype_dprintf(2, Zim); @print{} 0.0
@end example

@c ------------------------------------------------------------------------

@macro MmuxDefineRealRealImagPartFunction{REALSTEM}
@deftypefun  mmux_\REALSTEM\_t mmux_\REALSTEM\_real_part (mmux_\REALSTEM\_t @var{OP})
@deftypefunx mmux_\REALSTEM\_t mmux_\REALSTEM\_imag_part (mmux_\REALSTEM\_t @var{OP})
Extract and return the real or imaginary parts from the real number @var{OP}.  The real part is
@var{OP} itself; the imaginary part is always zero.
@end deftypefun

@end macro

@c ------------------------------------------------------------------------

@macro MmuxDefineComplexRealImagPartFunction{CPLXSTEM,REALSTEM}
@deftypefun  mmux_\REALSTEM\_t mmux_\CPLXSTEM\_real_part (mmux_\CPLXSTEM\_t @var{OP})
@deftypefunx mmux_\REALSTEM\_t mmux_\CPLXSTEM\_imag_part (mmux_\CPLXSTEM\_t @var{OP})
Extract and return the real or imaginary parts from the complex number @var{OP}.
@end deftypefun

@end macro

@c ------------------------------------------------------------------------

@deftypefn {Generic Macro}  mmux_ctype_t mmux_ctype_real_part (mmux_ctype_t @var{OP})
@deftypefnx {Generic Macro} mmux_ctype_t mmux_ctype_imag_part (mmux_ctype_t @var{OP})
Extract and return the real or imaginary parts from the real number @var{OP}.  The real part is
@var{OP} itself; the imaginary part is always zero.  The type @objtype{mmux_ctype_t} is a
placeholder for the type of the operand and result.
@end deftypefn


@MmuxDefineRealRealImagPartFunction{sshort}
@MmuxDefineRealRealImagPartFunction{ushort}
@MmuxDefineRealRealImagPartFunction{sint}
@MmuxDefineRealRealImagPartFunction{uint}
@MmuxDefineRealRealImagPartFunction{slong}
@MmuxDefineRealRealImagPartFunction{ulong}
@MmuxDefineRealRealImagPartFunction{sllong}
@MmuxDefineRealRealImagPartFunction{ullong}

@MmuxDefineRealRealImagPartFunction{sint8}
@MmuxDefineRealRealImagPartFunction{uint8}
@MmuxDefineRealRealImagPartFunction{sint16}
@MmuxDefineRealRealImagPartFunction{uint16}
@MmuxDefineRealRealImagPartFunction{sint32}
@MmuxDefineRealRealImagPartFunction{uint32}
@MmuxDefineRealRealImagPartFunction{sint64}
@MmuxDefineRealRealImagPartFunction{uint64}

@MmuxDefineRealRealImagPartFunction{byte}
@MmuxDefineRealRealImagPartFunction{octet}
@MmuxDefineRealRealImagPartFunction{sintmax}
@MmuxDefineRealRealImagPartFunction{uintmax}
@MmuxDefineRealRealImagPartFunction{sintptr}
@MmuxDefineRealRealImagPartFunction{uintptr}

@MmuxDefineRealRealImagPartFunction{flonumfl}
@MmuxDefineRealRealImagPartFunction{flonumdb}
@MmuxDefineRealRealImagPartFunction{flonumldb}

@MmuxDefineRealRealImagPartFunction{flonumf32}
@MmuxDefineRealRealImagPartFunction{flonumf64}
@MmuxDefineRealRealImagPartFunction{flonumf128}

@MmuxDefineRealRealImagPartFunction{flonumf32x}
@MmuxDefineRealRealImagPartFunction{flonumf64x}
@MmuxDefineRealRealImagPartFunction{flonumf128x}

@MmuxDefineRealRealImagPartFunction{flonumd32}
@MmuxDefineRealRealImagPartFunction{flonumd64}
@MmuxDefineRealRealImagPartFunction{flonumd128}

@c ------------------------------------------------------------------------

@MmuxDefineComplexRealImagPartFunction{flonumcfl, flonumfl}
@MmuxDefineComplexRealImagPartFunction{flonumcdb, flonumdb}
@MmuxDefineComplexRealImagPartFunction{flonumcldb, flonumldb}

@MmuxDefineComplexRealImagPartFunction{flonumcf32, flonumf32}
@MmuxDefineComplexRealImagPartFunction{flonumcf64, flonumf64}
@MmuxDefineComplexRealImagPartFunction{flonumcf128, flonumf128}

@MmuxDefineComplexRealImagPartFunction{flonumcf32x, flonumf32x}
@MmuxDefineComplexRealImagPartFunction{flonumcf64x, flonumf64x}
@MmuxDefineComplexRealImagPartFunction{flonumcf128x, flonumf128x}

@MmuxDefineComplexRealImagPartFunction{flonumcd32, flonumd32}
@MmuxDefineComplexRealImagPartFunction{flonumcd64, flonumd64}
@MmuxDefineComplexRealImagPartFunction{flonumcd128, flonumd128}

@c page
@node complex argument
@section Computing the argument value


To compute the complex argument of a complex number we do:

@example
mmux_flonumcf64_t  Z = mmux_flonumcf64_rectangular_literal(1.2,3.4);
mmux_flonumf64_t   A = mmux_flonumcf64_argument(Z);

mmux_flonumf64_dprintf(2, A);
@print{} 1.231504
@end example

@noindent
or more generically:

@example
auto    Z = mmux_flonumcf64_rectangular_literal(1.2,3.4);
auto    A = mmux_ctype_argument(Z);

mmux_ctype_dprintf(2, A);
@print{} 1.231504
@end example

To compute the complex argument of a real number we do:

@example
mmux_flonumf64_t   Z = mmux_flonumf64_literal(0.123);
mmux_flonumf64_t   A = mmux_flonumf64_argument(Z);

mmux_flonumf64_dprintf(2, A);
@print{} 0.0
@end example

@noindent
or more generically:

@example
auto    Z = mmux_flonumf64_literal(0.123);
auto    A = mmux_ctype_argument(Z);

mmux_ctype_dprintf(2, A);
@print{} 0.0
@end example

@c ------------------------------------------------------------------------

@macro MmuxDefineRealArgumentFunction{STEM}
@deftypefun mmux_\STEM\_t mmux_\STEM\_argument (mmux_\STEM\_t @var{OP})
Compute and return the argument value of @var{OP} interpreted as complex number.  The result is
always positive zero.
@end deftypefun

@end macro

@c ------------------------------------------------------------------------

@macro MmuxDefineComplexArgumentFunction{CPLXSTEM,REALSTEM}
@deftypefun mmux_\REALSTEM\_t mmux_\CPLXSTEM\_argument (mmux_\CPLXSTEM\_t @var{OP})
Compute and return the argument value of the complex number @var{OP}.
@end deftypefun

@end macro

@c ------------------------------------------------------------------------

@deftypefn {Generic Macro} mmux_ctype_t mmux_ctype_argument (mmux_ctype_t @var{OP})
Compute and return the complex argument value of @var{OP} interpreted as complex number.  The type
@objtype{mmux_ctype_t} is a placeholder for the type of the operand.
@end deftypefn


@MmuxDefineRealArgumentFunction{sshort}
@MmuxDefineRealArgumentFunction{ushort}
@MmuxDefineRealArgumentFunction{sint}
@MmuxDefineRealArgumentFunction{uint}
@MmuxDefineRealArgumentFunction{slong}
@MmuxDefineRealArgumentFunction{ulong}
@MmuxDefineRealArgumentFunction{sllong}
@MmuxDefineRealArgumentFunction{ullong}

@MmuxDefineRealArgumentFunction{sint8}
@MmuxDefineRealArgumentFunction{uint8}
@MmuxDefineRealArgumentFunction{sint16}
@MmuxDefineRealArgumentFunction{uint16}
@MmuxDefineRealArgumentFunction{sint32}
@MmuxDefineRealArgumentFunction{uint32}
@MmuxDefineRealArgumentFunction{sint64}
@MmuxDefineRealArgumentFunction{uint64}

@MmuxDefineRealArgumentFunction{byte}
@MmuxDefineRealArgumentFunction{octet}
@MmuxDefineRealArgumentFunction{sintmax}
@MmuxDefineRealArgumentFunction{uintmax}
@MmuxDefineRealArgumentFunction{sintptr}
@MmuxDefineRealArgumentFunction{uintptr}

@MmuxDefineRealArgumentFunction{flonumfl}
@MmuxDefineRealArgumentFunction{flonumdb}
@MmuxDefineRealArgumentFunction{flonumldb}

@MmuxDefineRealArgumentFunction{flonumf32}
@MmuxDefineRealArgumentFunction{flonumf64}
@MmuxDefineRealArgumentFunction{flonumf128}

@MmuxDefineRealArgumentFunction{flonumf32x}
@MmuxDefineRealArgumentFunction{flonumf64x}
@MmuxDefineRealArgumentFunction{flonumf128x}

@MmuxDefineRealArgumentFunction{flonumd32}
@MmuxDefineRealArgumentFunction{flonumd64}
@MmuxDefineRealArgumentFunction{flonumd128}

@c ------------------------------------------------------------------------

@MmuxDefineComplexArgumentFunction{flonumcfl, flonumfl}
@MmuxDefineComplexArgumentFunction{flonumcdb, flonumdb}
@MmuxDefineComplexArgumentFunction{flonumcldb, flonumldb}

@MmuxDefineComplexArgumentFunction{flonumcf32, flonumf32}
@MmuxDefineComplexArgumentFunction{flonumcf64, flonumf64}
@MmuxDefineComplexArgumentFunction{flonumcf128, flonumf128}

@MmuxDefineComplexArgumentFunction{flonumcf32x, flonumf32x}
@MmuxDefineComplexArgumentFunction{flonumcf64x, flonumf64x}
@MmuxDefineComplexArgumentFunction{flonumcf128x, flonumf128x}

@MmuxDefineComplexArgumentFunction{flonumcd32, flonumd32}
@MmuxDefineComplexArgumentFunction{flonumcd64, flonumd64}
@MmuxDefineComplexArgumentFunction{flonumcd128, flonumd128}

@c page
@node complex conjugate
@section Computing the complex conjugate value


To compute the complex conjugate of a complex number we do:

@example
mmux_flonumcf64_t  Z = mmux_flonumcf64_rectangular_literal(1.2,3.4);
mmux_flonumcf64_t  A = mmux_flonumcf64_conjugate(Z);

mmux_flonumcf64_dprintf(2, A);  @print{} (1.2)+i*(-3.4)
@end example

@noindent
or more generically:

@example
auto      Z = mmux_flonumcf64_rectangular_literal(1.2,3.4);
auto      A = mmux_ctype_conjugate(Z);

mmux_ctype_dprintf(2, A);       @print{} (1.2)+i*(-3.4)
@end example

To compute the complex conjugate of a real number we do:

@example
mmux_flonumf64_t   Z = mmux_flonumf64_literal(0.123);
mmux_flonumf64_t   A = mmux_flonumf64_conjugate(Z);

mmux_flonumf64_dprintf(2, A);   @print{} 0.123
@end example

@noindent
or more generically:

@example
auto      Z = mmux_flonumf64_literal(0.123);
auto      A = mmux_ctype_conjugate(Z);

mmux_ctype_dprintf(2, A);       @print{} 0.123
@end example

@c ------------------------------------------------------------------------

@macro MmuxDefineRealConjugateFunction{STEM}
@deftypefun mmux_\STEM\_t mmux_\STEM\_conjugate (mmux_\STEM\_t @var{OP})
Compute and return complex conjugate value of @var{OP} interpreted as a complex number; the result
is always @var{op} itself.
@end deftypefun

@end macro

@c ------------------------------------------------------------------------

@macro MmuxDefineComplexConjugateFunction{STEM}
@deftypefun mmux_\STEM\_t mmux_\STEM\_conjugate (mmux_\STEM\_t @var{OP})
Compute and return complex conjugate value of the complex number @var{OP}.
@end deftypefun

@end macro

@c ------------------------------------------------------------------------

@deftypefn {Generic Macro} mmux_ctype_t mmux_ctype_conjugate (mmux_ctype_t @var{OP})
Compute and return complex conjugate value of @var{OP}.  The type @objtype{mmux_ctype_t} is a
placeholder for the type of the operand and result.
@end deftypefn


@MmuxDefineRealConjugateFunction{sshort}
@MmuxDefineRealConjugateFunction{ushort}
@MmuxDefineRealConjugateFunction{sint}
@MmuxDefineRealConjugateFunction{uint}
@MmuxDefineRealConjugateFunction{slong}
@MmuxDefineRealConjugateFunction{ulong}
@MmuxDefineRealConjugateFunction{sllong}
@MmuxDefineRealConjugateFunction{ullong}

@MmuxDefineRealConjugateFunction{sint8}
@MmuxDefineRealConjugateFunction{uint8}
@MmuxDefineRealConjugateFunction{sint16}
@MmuxDefineRealConjugateFunction{uint16}
@MmuxDefineRealConjugateFunction{sint32}
@MmuxDefineRealConjugateFunction{uint32}
@MmuxDefineRealConjugateFunction{sint64}
@MmuxDefineRealConjugateFunction{uint64}

@MmuxDefineRealConjugateFunction{byte}
@MmuxDefineRealConjugateFunction{octet}
@MmuxDefineRealConjugateFunction{sintmax}
@MmuxDefineRealConjugateFunction{uintmax}
@MmuxDefineRealConjugateFunction{sintptr}
@MmuxDefineRealConjugateFunction{uintptr}

@MmuxDefineRealConjugateFunction{flonumfl}
@MmuxDefineRealConjugateFunction{flonumdb}
@MmuxDefineRealConjugateFunction{flonumldb}

@MmuxDefineRealConjugateFunction{flonumf32}
@MmuxDefineRealConjugateFunction{flonumf64}
@MmuxDefineRealConjugateFunction{flonumf128}

@MmuxDefineRealConjugateFunction{flonumf32x}
@MmuxDefineRealConjugateFunction{flonumf64x}
@MmuxDefineRealConjugateFunction{flonumf128x}

@MmuxDefineRealConjugateFunction{flonumd32}
@MmuxDefineRealConjugateFunction{flonumd64}
@MmuxDefineRealConjugateFunction{flonumd128}

@c ------------------------------------------------------------------------

@MmuxDefineComplexConjugateFunction{flonumcfl}
@MmuxDefineComplexConjugateFunction{flonumcdb}
@MmuxDefineComplexConjugateFunction{flonumcldb}

@MmuxDefineComplexConjugateFunction{flonumcf32}
@MmuxDefineComplexConjugateFunction{flonumcf64}
@MmuxDefineComplexConjugateFunction{flonumcf128}

@MmuxDefineComplexConjugateFunction{flonumcf32x}
@MmuxDefineComplexConjugateFunction{flonumcf64x}
@MmuxDefineComplexConjugateFunction{flonumcf128x}

@MmuxDefineComplexConjugateFunction{flonumcd32}
@MmuxDefineComplexConjugateFunction{flonumcd64}
@MmuxDefineComplexConjugateFunction{flonumcd128}

@c page
@node predicates
@chapter Type predicates


@cindex @objtype{char} is signed
@cindex @objtype{char} is unsigned
@cindex Signed @objtype{char}
@cindex Unsigned @objtype{char}


To test if a real number is zero we do:

@example
mmux_flonumf32x_t val = mmux_flonumf32x_literal(123.45);

if (mmux_flonumf32x_is_zero(val)) @{
  ...
@}
@end example

@noindent
or more generically:

@example
auto  val = mmux_flonumf32x_literal(123.45);

if (mmux_ctype_is_zero(val)) @{
  ...
@}
@end example

Notes:

@itemize
@item
When the following predicates are applied to a complex number: the predicate returns @ctrue{} if
both the real and imaginary parts satisfy it.

@item
The C language defines the zero for floating--point numbers as having a sign, so we have @samp{-0.0}
and @samp{+0.0}; this means zero can be positive or negative and the following predicates examine
the sign bit to determine the return value.
@end itemize


@deftypefun bool mmux_char_is_unsigned (void)
Return @ctrue{} if @objtype{mmux_char_t} is unsigned; otherwise return @cfalse{}.
@end deftypefun


@defmac MMUX_CC_TYPES_CHAR_IS_SIGNED
@defmacx MMUX_CC_TYPES_CHAR_IS_UNSIGNED
Preprocessor symbols defined to @samp{1} only if the corresponding condition is true; otherwise they
are undefined.  Whether the standard type @objtype{char} is signed or unsigned, it is implementation
dependent.  We can use them as follows:

@example
#ifdef MMUX_CC_TYPES_CHAR_IS_SIGNED
...
#endif
@end example
@end defmac

@c ------------------------------------------------------------------------

@macro MmuxDefineTypePredicates{STEM}
@deftypefun bool mmux_\STEM\_is_zero (mmux_\STEM\_t @var{OP})
@deftypefunx bool mmux_\STEM\_is_positive (mmux_\STEM\_t @var{OP})
@deftypefunx bool mmux_\STEM\_is_negative (mmux_\STEM\_t @var{OP})
@deftypefunx bool mmux_\STEM\_is_non_positive (mmux_\STEM\_t @var{OP})
@deftypefunx bool mmux_\STEM\_is_non_negative (mmux_\STEM\_t @var{OP})
@deftypefunx bool mmux_\STEM\_is_infinite (mmux_\STEM\_t @var{OP})
@deftypefunx bool mmux_\STEM\_is_finite (mmux_\STEM\_t @var{OP})
@deftypefunx bool mmux_\STEM\_is_nan (mmux_\STEM\_t @var{OP})
Return @ctrue{} if @var{OP} is zero, positive, negative, non--positive, non--negative, infinite,
not--a--number; otherwise return @cfalse{}.
@end deftypefun

@end macro

@c ------------------------------------------------------------------------

@macro MmuxDefineFlonumTypePredicates{STEM}
@deftypefun bool mmux_\STEM\_is_zero (mmux_\STEM\_t @var{OP})
@deftypefunx bool mmux_\STEM\_is_positive (mmux_\STEM\_t @var{OP})
@deftypefunx bool mmux_\STEM\_is_negative (mmux_\STEM\_t @var{OP})
@deftypefunx bool mmux_\STEM\_is_non_positive (mmux_\STEM\_t @var{OP})
@deftypefunx bool mmux_\STEM\_is_non_negative (mmux_\STEM\_t @var{OP})
@deftypefunx bool mmux_\STEM\_is_infinite (mmux_\STEM\_t @var{OP})
@deftypefunx bool mmux_\STEM\_is_finite (mmux_\STEM\_t @var{OP})
@deftypefunx bool mmux_\STEM\_is_nan (mmux_\STEM\_t @var{OP})
@deftypefunx bool mmux_\STEM\_is_normal (mmux_\STEM\_t @var{OP})
@deftypefunx bool mmux_\STEM\_is_subnormal (mmux_\STEM\_t @var{OP})
Return @ctrue{} if @var{OP} is zero, positive, negative, non--positive, non--negative, infinite,
not--a--number, normal, subnormal; otherwise return @cfalse{}.
@end deftypefun

@end macro

@c ------------------------------------------------------------------------

@deftypefn {Generic Macro} bool mmux_ctype_is_zero (mmux_ctype_t @var{OP})
@deftypefnx {Generic Macro} bool mmux_ctype_is_positive (mmux_ctype_t @var{OP})
@deftypefnx {Generic Macro} bool mmux_ctype_is_negative (mmux_ctype_t @var{OP})
@deftypefnx {Generic Macro} bool mmux_ctype_is_non_positive (mmux_ctype_t @var{OP})
@deftypefnx {Generic Macro} bool mmux_ctype_is_non_negative (mmux_ctype_t @var{OP})
@deftypefnx {Generic Macro} bool mmux_ctype_is_infinite (mmux_ctype_t @var{OP})
@deftypefnx {Generic Macro} bool mmux_ctype_is_finite (mmux_ctype_t @var{OP})
@deftypefnx {Generic Macro} bool mmux_ctype_is_nan (mmux_ctype_t @var{OP})
@deftypefnx {Generic Macro} bool mmux_ctype_is_normal (mmux_ctype_t @var{OP})
@deftypefnx {Generic Macro} bool mmux_ctype_is_subnormal (mmux_ctype_t @var{OP})
Return @ctrue{} if @var{OP} is zero, positive, negative, non--positive, non--negative, infinite,
not--a--number, normal, subnormal; otherwise return @cfalse{}.  The type @objtype{mmux_ctype_t} is a
placeholder for the type of the operand.
@end deftypefn

@MmuxDefineTypePredicates{pointer}

@MmuxDefineTypePredicates{char}
@MmuxDefineTypePredicates{schar}
@MmuxDefineTypePredicates{uchar}
@MmuxDefineTypePredicates{sshort}
@MmuxDefineTypePredicates{ushort}
@MmuxDefineTypePredicates{sint}
@MmuxDefineTypePredicates{uint}
@MmuxDefineTypePredicates{slong}
@MmuxDefineTypePredicates{ulong}
@MmuxDefineTypePredicates{sllong}
@MmuxDefineTypePredicates{ullong}
@MmuxDefineTypePredicates{sint8}
@MmuxDefineTypePredicates{uint8}
@MmuxDefineTypePredicates{sint16}
@MmuxDefineTypePredicates{uint16}
@MmuxDefineTypePredicates{sint32}
@MmuxDefineTypePredicates{uint32}
@MmuxDefineTypePredicates{sint64}
@MmuxDefineTypePredicates{uint64}

@MmuxDefineTypePredicates{byte}
@MmuxDefineTypePredicates{octet}

@MmuxDefineTypePredicates{ssize}
@MmuxDefineTypePredicates{usize}
@MmuxDefineTypePredicates{sintmax}
@MmuxDefineTypePredicates{uintmax}
@MmuxDefineTypePredicates{sintptr}
@MmuxDefineTypePredicates{uintptr}
@MmuxDefineTypePredicates{ptrdiff}
@MmuxDefineTypePredicates{mode}
@MmuxDefineTypePredicates{off}
@MmuxDefineTypePredicates{pid}
@MmuxDefineTypePredicates{uid}
@MmuxDefineTypePredicates{gid}
@MmuxDefineTypePredicates{wchar}
@MmuxDefineTypePredicates{wint}
@MmuxDefineTypePredicates{time}
@MmuxDefineTypePredicates{socklen}
@MmuxDefineTypePredicates{rlim}
@MmuxDefineTypePredicates{ino}
@MmuxDefineTypePredicates{dev}
@MmuxDefineTypePredicates{nlink}
@MmuxDefineTypePredicates{blkcnt}

@MmuxDefineFlonumTypePredicates{flonumfl}
@MmuxDefineFlonumTypePredicates{flonumdb}
@MmuxDefineFlonumTypePredicates{flonumldb}

@MmuxDefineFlonumTypePredicates{flonumf32}
@MmuxDefineFlonumTypePredicates{flonumf64}
@MmuxDefineFlonumTypePredicates{flonumf128}

@MmuxDefineFlonumTypePredicates{flonumf32x}
@MmuxDefineFlonumTypePredicates{flonumf64x}
@MmuxDefineFlonumTypePredicates{flonumf128x}

@MmuxDefineFlonumTypePredicates{flonumd32}
@MmuxDefineFlonumTypePredicates{flonumd64}
@MmuxDefineFlonumTypePredicates{flonumd128}

@MmuxDefineFlonumTypePredicates{flonumcfl}
@MmuxDefineFlonumTypePredicates{flonumcdb}
@MmuxDefineFlonumTypePredicates{flonumcldb}

@MmuxDefineFlonumTypePredicates{flonumcf32}
@MmuxDefineFlonumTypePredicates{flonumcf64}
@MmuxDefineFlonumTypePredicates{flonumcf128}

@MmuxDefineFlonumTypePredicates{flonumcf32x}
@MmuxDefineFlonumTypePredicates{flonumcf64x}
@MmuxDefineFlonumTypePredicates{flonumcf128x}

@MmuxDefineFlonumTypePredicates{flonumcd32}
@MmuxDefineFlonumTypePredicates{flonumcd64}
@MmuxDefineFlonumTypePredicates{flonumcd128}

@c page
@node comparison
@chapter Comparison functions


@menu
* comparison exact::            Exact comparison functions.
* comparison mimmax::           Maximum and minimum values.
* comparison absmargin::        Absolute margin comparison criterion.
* comparison relepsilon::       Relative epsilon comparison criterion.
@end menu

@c page
@node comparison exact
@section Exact comparison functions


To compare two numbers we do:

@example
mmux_slong_t      A = mmux_slong_literal(123);
mmux_slong_t      B = mmux_slong_literal(456);
mmux_sint_t       V = mmux_slong_cmp(A, B);

mmux_sint_dprintf(2, V);        @print{} -1
if (0 == V.value) @{
  ...
@}
@end example

@noindent
or more generically:

@example
auto              A = mmux_slong_literal(123);
auto              B = mmux_slong_literal(456);
mmux_sint_t       V = mmux_ctype_cmp(A, B);

mmux_sint_dprintf(2, V);        @print{} -1
if (0 == V.value) @{
  ...
@}
@end example

Notes:

@itemize
@item
In the context of @value{PACKAGE}, when comparing complex numbers: the functions @samp{cmp},
@samp{equal}, @samp{less}, @samp{greater}, @samp{less_equal}, @samp{greater_equal} compare the
absolute value of the complex operands.

@item
The @cfunc{mmux_*_cmp} functions perform the usual comparison with ternary result.  The predicate
functions return @ctrue{} if the operands are in the named relation; otherwise return @cfalse{}.
@end itemize

@c ------------------------------------------------------------------------

@macro MmuxDefineTypeComparisonExactFunction{STEM}
@deftypefun mmux_sint_t mmux_\STEM\_cmp (mmux_\STEM\_t @vari{OP}, mmux_\STEM\_t @varii{OP})
@deftypefunx bool mmux_\STEM\_equal (mmux_\STEM\_t @vari{OP}, mmux_\STEM\_t @varii{OP})
@deftypefunx bool mmux_\STEM\_not_equal (mmux_\STEM\_t @vari{OP}, mmux_\STEM\_t @varii{OP})
@deftypefunx bool mmux_\STEM\_greater (mmux_\STEM\_t @vari{OP}, mmux_\STEM\_t @varii{OP})
@deftypefunx bool mmux_\STEM\_less (mmux_\STEM\_t @vari{OP}, mmux_\STEM\_t @varii{OP})
@deftypefunx bool mmux_\STEM\_greater_equal (mmux_\STEM\_t @vari{OP}, mmux_\STEM\_t @varii{OP})
@deftypefunx bool mmux_\STEM\_less_equal (mmux_\STEM\_t @vari{OP}, mmux_\STEM\_t @varii{OP})
Comparison between @objtype{mmux_\STEM\_t} values.
@end deftypefun

@end macro

@c ------------------------------------------------------------------------

@deftypefn {Generic Macro} mmux_sint_t mmux_ctype_cmp (mmux_ctype_t @vari{OP}, mmux_ctype_t @varii{OP})
@deftypefnx {Generic Macro} bool mmux_ctype_equal (mmux_ctype_t @vari{OP}, mmux_ctype_t @varii{OP})
@deftypefnx {Generic Macro} bool mmux_ctype_not_equal (mmux_ctype_t @vari{OP}, mmux_ctype_t @varii{OP})
@deftypefnx {Generic Macro} bool mmux_ctype_greater (mmux_ctype_t @vari{OP}, mmux_ctype_t @varii{OP})
@deftypefnx {Generic Macro} bool mmux_ctype_less (mmux_ctype_t @vari{OP}, mmux_ctype_t @varii{OP})
@deftypefnx {Generic Macro} bool mmux_ctype_greater_equal (mmux_ctype_t @vari{OP}, mmux_ctype_t @varii{OP})
@deftypefnx {Generic Macro} bool mmux_ctype_less_equal (mmux_ctype_t @vari{OP}, mmux_ctype_t @varii{OP})
Comparison between values.  The type @objtype{mmux_ctype_t} is a placeholder for the type of the
operands.
@end deftypefn

@MmuxDefineTypeComparisonExactFunction{pointer}

@MmuxDefineTypeComparisonExactFunction{char}
@MmuxDefineTypeComparisonExactFunction{schar}
@MmuxDefineTypeComparisonExactFunction{uchar}
@MmuxDefineTypeComparisonExactFunction{sshort}
@MmuxDefineTypeComparisonExactFunction{ushort}
@MmuxDefineTypeComparisonExactFunction{sint}
@MmuxDefineTypeComparisonExactFunction{uint}
@MmuxDefineTypeComparisonExactFunction{slong}
@MmuxDefineTypeComparisonExactFunction{ulong}
@MmuxDefineTypeComparisonExactFunction{sllong}
@MmuxDefineTypeComparisonExactFunction{ullong}
@MmuxDefineTypeComparisonExactFunction{sint8}
@MmuxDefineTypeComparisonExactFunction{uint8}
@MmuxDefineTypeComparisonExactFunction{sint16}
@MmuxDefineTypeComparisonExactFunction{uint16}
@MmuxDefineTypeComparisonExactFunction{sint32}
@MmuxDefineTypeComparisonExactFunction{uint32}
@MmuxDefineTypeComparisonExactFunction{sint64}
@MmuxDefineTypeComparisonExactFunction{uint64}

@MmuxDefineTypeComparisonExactFunction{byte}
@MmuxDefineTypeComparisonExactFunction{octet}

@MmuxDefineTypeComparisonExactFunction{ssize}
@MmuxDefineTypeComparisonExactFunction{usize}
@MmuxDefineTypeComparisonExactFunction{sintmax}
@MmuxDefineTypeComparisonExactFunction{uintmax}
@MmuxDefineTypeComparisonExactFunction{sintptr}
@MmuxDefineTypeComparisonExactFunction{uintptr}
@MmuxDefineTypeComparisonExactFunction{ptrdiff}
@MmuxDefineTypeComparisonExactFunction{mode}
@MmuxDefineTypeComparisonExactFunction{off}
@MmuxDefineTypeComparisonExactFunction{pid}
@MmuxDefineTypeComparisonExactFunction{uid}
@MmuxDefineTypeComparisonExactFunction{gid}
@MmuxDefineTypeComparisonExactFunction{wchar}
@MmuxDefineTypeComparisonExactFunction{wint}
@MmuxDefineTypeComparisonExactFunction{time}
@MmuxDefineTypeComparisonExactFunction{socklen}
@MmuxDefineTypeComparisonExactFunction{rlim}
@MmuxDefineTypeComparisonExactFunction{ino}
@MmuxDefineTypeComparisonExactFunction{dev}
@MmuxDefineTypeComparisonExactFunction{nlink}
@MmuxDefineTypeComparisonExactFunction{blkcnt}

@MmuxDefineTypeComparisonExactFunction{flonumfl}
@MmuxDefineTypeComparisonExactFunction{flonumdb}
@MmuxDefineTypeComparisonExactFunction{flonumldb}

@MmuxDefineTypeComparisonExactFunction{flonumf32}
@MmuxDefineTypeComparisonExactFunction{flonumf64}
@MmuxDefineTypeComparisonExactFunction{flonumf128}

@MmuxDefineTypeComparisonExactFunction{flonumf32x}
@MmuxDefineTypeComparisonExactFunction{flonumf64x}
@MmuxDefineTypeComparisonExactFunction{flonumf128x}

@MmuxDefineTypeComparisonExactFunction{flonumd32}
@MmuxDefineTypeComparisonExactFunction{flonumd64}
@MmuxDefineTypeComparisonExactFunction{flonumd128}

@MmuxDefineTypeComparisonExactFunction{flonumcfl}
@MmuxDefineTypeComparisonExactFunction{flonumcdb}
@MmuxDefineTypeComparisonExactFunction{flonumcldb}

@MmuxDefineTypeComparisonExactFunction{flonumcf32}
@MmuxDefineTypeComparisonExactFunction{flonumcf64}
@MmuxDefineTypeComparisonExactFunction{flonumcf128}

@MmuxDefineTypeComparisonExactFunction{flonumcf32x}
@MmuxDefineTypeComparisonExactFunction{flonumcf64x}
@MmuxDefineTypeComparisonExactFunction{flonumcf128x}

@MmuxDefineTypeComparisonExactFunction{flonumcd32}
@MmuxDefineTypeComparisonExactFunction{flonumcd64}
@MmuxDefineTypeComparisonExactFunction{flonumcd128}

@c page
@node comparison mimmax
@section Maximum and minimum values


To determine the maximum between two numbers we do:

@example
mmux_uint64_t     A = mmux_uint64_literal(123);
mmux_uint64_t     B = mmux_uint64_literal(456);
mmux_uint64_t     V = mmux_uint64_max(A, B);

mmux_uint64_dprintf(2, V);       @print{} 456
@end example

@noindent
or more generically:

@example
auto      A = mmux_uint64_literal(123);
auto      B = mmux_uint64_literal(456);
auto      V = mmux_ctype_max(A, B);

mmux_ctype_dprintf(2, V);       @print{} 456
@end example

In what follows: complex floating--point numbers are compared by comparing their absolute values.

@c ------------------------------------------------------------------------

@macro MmuxDefineTypeComparisonMinMaxFunction{STEM}
@deftypefun mmux_\STEM\_t mmux_\STEM\_max (mmux_\STEM\_t @vari{OP}, mmux_\STEM\_t @varii{OP})
@deftypefunx mmux_\STEM\_t mmux_\STEM\_min (mmux_\STEM\_t @vari{OP}, mmux_\STEM\_t @varii{OP})
Return the maximum or minimum value between the operands.
@end deftypefun

@end macro

@c ------------------------------------------------------------------------

@deftypefn {Generic Macro} mmux_ctype_t mmux_ctype_max (mmux_ctype_t @vari{OP}, mmux_ctype_t @varii{OP})
@deftypefnx {Generic Macro} mmux_ctype_t mmux_ctype_min (mmux_ctype_t @vari{OP}, mmux_ctype_t @varii{OP})
Return the maximum or minimum value between the operands.  The type @objtype{mmux_ctype_t} is a
placeholder for the type of the operands and result.
@end deftypefn


@MmuxDefineTypeComparisonMinMaxFunction{pointer}

@MmuxDefineTypeComparisonMinMaxFunction{char}
@MmuxDefineTypeComparisonMinMaxFunction{schar}
@MmuxDefineTypeComparisonMinMaxFunction{uchar}
@MmuxDefineTypeComparisonMinMaxFunction{sshort}
@MmuxDefineTypeComparisonMinMaxFunction{ushort}
@MmuxDefineTypeComparisonMinMaxFunction{sint}
@MmuxDefineTypeComparisonMinMaxFunction{uint}
@MmuxDefineTypeComparisonMinMaxFunction{slong}
@MmuxDefineTypeComparisonMinMaxFunction{ulong}
@MmuxDefineTypeComparisonMinMaxFunction{sllong}
@MmuxDefineTypeComparisonMinMaxFunction{ullong}

@MmuxDefineTypeComparisonMinMaxFunction{sint8}
@MmuxDefineTypeComparisonMinMaxFunction{uint8}
@MmuxDefineTypeComparisonMinMaxFunction{sint16}
@MmuxDefineTypeComparisonMinMaxFunction{uint16}
@MmuxDefineTypeComparisonMinMaxFunction{sint32}
@MmuxDefineTypeComparisonMinMaxFunction{uint32}
@MmuxDefineTypeComparisonMinMaxFunction{sint64}
@MmuxDefineTypeComparisonMinMaxFunction{uint64}

@MmuxDefineTypeComparisonMinMaxFunction{byte}
@MmuxDefineTypeComparisonMinMaxFunction{octet}

@MmuxDefineTypeComparisonMinMaxFunction{ssize}
@MmuxDefineTypeComparisonMinMaxFunction{usize}
@MmuxDefineTypeComparisonMinMaxFunction{sintmax}
@MmuxDefineTypeComparisonMinMaxFunction{uintmax}
@MmuxDefineTypeComparisonMinMaxFunction{sintptr}
@MmuxDefineTypeComparisonMinMaxFunction{uintptr}
@MmuxDefineTypeComparisonMinMaxFunction{ptrdiff}
@MmuxDefineTypeComparisonMinMaxFunction{mode}
@MmuxDefineTypeComparisonMinMaxFunction{off}
@MmuxDefineTypeComparisonMinMaxFunction{pid}
@MmuxDefineTypeComparisonMinMaxFunction{uid}
@MmuxDefineTypeComparisonMinMaxFunction{gid}
@MmuxDefineTypeComparisonMinMaxFunction{wchar}
@MmuxDefineTypeComparisonMinMaxFunction{wint}
@MmuxDefineTypeComparisonMinMaxFunction{time}
@MmuxDefineTypeComparisonMinMaxFunction{socklen}
@MmuxDefineTypeComparisonMinMaxFunction{rlim}
@MmuxDefineTypeComparisonMinMaxFunction{ino}
@MmuxDefineTypeComparisonMinMaxFunction{dev}
@MmuxDefineTypeComparisonMinMaxFunction{nlink}
@MmuxDefineTypeComparisonMinMaxFunction{blkcnt}

@MmuxDefineTypeComparisonMinMaxFunction{flonumfl}
@MmuxDefineTypeComparisonMinMaxFunction{flonumdb}
@MmuxDefineTypeComparisonMinMaxFunction{flonumldb}

@MmuxDefineTypeComparisonMinMaxFunction{flonumf32}
@MmuxDefineTypeComparisonMinMaxFunction{flonumf64}
@MmuxDefineTypeComparisonMinMaxFunction{flonumf128}

@MmuxDefineTypeComparisonMinMaxFunction{flonumf32x}
@MmuxDefineTypeComparisonMinMaxFunction{flonumf64x}
@MmuxDefineTypeComparisonMinMaxFunction{flonumf128x}

@MmuxDefineTypeComparisonMinMaxFunction{flonumd32}
@MmuxDefineTypeComparisonMinMaxFunction{flonumd64}
@MmuxDefineTypeComparisonMinMaxFunction{flonumd128}

@MmuxDefineTypeComparisonMinMaxFunction{flonumcfl}
@MmuxDefineTypeComparisonMinMaxFunction{flonumcdb}
@MmuxDefineTypeComparisonMinMaxFunction{flonumcldb}

@MmuxDefineTypeComparisonMinMaxFunction{flonumcf32}
@MmuxDefineTypeComparisonMinMaxFunction{flonumcf64}
@MmuxDefineTypeComparisonMinMaxFunction{flonumcf128}

@MmuxDefineTypeComparisonMinMaxFunction{flonumcf32x}
@MmuxDefineTypeComparisonMinMaxFunction{flonumcf64x}
@MmuxDefineTypeComparisonMinMaxFunction{flonumcf128x}

@MmuxDefineTypeComparisonMinMaxFunction{flonumcd32}
@MmuxDefineTypeComparisonMinMaxFunction{flonumcd64}
@MmuxDefineTypeComparisonMinMaxFunction{flonumcd128}

@c page
@node comparison absmargin
@section Absolute margin comparison criterion


@cindex Absolute margin comparison criterion
@cindex Comparison criterion, absolute margin
@cindex Margin, absolute margin comparison criterion


To compare real numbers with the @dfn{criterion of the absolute margin} means to verify the
predicate between the real numbers @vari{OP}, @varii{OP}, @var{MARGIN}:

@example
abs(@vari{OP} - @varii{OP}) <= abs(@var{MARGIN})
@end example

@noindent
while to compare complex numbers means to verify the predicate between the complex numbers
@vari{OP}, @varii{OP}, @var{MARGIN}:

@example
abs(real(@vari{OP}) - real(@varii{OP})) <= abs(real(@var{MARGIN})) &&
abs(imag(@vari{OP}) - imag(@varii{OP})) <= abs(imag(@var{MARGIN}))
@end example

To compare two floating--point numbers with the criterion of the absolute margin, we do:

@example
mmux_flonumldb_t  op1 = mmux_flonumdb_literal(1.2);
mmux_flonumldb_t  op2 = mmux_flonumdb_literal(1.23);
mmux_flonumldb_t  mrg = mmux_flonumdb_literal(1e-6);

if (mmux_flonumldb_equal_absmargin(op1, op2, mrg)) @{
  ... /* equal */
@} else @{
  ... /* not equal */
@}
@end example

@noindent
or more generically:

@example
auto      op1 = mmux_flonumldb_literal(1.2);
auto      op2 = mmux_flonumldb_literal(1.23);
auto      mrg = mmux_flonumldb_literal(1e-6);

if (mmux_ctype_equal_absmargin(op1, op2, mrg)) @{
  ... /* equal */
@} else @{
  ... /* not equal */
@}
@end example

@c ------------------------------------------------------------------------

@macro MmuxDefineAbsmarginFunc{STEM}
@deftypefun bool mmux_\STEM\_equal_absmargin (mmux_\STEM\_t @vari{OP}, mmux_\STEM\_t @varii{OP}, mmux_\STEM\_t @vari{MARGIN})
Compare the operands using the given margin.
@end deftypefun

@end macro

@c ------------------------------------------------------------------------

@deftypefn {Generic Macro} bool mmux_ctype_equal_absmargin (mmux_ctype_t @vari{OP}, mmux_ctype_t @varii{OP}, mmux_ctype_t @vari{MARGIN})
Compare the operands using the given margin.  The type @objtype{mmux_ctype_t} is a placeholder for
the type of the operands.
@end deftypefn


@MmuxDefineAbsmarginFunc{flonumfl}
@MmuxDefineAbsmarginFunc{flonumdb}
@MmuxDefineAbsmarginFunc{flonumldb}

@MmuxDefineAbsmarginFunc{flonumf32}
@MmuxDefineAbsmarginFunc{flonumf64}
@MmuxDefineAbsmarginFunc{flonumf128}

@MmuxDefineAbsmarginFunc{flonumf32x}
@MmuxDefineAbsmarginFunc{flonumf64x}
@MmuxDefineAbsmarginFunc{flonumf128x}

@MmuxDefineAbsmarginFunc{flonumd32}
@MmuxDefineAbsmarginFunc{flonumd64}
@MmuxDefineAbsmarginFunc{flonumd128}

@c ------------------------------------------------------------------------

@MmuxDefineAbsmarginFunc{flonumcfl}
@MmuxDefineAbsmarginFunc{flonumcdb}
@MmuxDefineAbsmarginFunc{flonumcldb}

@MmuxDefineAbsmarginFunc{flonumcf32}
@MmuxDefineAbsmarginFunc{flonumcf64}
@MmuxDefineAbsmarginFunc{flonumcf128}

@MmuxDefineAbsmarginFunc{flonumcf32x}
@MmuxDefineAbsmarginFunc{flonumcf64x}
@MmuxDefineAbsmarginFunc{flonumcf128x}

@MmuxDefineAbsmarginFunc{flonumcd32}
@MmuxDefineAbsmarginFunc{flonumcd64}
@MmuxDefineAbsmarginFunc{flonumcd128}

@c page
@node comparison relepsilon
@section Relative epsilon comparison criterion


@cindex Relative epsilon comparison criterion
@cindex Comparison criterion, relative epsilon
@cindex Epsilon, relative epsilon comparison criterion


To compare real numbers with the @dfn{criterion of the relative epsilon} means to verify the
predicate between the real numbers @vari{OP}, @varii{OP}, @var{EPSILON}:

@example
abs(@vari{OP} - @varii{OP}) <= (abs(@var{EPSILON}) * max(abs(@vari{OP}), abs(@varii{OP})))
@end example

@noindent
while to compare complex numbers means to verify the predicate between the complex numbers
@vari{OP}, @varii{OP}, @var{EPSILON}:

@example
abs(real(@varo{OP}) - real(@var{OP})) <= (abs(real(@var{EPSILON})) * max(abs(real(@vari{OP})), abs(real(@varii{OP})))) &&
abs(imag(@varo{OP}) - imag(@var{OP})) <= (abs(imag(@var{EPSILON})) * max(abs(imag(@vari{OP})), abs(imag(@varii{OP}))))
@end example

To compare two floating--point numbers with the criterion of the relative epsilon, we do:

@example
mmux_flonumldb_t  op1 = mmux_flonumdb_literal(1.2);
mmux_flonumldb_t  op2 = mmux_flonumdb_literal(1.23);
mmux_flonumldb_t  eps = mmux_flonumdb_literal(1e-6);

if (mmux_flonumldb_equal_relepsilon(op1, op2, eps)) @{
  ... /* equal */
@} else @{
  ... /* not equal */
@}
@end example

@noindent
or more generically:

@example
auto      op1 = mmux_flonumldb_literal(1.2);
auto      op2 = mmux_flonumldb_literal(1.23);
auto      eps = mmux_flonumldb_literal(1e-6);

if (mmux_ctype_equal_relepsilon(op1, op2, eps)) @{
  ... /* equal */
@} else @{
  ... /* not equal */
@}
@end example

@c ------------------------------------------------------------------------

@macro MmuxDefineRelepsilonFunc{STEM}
@deftypefun bool mmux_\STEM\_equal_relepsilon (mmux_\STEM\_t @vari{OP}, mmux_\STEM\_t @varii{OP}, mmux_\STEM\_t @vari{EPSILON})
Compare the operands using the given epsilon.
@end deftypefun

@end macro

@c ------------------------------------------------------------------------

@deftypefn {Generic Macro} bool mmux_ctype_equal_relepsilon (mmux_ctype_t @vari{OP}, mmux_ctype_t @varii{OP}, mmux_ctype_t @vari{EPSILON})
Compare the operands using the given epsilon.  The type @objtype{mmux_ctype_t} is a placeholder for
the type of the operands.
@end deftypefn


@MmuxDefineRelepsilonFunc{flonumfl}
@MmuxDefineRelepsilonFunc{flonumdb}
@MmuxDefineRelepsilonFunc{flonumldb}

@MmuxDefineRelepsilonFunc{flonumf32}
@MmuxDefineRelepsilonFunc{flonumf64}
@MmuxDefineRelepsilonFunc{flonumf128}

@MmuxDefineRelepsilonFunc{flonumf32x}
@MmuxDefineRelepsilonFunc{flonumf64x}
@MmuxDefineRelepsilonFunc{flonumf128x}

@MmuxDefineRelepsilonFunc{flonumd32}
@MmuxDefineRelepsilonFunc{flonumd64}
@MmuxDefineRelepsilonFunc{flonumd128}

@c ------------------------------------------------------------------------

@MmuxDefineRelepsilonFunc{flonumcfl}
@MmuxDefineRelepsilonFunc{flonumcdb}
@MmuxDefineRelepsilonFunc{flonumcldb}

@MmuxDefineRelepsilonFunc{flonumcf32}
@MmuxDefineRelepsilonFunc{flonumcf64}
@MmuxDefineRelepsilonFunc{flonumcf128}

@MmuxDefineRelepsilonFunc{flonumcf32x}
@MmuxDefineRelepsilonFunc{flonumcf64x}
@MmuxDefineRelepsilonFunc{flonumcf128x}

@MmuxDefineRelepsilonFunc{flonumcd32}
@MmuxDefineRelepsilonFunc{flonumcd64}
@MmuxDefineRelepsilonFunc{flonumcd128}

@c page
@node arithmetics
@chapter Arithmetical operations


To add two numbers we do:

@example
mmux_flonumf128_t A = mmux_flonumf128_literal(1.23);
mmux_flonumf128_t B = mmux_flonumf128_literal(4.56);
mmux_flonumf128_t C = mmux_flonumf128_add(A, B);

mmux_flonumf128_dprintf(2, C);  @print{} 5.79
@end example

@noindent
or more generically:

@example
auto      A = mmux_flonumf128_literal(1.23);
auto      B = mmux_flonumf128_literal(4.56);
auto      C = mmux_ctype_add(A, B);

mmux_ctype_dprintf(2, C);  @print{} 5.79
@end example

Notes on arithmetics functions:

@itemize
@item
Notice how the @code{neg} functions are defined for unsigned exact integers: the result of such an
operation is whatever the compiled code produces; for example:

@example
auto    op  = mmux_ulong_literal(5);
auto    rop = mmux_ctype_neg(op);

mmux_ctype_dprintf(2, rop);     @print{} 18446744073709551611
@end example

@item
The @code{modulo} functions for floating--point numbers is implemented using the @cfunc{fmod}
standard functions.
@end itemize


@deftypefn {Generic Macro} mmux_ctype_t mmux_ctype_add (mmux_ctype_t @vari{OP}, mmux_ctype_t @varii{OP})
@deftypefnx {Generic Macro} mmux_ctype_t mmux_ctype_sub (mmux_ctype_t @vari{OP}, mmux_ctype_t @varii{OP})
@deftypefnx {Generic Macro} mmux_ctype_t mmux_ctype_mul (mmux_ctype_t @vari{OP}, mmux_ctype_t @varii{OP})
@deftypefnx {Generic Macro} mmux_ctype_t mmux_ctype_div (mmux_ctype_t @vari{OP}, mmux_ctype_t @varii{OP})
@deftypefnx {Generic Macro} mmux_ctype_t mmux_ctype_neg (mmux_ctype_t @var{OP})
@deftypefnx {Generic Macro} mmux_ctype_t mmux_ctype_inverse (mmux_ctype_t @var{OP})
@deftypefnx {Generic Macro} mmux_ctype_t mmux_ctype_absolute (mmux_ctype_t @var{OP})
@deftypefnx {Generic Macro} mmux_ctype_t mmux_ctype_modulo (mmux_ctype_t @vari{OP}, mmux_ctype_t @varii{OP})
@deftypefnx {Generic Macro} mmux_ctype_t mmux_ctype_remainder (mmux_ctype_t @vari{OP}, mmux_ctype_t @varii{OP})
@deftypefnx {Generic Macro} mmux_ctype_t mmux_ctype_incr (mmux_ctype_t @var{OP})
@deftypefnx {Generic Macro} mmux_ctype_t mmux_ctype_decr (mmux_ctype_t @var{OP})
Compute the addition, subtraction, multiplication, division, negation, inverse, absolute value,
modulo, remainder, increment, decrement.  The type @objtype{mmux_ctype_t} is a placeholder for the
type of the operands and result.
@end deftypefn


@deftypefun mmux_pointer_t mmux_pointer_add (mmux_pointer_t @var{OP}, mmux_ptrdiff_t @var{DELTA})
Perform the addition between @var{PTR} and @var{DELTA}, return the result.
@end deftypefun


@deftypefun mmux_ptrdiff_t mmux_pointer_sub (mmux_pointer_t @vari{OP}, mmux_pointer_t @varii{OP})
Compute the difference between the operands @code{@vari{OP} - @varii{OP}}, interpreting the pointers
as @code{mmux_uint8_t *}, return the result.
@end deftypefun

@c ------------------------------------------------------------------------

@macro MmuxDefineNotIntegerRealArithmeticsFunc{STEM}
@deftypefun mmux_\STEM\_t mmux_\STEM\_add (mmux_\STEM\_t @vari{OP}, mmux_\STEM\_t @varii{OP})
@deftypefunx mmux_\STEM\_t mmux_\STEM\_sub (mmux_\STEM\_t @vari{OP}, mmux_\STEM\_t @varii{OP})
@deftypefunx mmux_\STEM\_t mmux_\STEM\_mul (mmux_\STEM\_t @vari{OP}, mmux_\STEM\_t @varii{OP})
@deftypefunx mmux_\STEM\_t mmux_\STEM\_div (mmux_\STEM\_t @vari{OP}, mmux_\STEM\_t @varii{OP})
@deftypefunx mmux_\STEM\_t mmux_\STEM\_neg (mmux_\STEM\_t @var{OP})
@deftypefunx mmux_\STEM\_t mmux_\STEM\_inverse (mmux_\STEM\_t @var{OP})
@deftypefunx mmux_\STEM\_t mmux_\STEM\_absolute (mmux_\STEM\_t @var{OP})
@deftypefunx mmux_\STEM\_t mmux_\STEM\_modulo (mmux_\STEM\_t @vari{OP}, mmux_\STEM\_t @varii{OP})
@deftypefunx mmux_\STEM\_t mmux_\STEM\_remainder (mmux_\STEM\_t @vari{OP}, mmux_\STEM\_t @varii{OP})
@deftypefunx mmux_\STEM\_t mmux_\STEM\_incr (mmux_\STEM\_t @var{OP})
@deftypefunx mmux_\STEM\_t mmux_\STEM\_decr (mmux_\STEM\_t @var{OP})
Compute the addition, subtraction, multiplication, division, negation, inverse, absolute value,
modulo, increment, decrement.
@end deftypefun

@end macro

@c ------------------------------------------------------------------------

@macro MmuxDefineComplexArithmeticsFunc{CPLXSTEM,REALSTEM}
@deftypefun mmux_\CPLXSTEM\_t mmux_\CPLXSTEM\_add (mmux_\CPLXSTEM\_t @vari{OP}, mmux_\CPLXSTEM\_t @varii{OP})
@deftypefunx mmux_\CPLXSTEM\_t mmux_\CPLXSTEM\_sub (mmux_\CPLXSTEM\_t @vari{OP}, mmux_\CPLXSTEM\_t @varii{OP})
@deftypefunx mmux_\CPLXSTEM\_t mmux_\CPLXSTEM\_mul (mmux_\CPLXSTEM\_t @vari{OP}, mmux_\CPLXSTEM\_t @varii{OP})
@deftypefunx mmux_\CPLXSTEM\_t mmux_\CPLXSTEM\_div (mmux_\CPLXSTEM\_t @vari{OP}, mmux_\CPLXSTEM\_t @varii{OP})
@deftypefunx mmux_\CPLXSTEM\_t mmux_\CPLXSTEM\_neg (mmux_\CPLXSTEM\_t @var{OP})
@deftypefunx mmux_\CPLXSTEM\_t mmux_\CPLXSTEM\_inverse (mmux_\CPLXSTEM\_t @var{OP})
@deftypefunx mmux_\REALSTEM\_t mmux_\CPLXSTEM\_absolute (mmux_\CPLXSTEM\_t @var{OP})
Compute the addition, subtraction, multiplication, division, negation, inverse, absolute values.
@end deftypefun

@end macro

@c ------------------------------------------------------------------------

@macro MmuxDefineIntegerArithmeticsFunc{STEM}
@deftypefun mmux_\STEM\_t mmux_\STEM\_add (mmux_\STEM\_t @vari{OP}, mmux_\STEM\_t @varii{OP})
@deftypefunx mmux_\STEM\_t mmux_\STEM\_sub (mmux_\STEM\_t @vari{OP}, mmux_\STEM\_t @varii{OP})
@deftypefunx mmux_\STEM\_t mmux_\STEM\_mul (mmux_\STEM\_t @vari{OP}, mmux_\STEM\_t @varii{OP})
@deftypefunx mmux_\STEM\_t mmux_\STEM\_div (mmux_\STEM\_t @vari{OP}, mmux_\STEM\_t @varii{OP})
@deftypefunx mmux_\STEM\_t mmux_\STEM\_neg (mmux_\STEM\_t @var{OP})
@deftypefunx mmux_\STEM\_t mmux_\STEM\_inverse (mmux_\STEM\_t @var{OP})
@deftypefunx mmux_\STEM\_t mmux_\STEM\_absolute (mmux_\STEM\_t @var{OP})
@deftypefunx mmux_\STEM\_t mmux_\STEM\_modulo (mmux_\STEM\_t @vari{OP}, mmux_\STEM\_t @varii{OP})
@deftypefunx mmux_\STEM\_t mmux_\STEM\_incr (mmux_\STEM\_t @var{OP})
@deftypefunx mmux_\STEM\_t mmux_\STEM\_decr (mmux_\STEM\_t @var{OP})
Compute the addition, subtraction, multiplication, division, negation, inverse, absolute value,
modulo, increment, decrement.
@end deftypefun

@end macro

@c ------------------------------------------------------------------------

@MmuxDefineIntegerArithmeticsFunc{char}
@MmuxDefineIntegerArithmeticsFunc{schar}
@MmuxDefineIntegerArithmeticsFunc{uchar}
@MmuxDefineIntegerArithmeticsFunc{sshort}
@MmuxDefineIntegerArithmeticsFunc{ushort}
@MmuxDefineIntegerArithmeticsFunc{sint}
@MmuxDefineIntegerArithmeticsFunc{uint}
@MmuxDefineIntegerArithmeticsFunc{slong}
@MmuxDefineIntegerArithmeticsFunc{ulong}
@MmuxDefineIntegerArithmeticsFunc{sllong}
@MmuxDefineIntegerArithmeticsFunc{ullong}
@MmuxDefineIntegerArithmeticsFunc{sint8}
@MmuxDefineIntegerArithmeticsFunc{uint8}
@MmuxDefineIntegerArithmeticsFunc{sint16}
@MmuxDefineIntegerArithmeticsFunc{uint16}
@MmuxDefineIntegerArithmeticsFunc{sint32}
@MmuxDefineIntegerArithmeticsFunc{uint32}
@MmuxDefineIntegerArithmeticsFunc{sint64}
@MmuxDefineIntegerArithmeticsFunc{uint64}

@MmuxDefineIntegerArithmeticsFunc{byte}
@MmuxDefineIntegerArithmeticsFunc{octet}

@MmuxDefineIntegerArithmeticsFunc{ssize}
@MmuxDefineIntegerArithmeticsFunc{usize}
@MmuxDefineIntegerArithmeticsFunc{sintmax}
@MmuxDefineIntegerArithmeticsFunc{uintmax}
@MmuxDefineIntegerArithmeticsFunc{sintptr}
@MmuxDefineIntegerArithmeticsFunc{uintptr}
@MmuxDefineIntegerArithmeticsFunc{ptrdiff}
@MmuxDefineIntegerArithmeticsFunc{off}
@MmuxDefineIntegerArithmeticsFunc{wchar}
@MmuxDefineIntegerArithmeticsFunc{wint}
@MmuxDefineIntegerArithmeticsFunc{time}

@MmuxDefineNotIntegerRealArithmeticsFunc{flonumfl}
@MmuxDefineNotIntegerRealArithmeticsFunc{flonumdb}
@MmuxDefineNotIntegerRealArithmeticsFunc{flonumldb}

@MmuxDefineNotIntegerRealArithmeticsFunc{flonumf32}
@MmuxDefineNotIntegerRealArithmeticsFunc{flonumf64}
@MmuxDefineNotIntegerRealArithmeticsFunc{flonumf128}

@MmuxDefineNotIntegerRealArithmeticsFunc{flonumf32x}
@MmuxDefineNotIntegerRealArithmeticsFunc{flonumf64x}
@MmuxDefineNotIntegerRealArithmeticsFunc{flonumf128x}

@MmuxDefineNotIntegerRealArithmeticsFunc{flonumd32}
@MmuxDefineNotIntegerRealArithmeticsFunc{flonumd64}
@MmuxDefineNotIntegerRealArithmeticsFunc{flonumd128}

@MmuxDefineComplexArithmeticsFunc{flonumcfl,flonumfl}
@MmuxDefineComplexArithmeticsFunc{flonumcdb,flonumdb}
@MmuxDefineComplexArithmeticsFunc{flonumcldb,flonumldb}

@MmuxDefineComplexArithmeticsFunc{flonumcf32,flonumf32}
@MmuxDefineComplexArithmeticsFunc{flonumcf64,flonumf64}
@MmuxDefineComplexArithmeticsFunc{flonumcf128,flonumf128}

@MmuxDefineComplexArithmeticsFunc{flonumcf32x,flonumf32x}
@MmuxDefineComplexArithmeticsFunc{flonumcf64x,flonumf64x}
@MmuxDefineComplexArithmeticsFunc{flonumcf128x,flonumf128x}

@MmuxDefineComplexArithmeticsFunc{flonumcd32,flonumd32}
@MmuxDefineComplexArithmeticsFunc{flonumcd64,flonumd64}
@MmuxDefineComplexArithmeticsFunc{flonumcd128,flonumd128}

@c page
@node mathematics
@chapter Mathematical operations


If we want to compute the trigonometric cosine of a floating--point number we do:

@example
mmux_flonumdb_t   X = mmux_flonumdb_literal(0.123);
mmux_flonumdb_t   Y = mmux_flonumdb_cos(X);

mmux_flonumdb_dprintf(2, Y);    @print{} 0.992445
@end example

@noindent
or more generically:

@example
auto      X = mmux_flonumdb_literal(0.123);
auto      Y = mmux_ctype_cos(X);

mmux_ctype_dprintf(2, Y);       @print{} 0.992445
@end example

@menu
* mathematics trigonometry::    Trigonometric functions.
* mathematics hyperbolic::      Hyperbolic functions.
* mathematics exponentiation::  Exponentiation functions.
* mathematics logarithmic::     Logarithmic functions.
* mathematics powers::          Raising to the power functions.
* mathematics special::         Special functions.
@end menu

@c page
@node mathematics trigonometry
@section Trigonometric functions


@macro MmuxDefineMathRealTrigonometricFuncs{STEM}
@deftypefun mmux_\STEM\_t mmux_\STEM\_sin (mmux_\STEM\_t @var{OP})
@deftypefunx mmux_\STEM\_t mmux_\STEM\_cos (mmux_\STEM\_t @var{OP})
@deftypefunx mmux_\STEM\_t mmux_\STEM\_tan (mmux_\STEM\_t @var{OP})
@deftypefunx mmux_\STEM\_t mmux_\STEM\_asin (mmux_\STEM\_t @var{OP})
@deftypefunx mmux_\STEM\_t mmux_\STEM\_acos (mmux_\STEM\_t @var{OP})
@deftypefunx mmux_\STEM\_t mmux_\STEM\_atan (mmux_\STEM\_t @var{OP})
@deftypefunx mmux_\STEM\_t mmux_\STEM\_atan2 (mmux_\STEM\_t @vari{OP}, mmux_\STEM\_t @varii{OP})
Compute the named C function.
@end deftypefun

@end macro

@macro MmuxDefineMathCplxTrigonometricFuncs{STEM}
@deftypefun mmux_\STEM\_t mmux_\STEM\_sin (mmux_\STEM\_t @var{OP})
@deftypefunx mmux_\STEM\_t mmux_\STEM\_cos (mmux_\STEM\_t @var{OP})
@deftypefunx mmux_\STEM\_t mmux_\STEM\_tan (mmux_\STEM\_t @var{OP})
@deftypefunx mmux_\STEM\_t mmux_\STEM\_asin (mmux_\STEM\_t @var{OP})
@deftypefunx mmux_\STEM\_t mmux_\STEM\_acos (mmux_\STEM\_t @var{OP})
@deftypefunx mmux_\STEM\_t mmux_\STEM\_atan (mmux_\STEM\_t @var{OP})
Compute the named C function.
@end deftypefun

@end macro

@c ------------------------------------------------------------------------

@deftypefn {Generic Macro} mmux_ctype_t mmux_ctype_sin (mmux_ctype_t @var{OP})
@deftypefnx {Generic Macro} mmux_ctype_t mmux_ctype_cos (mmux_ctype_t @var{OP})
@deftypefnx {Generic Macro} mmux_ctype_t mmux_ctype_tan (mmux_ctype_t @var{OP})
@deftypefnx {Generic Macro} mmux_ctype_t mmux_ctype_asin (mmux_ctype_t @var{OP})
@deftypefnx {Generic Macro} mmux_ctype_t mmux_ctype_acos (mmux_ctype_t @var{OP})
@deftypefnx {Generic Macro} mmux_ctype_t mmux_ctype_atan (mmux_ctype_t @var{OP})
@deftypefnx {Generic Macro} mmux_ctype_t mmux_ctype_atan2 (mmux_ctype_t @vari{OP}, mmux_ctype_t @varii{OP})
Compute the named C function.  The type @objtype{mmux_ctype_t} is a placeholder for the type of the
operands and result.
@end deftypefn


@MmuxDefineMathRealTrigonometricFuncs{flonumfl}
@MmuxDefineMathRealTrigonometricFuncs{flonumdb}
@MmuxDefineMathRealTrigonometricFuncs{flonumldb}

@MmuxDefineMathRealTrigonometricFuncs{flonumf32}
@MmuxDefineMathRealTrigonometricFuncs{flonumf64}
@MmuxDefineMathRealTrigonometricFuncs{flonumf128}

@MmuxDefineMathRealTrigonometricFuncs{flonumf32x}
@MmuxDefineMathRealTrigonometricFuncs{flonumf64x}
@MmuxDefineMathRealTrigonometricFuncs{flonumf128x}

@MmuxDefineMathRealTrigonometricFuncs{flonumd32}
@MmuxDefineMathRealTrigonometricFuncs{flonumd64}
@MmuxDefineMathRealTrigonometricFuncs{flonumd128}

@MmuxDefineMathCplxTrigonometricFuncs{flonumcfl}
@MmuxDefineMathCplxTrigonometricFuncs{flonumcdb}
@MmuxDefineMathCplxTrigonometricFuncs{flonumcldb}

@MmuxDefineMathCplxTrigonometricFuncs{flonumcf32}
@MmuxDefineMathCplxTrigonometricFuncs{flonumcf64}
@MmuxDefineMathCplxTrigonometricFuncs{flonumcf128}

@MmuxDefineMathCplxTrigonometricFuncs{flonumcf32x}
@MmuxDefineMathCplxTrigonometricFuncs{flonumcf64x}
@MmuxDefineMathCplxTrigonometricFuncs{flonumcf128x}

@MmuxDefineMathCplxTrigonometricFuncs{flonumcd32}
@MmuxDefineMathCplxTrigonometricFuncs{flonumcd64}
@MmuxDefineMathCplxTrigonometricFuncs{flonumcd128}

@c page
@node mathematics hyperbolic
@section Hyperbolic functions


@macro MmuxDefineMathHyperbolicFuncs{STEM}
@deftypefun mmux_\STEM\_t mmux_\STEM\_sinh (mmux_\STEM\_t @var{OP})
@deftypefunx mmux_\STEM\_t mmux_\STEM\_cosh (mmux_\STEM\_t @var{OP})
@deftypefunx mmux_\STEM\_t mmux_\STEM\_tanh (mmux_\STEM\_t @var{OP})
@deftypefunx mmux_\STEM\_t mmux_\STEM\_asinh (mmux_\STEM\_t @var{OP})
@deftypefunx mmux_\STEM\_t mmux_\STEM\_acosh (mmux_\STEM\_t @var{OP})
@deftypefunx mmux_\STEM\_t mmux_\STEM\_atanh (mmux_\STEM\_t @var{OP})
Compute the named C function.
@end deftypefun

@end macro

@c ------------------------------------------------------------------------

@deftypefn {Generic Macro} mmux_ctype_t mmux_ctype_sinh (mmux_ctype_t @var{OP})
@deftypefnx {Generic Macro} mmux_ctype_t mmux_ctype_cosh (mmux_ctype_t @var{OP})
@deftypefnx {Generic Macro} mmux_ctype_t mmux_ctype_tanh (mmux_ctype_t @var{OP})
@deftypefnx {Generic Macro} mmux_ctype_t mmux_ctype_asinh (mmux_ctype_t @var{OP})
@deftypefnx {Generic Macro} mmux_ctype_t mmux_ctype_acosh (mmux_ctype_t @var{OP})
@deftypefnx {Generic Macro} mmux_ctype_t mmux_ctype_atanh (mmux_ctype_t @var{OP})
Compute the named C function.  The type @objtype{mmux_ctype_t} is a placeholder for the type of the
operand and result.
@end deftypefn


@MmuxDefineMathHyperbolicFuncs{flonumfl}
@MmuxDefineMathHyperbolicFuncs{flonumdb}
@MmuxDefineMathHyperbolicFuncs{flonumldb}

@MmuxDefineMathHyperbolicFuncs{flonumf32}
@MmuxDefineMathHyperbolicFuncs{flonumf64}
@MmuxDefineMathHyperbolicFuncs{flonumf128}

@MmuxDefineMathHyperbolicFuncs{flonumf32x}
@MmuxDefineMathHyperbolicFuncs{flonumf64x}
@MmuxDefineMathHyperbolicFuncs{flonumf128x}

@MmuxDefineMathHyperbolicFuncs{flonumd32}
@MmuxDefineMathHyperbolicFuncs{flonumd64}
@MmuxDefineMathHyperbolicFuncs{flonumd128}

@MmuxDefineMathHyperbolicFuncs{flonumcfl}
@MmuxDefineMathHyperbolicFuncs{flonumcdb}
@MmuxDefineMathHyperbolicFuncs{flonumcldb}

@MmuxDefineMathHyperbolicFuncs{flonumcf32}
@MmuxDefineMathHyperbolicFuncs{flonumcf64}
@MmuxDefineMathHyperbolicFuncs{flonumcf128}

@MmuxDefineMathHyperbolicFuncs{flonumcf32x}
@MmuxDefineMathHyperbolicFuncs{flonumcf64x}
@MmuxDefineMathHyperbolicFuncs{flonumcf128x}

@MmuxDefineMathHyperbolicFuncs{flonumcd32}
@MmuxDefineMathHyperbolicFuncs{flonumcd64}
@MmuxDefineMathHyperbolicFuncs{flonumcd128}

@c page
@node mathematics exponentiation
@section Exponentiation functions


@macro MmuxDefineMathRealExponentiationFuncs{STEM}
@deftypefun mmux_\STEM\_t mmux_\STEM\_exp (mmux_\STEM\_t @var{OP})
@deftypefunx mmux_\STEM\_t mmux_\STEM\_exp2 (mmux_\STEM\_t @var{OP})
@deftypefunx mmux_\STEM\_t mmux_\STEM\_exp10 (mmux_\STEM\_t @var{OP})
@deftypefunx mmux_\STEM\_t mmux_\STEM\_expm1 (mmux_\STEM\_t @var{OP})
Compute the named C function.
@end deftypefun

@end macro

@macro MmuxDefineMathCplxExponentiationFuncs{STEM}
@deftypefun mmux_\STEM\_t mmux_\STEM\_exp (mmux_\STEM\_t @var{OP})
@deftypefunx mmux_\STEM\_t mmux_\STEM\_exp2 (mmux_\STEM\_t @var{OP})
@deftypefunx mmux_\STEM\_t mmux_\STEM\_exp10 (mmux_\STEM\_t @var{OP})
Compute the named C function.
@end deftypefun

@end macro

@c ------------------------------------------------------------------------

@deftypefn {Generic Macro} mmux_ctype_t mmux_ctype_exp (mmux_ctype_t @var{OP})
@deftypefnx {Generic Macro} mmux_ctype_t mmux_ctype_exp2 (mmux_ctype_t @var{OP})
@deftypefnx {Generic Macro} mmux_ctype_t mmux_ctype_exp10 (mmux_ctype_t @var{OP})
@deftypefnx {Generic Macro} mmux_ctype_t mmux_ctype_expm1 (mmux_ctype_t @var{OP})
Compute the named C function.  The type @objtype{mmux_ctype_t} is a placeholder for the type of the
operand and result.
@end deftypefn


@MmuxDefineMathRealExponentiationFuncs{flonumfl}
@MmuxDefineMathRealExponentiationFuncs{flonumdb}
@MmuxDefineMathRealExponentiationFuncs{flonumldb}

@MmuxDefineMathRealExponentiationFuncs{flonumf32}
@MmuxDefineMathRealExponentiationFuncs{flonumf64}
@MmuxDefineMathRealExponentiationFuncs{flonumf128}

@MmuxDefineMathRealExponentiationFuncs{flonumf32x}
@MmuxDefineMathRealExponentiationFuncs{flonumf64x}
@MmuxDefineMathRealExponentiationFuncs{flonumf128x}

@MmuxDefineMathRealExponentiationFuncs{flonumd32}
@MmuxDefineMathRealExponentiationFuncs{flonumd64}
@MmuxDefineMathRealExponentiationFuncs{flonumd128}

@MmuxDefineMathCplxExponentiationFuncs{flonumcfl}
@MmuxDefineMathCplxExponentiationFuncs{flonumcdb}
@MmuxDefineMathCplxExponentiationFuncs{flonumcldb}

@MmuxDefineMathCplxExponentiationFuncs{flonumcf32}
@MmuxDefineMathCplxExponentiationFuncs{flonumcf64}
@MmuxDefineMathCplxExponentiationFuncs{flonumcf128}

@MmuxDefineMathCplxExponentiationFuncs{flonumcf32x}
@MmuxDefineMathCplxExponentiationFuncs{flonumcf64x}
@MmuxDefineMathCplxExponentiationFuncs{flonumcf128x}

@MmuxDefineMathCplxExponentiationFuncs{flonumcd32}
@MmuxDefineMathCplxExponentiationFuncs{flonumcd64}
@MmuxDefineMathCplxExponentiationFuncs{flonumcd128}

@c page
@node mathematics logarithmic
@section Logarithmic functions


@macro MmuxDefineMathRealLogarithmicFuncs{STEM}
@deftypefun mmux_\STEM\_t mmux_\STEM\_log (mmux_\STEM\_t @var{OP})
@deftypefunx mmux_\STEM\_t mmux_\STEM\_log2 (mmux_\STEM\_t @var{OP})
@deftypefunx mmux_\STEM\_t mmux_\STEM\_log10 (mmux_\STEM\_t @var{OP})
@deftypefunx mmux_\STEM\_t mmux_\STEM\_logb (mmux_\STEM\_t @var{OP})
@deftypefunx mmux_\STEM\_t mmux_\STEM\_log1p (mmux_\STEM\_t @var{OP})
Compute the named C function.
@end deftypefun

@end macro

@macro MmuxDefineMathCplxLogarithmicFuncs{STEM}
@deftypefun mmux_\STEM\_t mmux_\STEM\_log (mmux_\STEM\_t @var{OP})
@deftypefunx mmux_\STEM\_t mmux_\STEM\_log2 (mmux_\STEM\_t @var{OP})
@deftypefunx mmux_\STEM\_t mmux_\STEM\_log10 (mmux_\STEM\_t @var{OP})
Compute the named C function.
@end deftypefun

@end macro

@c ------------------------------------------------------------------------

@deftypefn {Generic Macro} mmux_ctype_t mmux_ctype_log (mmux_ctype_t @var{OP})
@deftypefnx {Generic Macro} mmux_ctype_t mmux_ctype_log2 (mmux_ctype_t @var{OP})
@deftypefnx {Generic Macro} mmux_ctype_t mmux_ctype_log10 (mmux_ctype_t @var{OP})
@deftypefnx {Generic Macro} mmux_ctype_t mmux_ctype_logb (mmux_ctype_t @var{OP})
@deftypefnx {Generic Macro} mmux_ctype_t mmux_ctype_log1p (mmux_ctype_t @var{OP})
Compute the named C function.  The type @objtype{mmux_ctype_t} is a placeholder for the type of the
operand and result.
@end deftypefn


@MmuxDefineMathRealLogarithmicFuncs{flonumfl}
@MmuxDefineMathRealLogarithmicFuncs{flonumdb}
@MmuxDefineMathRealLogarithmicFuncs{flonumldb}

@MmuxDefineMathRealLogarithmicFuncs{flonumf32}
@MmuxDefineMathRealLogarithmicFuncs{flonumf64}
@MmuxDefineMathRealLogarithmicFuncs{flonumf128}

@MmuxDefineMathRealLogarithmicFuncs{flonumf32x}
@MmuxDefineMathRealLogarithmicFuncs{flonumf64x}
@MmuxDefineMathRealLogarithmicFuncs{flonumf128x}

@MmuxDefineMathRealLogarithmicFuncs{flonumd32}
@MmuxDefineMathRealLogarithmicFuncs{flonumd64}
@MmuxDefineMathRealLogarithmicFuncs{flonumd128}

@MmuxDefineMathCplxLogarithmicFuncs{flonumcfl}
@MmuxDefineMathCplxLogarithmicFuncs{flonumcdb}
@MmuxDefineMathCplxLogarithmicFuncs{flonumcldb}

@MmuxDefineMathCplxLogarithmicFuncs{flonumcf32}
@MmuxDefineMathCplxLogarithmicFuncs{flonumcf64}
@MmuxDefineMathCplxLogarithmicFuncs{flonumcf128}

@MmuxDefineMathCplxLogarithmicFuncs{flonumcf32x}
@MmuxDefineMathCplxLogarithmicFuncs{flonumcf64x}
@MmuxDefineMathCplxLogarithmicFuncs{flonumcf128x}

@MmuxDefineMathCplxLogarithmicFuncs{flonumcd32}
@MmuxDefineMathCplxLogarithmicFuncs{flonumcd64}
@MmuxDefineMathCplxLogarithmicFuncs{flonumcd128}

@c page
@node mathematics powers
@section Raising to the power functions


@macro MmuxDefineMathPowersFuncs{STEM}
@deftypefun mmux_\STEM\_t mmux_\STEM\_pow (mmux_\STEM\_t @vari{OP}, mmux_\STEM\_t @varii{OP})
@deftypefunx mmux_\STEM\_t mmux_\STEM\_square (mmux_\STEM\_t @var{OP})
@deftypefunx mmux_\STEM\_t mmux_\STEM\_cube (mmux_\STEM\_t @var{OP})
@deftypefunx mmux_\STEM\_t mmux_\STEM\_sqrt (mmux_\STEM\_t @var{OP})
@deftypefunx mmux_\STEM\_t mmux_\STEM\_cbrt (mmux_\STEM\_t @var{OP})
Compute the named C function.
@end deftypefun

@end macro

@c ------------------------------------------------------------------------

@deftypefn {Generic Macro} mmux_ctype_t mmux_ctype_pow (mmux_ctype_t @vari{OP}, mmux_ctype_t @varii{OP})
@deftypefnx {Generic Macro} mmux_ctype_t mmux_ctype_square (mmux_ctype_t @var{OP})
@deftypefnx {Generic Macro} mmux_ctype_t mmux_ctype_cube (mmux_ctype_t @var{OP})
@deftypefnx {Generic Macro} mmux_ctype_t mmux_ctype_sqrt (mmux_ctype_t @var{OP})
@deftypefnx {Generic Macro} mmux_ctype_t mmux_ctype_cbrt (mmux_ctype_t @var{OP})
Compute the named C function.  The type @objtype{mmux_ctype_t} is a placeholder for the type of the
operands and result.
@end deftypefn


@MmuxDefineMathPowersFuncs{flonumfl}
@MmuxDefineMathPowersFuncs{flonumdb}
@MmuxDefineMathPowersFuncs{flonumldb}

@MmuxDefineMathPowersFuncs{flonumf32}
@MmuxDefineMathPowersFuncs{flonumf64}
@MmuxDefineMathPowersFuncs{flonumf128}

@MmuxDefineMathPowersFuncs{flonumf32x}
@MmuxDefineMathPowersFuncs{flonumf64x}
@MmuxDefineMathPowersFuncs{flonumf128x}

@MmuxDefineMathPowersFuncs{flonumd32}
@MmuxDefineMathPowersFuncs{flonumd64}
@MmuxDefineMathPowersFuncs{flonumd128}

@MmuxDefineMathPowersFuncs{flonumcfl}
@MmuxDefineMathPowersFuncs{flonumcdb}
@MmuxDefineMathPowersFuncs{flonumcldb}

@MmuxDefineMathPowersFuncs{flonumcf32}
@MmuxDefineMathPowersFuncs{flonumcf64}
@MmuxDefineMathPowersFuncs{flonumcf128}

@MmuxDefineMathPowersFuncs{flonumcf32x}
@MmuxDefineMathPowersFuncs{flonumcf64x}
@MmuxDefineMathPowersFuncs{flonumcf128x}

@MmuxDefineMathPowersFuncs{flonumcd32}
@MmuxDefineMathPowersFuncs{flonumcd64}
@MmuxDefineMathPowersFuncs{flonumcd128}

@c page
@node mathematics special
@section Special functions


@macro MmuxDefineMathSpecialFuncs{STEM}
@deftypefun mmux_\STEM\_t mmux_\STEM\_hypot (mmux_\STEM\_t @vari{OP}, mmux_\STEM\_t @varii{OP})
@deftypefunx mmux_\STEM\_t mmux_\STEM\_log1p (mmux_\STEM\_t @var{OP})
@deftypefunx mmux_\STEM\_t mmux_\STEM\_erf (mmux_\STEM\_t @var{OP})
@deftypefunx mmux_\STEM\_t mmux_\STEM\_erfc (mmux_\STEM\_t @var{OP})
@deftypefunx mmux_\STEM\_t mmux_\STEM\_lgamma (mmux_\STEM\_t @var{OP})
@deftypefunx mmux_\STEM\_t mmux_\STEM\_tgamma (mmux_\STEM\_t @var{OP})
@deftypefunx mmux_\STEM\_t mmux_\STEM\_j0 (mmux_\STEM\_t @var{OP})
@deftypefunx mmux_\STEM\_t mmux_\STEM\_j1 (mmux_\STEM\_t @var{OP})
@deftypefunx mmux_\STEM\_t mmux_\STEM\_jn (mmux_sint_t @var{N}, mmux_\STEM\_t @var{OP})
@deftypefunx mmux_\STEM\_t mmux_\STEM\_y0 (mmux_\STEM\_t @var{OP})
@deftypefunx mmux_\STEM\_t mmux_\STEM\_y1 (mmux_\STEM\_t @var{OP})
@deftypefunx mmux_\STEM\_t mmux_\STEM\_yn (mmux_sint_t @var{N}, mmux_\STEM\_t @var{OP})
Compute the named C function.
@end deftypefun

@end macro

@c ------------------------------------------------------------------------

@deftypefn {Generic Macro} mmux_ctype_t mmux_ctype_hypot (mmux_ctype_t @vari{OP}, mmux_ctype_t @varii{OP})
@deftypefnx {Generic Macro} mmux_ctype_t mmux_ctype_log1p (mmux_ctype_t @var{OP})
@deftypefnx {Generic Macro} mmux_ctype_t mmux_ctype_erf (mmux_ctype_t @var{OP})
@deftypefnx {Generic Macro} mmux_ctype_t mmux_ctype_erfc (mmux_ctype_t @var{OP})
@deftypefnx {Generic Macro} mmux_ctype_t mmux_ctype_lgamma (mmux_ctype_t @var{OP})
@deftypefnx {Generic Macro} mmux_ctype_t mmux_ctype_tgamma (mmux_ctype_t @var{OP})
@deftypefnx {Generic Macro} mmux_ctype_t mmux_ctype_j0 (mmux_ctype_t @var{OP})
@deftypefnx {Generic Macro} mmux_ctype_t mmux_ctype_j1 (mmux_ctype_t @var{OP})
@deftypefnx {Generic Macro} mmux_ctype_t mmux_ctype_jn (mmux_sint_t @var{N}, mmux_ctype_t @var{OP})
@deftypefnx {Generic Macro} mmux_ctype_t mmux_ctype_y0 (mmux_ctype_t @var{OP})
@deftypefnx {Generic Macro} mmux_ctype_t mmux_ctype_y1 (mmux_ctype_t @var{OP})
@deftypefnx {Generic Macro} mmux_ctype_t mmux_ctype_yn (mmux_sint_t @var{N}, mmux_ctype_t @var{OP})
Compute the named C function.  The type @objtype{mmux_ctype_t} is a placeholder for the type of the
operands and result.
@end deftypefn


@MmuxDefineMathSpecialFuncs{flonumfl}
@MmuxDefineMathSpecialFuncs{flonumdb}
@MmuxDefineMathSpecialFuncs{flonumldb}

@MmuxDefineMathSpecialFuncs{flonumf32}
@MmuxDefineMathSpecialFuncs{flonumf64}
@MmuxDefineMathSpecialFuncs{flonumf128}

@MmuxDefineMathSpecialFuncs{flonumf32x}
@MmuxDefineMathSpecialFuncs{flonumf64x}
@MmuxDefineMathSpecialFuncs{flonumf128x}

@MmuxDefineMathSpecialFuncs{flonumd32}
@MmuxDefineMathSpecialFuncs{flonumd64}
@MmuxDefineMathSpecialFuncs{flonumd128}

@c page
@node bitwise
@chapter Bitwise operations


Bitwise operations are implemented for exact integer types.  If we want to perform the bitwise
exclusive--OR operation on two integers we do:

@example
mmux_uint_t     A = mmux_uint_literal(0b111000);
mmux_uint_t     B = mmux_uint_literal(0b101010);
mmux_uint_t     C = mmux_uint_bitwise_xor(A, B);
mmux_uint_t     base = mmux_uint_literal(2);

mmux_uint_dprintf_with_base(2, C, base);        @print{} +10010
@end example

@noindent
or more generically:

@example
auto    A = mmux_uint_literal(0b111000);
auto    B = mmux_uint_literal(0b101010);
auto    C = mmux_ctype_bitwise_xor(A, B);
auto    base = mmux_uint_literal(2);

mmux_ctype_dprintf_with_base(2, C, base);       @print{} +10010
@end example


@deftypefn {Generic Macro} mmux_ctype_t mmux_ctype_bitwise_and (mmux_ctype_t @var{OP}, mmux_ctype_t @var{MASK})
@deftypefnx {Generic Macro} mmux_ctype_t mmux_ctype_bitwise_or (mmux_ctype_t @var{OP}, mmux_ctype_t @var{MASK})
@deftypefnx {Generic Macro} mmux_ctype_t mmux_ctype_bitwise_xor (mmux_ctype_t @var{OP}, mmux_ctype_t @var{MASK})
@deftypefnx {Generic Macro} mmux_ctype_t mmux_ctype_bitwise_not (mmux_ctype_t @var{OP})
@deftypefnx {Generic Macro} mmux_ctype_t mmux_ctype_bitwise_shl (mmux_ctype_t @var{OP}, mmux_sint_t @var{NBITS})
@deftypefnx {Generic Macro} mmux_ctype_t mmux_ctype_bitwise_shr (mmux_ctype_t @var{OP}, mmux_sint_t @var{NBITS})
Perform the bitwise operations on exact integer values.  The type @objtype{mmux_ctype_t} is a
placeholder for the type of the operands and result.
@end deftypefn


@deftypefun mmux_pointer_t mmux_pointer_bitwise_and (mmux_pointer_t @var{OP}, mmux_uintptr_t @var{MASK})
@deftypefunx mmux_pointer_t mmux_pointer_bitwise_or (mmux_pointer_t @var{OP}, mmux_uintptr_t @var{MASK})
@deftypefunx mmux_pointer_t mmux_pointer_bitwise_xor (mmux_pointer_t @var{OP}, mmux_uintptr_t @var{MASK})
@deftypefunx mmux_pointer_t mmux_pointer_bitwise_not (mmux_pointer_t @var{OP})
@deftypefunx mmux_pointer_t mmux_pointer_bitwise_shl (mmux_pointer_t @var{OP}, mmux_sint_t @var{NBITS})
@deftypefunx mmux_pointer_t mmux_pointer_bitwise_shr (mmux_pointer_t @var{OP}, mmux_sint_t @var{NBITS})
Perform the bitwise operations on a pointer value.
@end deftypefun


@macro MmuxDefineBitwiseFuncs{STEM}
@deftypefun mmux_\STEM\_t mmux_\STEM\_bitwise_and (mmux_\STEM\_t @vari{OP}, mmux_\STEM\_t @varii{OP})
@deftypefunx mmux_\STEM\_t mmux_\STEM\_bitwise_or (mmux_\STEM\_t @vari{OP}, mmux_\STEM\_t @varii{OP})
@deftypefunx mmux_\STEM\_t mmux_\STEM\_bitwise_xor (mmux_\STEM\_t @vari{OP}, mmux_\STEM\_t @varii{OP})
@deftypefunx mmux_\STEM\_t mmux_\STEM\_bitwise_not (mmux_\STEM\_t @var{OP})
@deftypefunx mmux_\STEM\_t mmux_\STEM\_bitwise_shl (mmux_\STEM\_t @var{OP}, mmux_sint_t @var{NBITS})
@deftypefunx mmux_\STEM\_t mmux_\STEM\_bitwise_shr (mmux_\STEM\_t @var{OP}, mmux_sint_t @var{NBITS})
Perform the bitwise operations.
@end deftypefun

@end macro

@MmuxDefineBitwiseFuncs{char}
@MmuxDefineBitwiseFuncs{schar}
@MmuxDefineBitwiseFuncs{uchar}
@MmuxDefineBitwiseFuncs{sshort}
@MmuxDefineBitwiseFuncs{ushort}
@MmuxDefineBitwiseFuncs{sint}
@MmuxDefineBitwiseFuncs{uint}
@MmuxDefineBitwiseFuncs{slong}
@MmuxDefineBitwiseFuncs{ulong}
@MmuxDefineBitwiseFuncs{sllong}
@MmuxDefineBitwiseFuncs{ullong}

@MmuxDefineBitwiseFuncs{sint8}
@MmuxDefineBitwiseFuncs{uint8}
@MmuxDefineBitwiseFuncs{sint16}
@MmuxDefineBitwiseFuncs{uint16}
@MmuxDefineBitwiseFuncs{sint32}
@MmuxDefineBitwiseFuncs{uint32}
@MmuxDefineBitwiseFuncs{sint64}
@MmuxDefineBitwiseFuncs{uint64}

@MmuxDefineBitwiseFuncs{byte}
@MmuxDefineBitwiseFuncs{octet}

@MmuxDefineBitwiseFuncs{ssize}
@MmuxDefineBitwiseFuncs{usize}
@MmuxDefineBitwiseFuncs{sintmax}
@MmuxDefineBitwiseFuncs{uintmax}
@MmuxDefineBitwiseFuncs{sintptr}
@MmuxDefineBitwiseFuncs{uintptr}
@MmuxDefineBitwiseFuncs{ptrdiff}
@MmuxDefineBitwiseFuncs{mode}
@MmuxDefineBitwiseFuncs{off}
@MmuxDefineBitwiseFuncs{pid}
@MmuxDefineBitwiseFuncs{uid}
@MmuxDefineBitwiseFuncs{gid}
@MmuxDefineBitwiseFuncs{wchar}
@MmuxDefineBitwiseFuncs{wint}
@MmuxDefineBitwiseFuncs{time}
@MmuxDefineBitwiseFuncs{socklen}
@MmuxDefineBitwiseFuncs{rlim}
@MmuxDefineBitwiseFuncs{ino}
@MmuxDefineBitwiseFuncs{dev}
@MmuxDefineBitwiseFuncs{nlink}
@MmuxDefineBitwiseFuncs{blkcnt}

@c page
@node generic
@chapter Miscellaneous generic macros


Notes on generic macros:

@itemize
@item
In the following documentation the type @objtype{mmux_ctype_t} is a placeholder for the actual type
of the operand.
@end itemize


@deftypefn {Generic Macro} bool mmux_ctype_is_signed (mmux_ctype_t @var{op})
Expand to @ctrue{} if @var{op} is a signed number, otherwise expand to @cfalse{}.  All the real and
complex floating--point numbers are considered signed numbers.

@example
auto    op = mmux_sint64_literal(123);

mmux_ctype_is_signed(op)        @expansion{} true
@end example
@end deftypefn


@deftypefn {Generic Macro} mmux_standard_ctype_t mmux_ctype_value (mmux_ctype_t @var{op})
For the types that are data structures with the field @code{value}, expand as follows:

@example
mmux_ctype_value(@var{op})      @expansion{} ((@var{op}).value)
@end example

@noindent
for the types that are unwrapped values, expand as follows:

@example
mmux_ctype_value(@var{op})      @expansion{} (@var{op})
@end example
@end deftypefn


@deftypefn {Generic Macro} bool mmux_ctype_is_unsigned (mmux_ctype_t @var{op})
Expand to @ctrue{} if @var{op} is an unsigned number, otherwise expand to @cfalse{}.  All the real
and complex floating--point numbers are considered signed numbers.

@example
auto    op = mmux_sint64_literal(123);

mmux_ctype_is_unsigned(op)      @expansion{} false
@end example
@end deftypefn


@deftypefn {Generic Macro} bool mmux_ctype_is_exact_integer (mmux_ctype_t @var{op})
Expand to @ctrue{} if @var{op} is an exact integer number, otherwise expand to @cfalse{}.  All the
real and complex floating--point numbers are not exact integers.

@example
auto    op = mmux_sint64_literal(123);

mmux_ctype_is_exact_integer(op) @expansion{} true
@end example
@end deftypefn


@deftypefn {Generic Macro} bool mmux_ctype_is_real_number (mmux_ctype_t @var{op})
Expand to @ctrue{} if @var{op} is a real number, otherwise expand to @cfalse{}.  All the exact
integers and flonums are real numbers.

@example
auto    op = mmux_sint64_literal(123);

mmux_ctype_is_real_number(op)   @expansion{} true
@end example
@end deftypefn


@deftypefn {Generic Macro} bool mmux_ctype_is_complex_number (mmux_ctype_t @var{op})
Expand to @ctrue{} if @var{op} is a complex number, otherwise expand to @cfalse{}.  All the exact
integers and flonums are @strong{not} complex numbers.

@example
auto    op = mmux_sint64_literal(123);

mmux_ctype_is_complex_number(op) @expansion{} false
@end example
@end deftypefn


@deftypefn {Generic Macro} bool mmux_ctype_is_flonum (mmux_ctype_t @var{op})
Expand to @ctrue{} if @var{op} is a flonum, otherwise expand to @cfalse{}.  All the types with stem
@samp{flonumfl}, @samp{flonumdb}, @samp{flonumldb}, @dots{} are flonums.

@example
auto    op = mmux_flonumldb_literal(1.23);

mmux_ctype_is_flonum(op)        @expansion{} true
@end example
@end deftypefn


@deftypefn {Generic Macro} bool mmux_ctype_is_flonumc (mmux_ctype_t @var{op})
Expand to @ctrue{} if @var{op} is a flonumc, otherwise expand to @cfalse{}.  All the types with stem
@samp{flonumcfl}, @samp{flonumcdb}, @samp{flonumcldb}, @dots{} are flonumcs.

@example
auto    op = mmux_flonumcdb_literal(1.23, 4.56);

mmux_ctype_is_flonumc(op)       @expansion{} true
@end example
@end deftypefn


@deftypefn {Generic Macro} mmux_asciizcp_t mmux_ctype_typedef_name (mmux_ctype_t @var{op})
Expand to a pointer to a statically allocated @asciiz{} string representing the name of the type.

@example
auto    op = mmux_flonumcdb_literal(1.23, 4.56);

mmux_ctype_typedef_name(op)       @expansion{} "mmux_flonumcdb_t"
@end example
@end deftypefn


@deftypefn {Generic Macro} mmux_asciizcp_t mmux_ctype_stem_name (mmux_ctype_t @var{op})
Expand to a pointer to a statically allocated @asciiz{} string representing the name of the type
stem.

@example
auto    op = mmux_flonumcdb_literal(1.23, 4.56);

mmux_ctype_typedef_name(op)       @expansion{} "flonumcdb"
@end example
@end deftypefn

@c page
@c ------------------------------------------------------------
@c Appendices.
@c ------------------------------------------------------------

@include gpl-3.0.texi
@include fdl-1.3.texi

@c page
@node references
@appendix Bibliography and references


The documentation of @value{PACKAGE} is available online:

@center @value{DocumentationUrl}

@noindent
development takes place at:

@center @value{GithubUrl}

The package @emph{Decimal Floating Point C Library}, @code{libdfp}, is available online:

@center @url{https://github.com/libdfp/libdfp}

@c page
@node concept index
@appendix An entry for each concept

@printindex cp

@node function index
@appendix An entry for each function.

@printindex fn

@node variable index
@appendix An entry for each variable.

@printindex vr

@node type index
@appendix An entry for each type.

@printindex tp

@contents
@bye

@c end of file

